// Copyright 2018-2022 The Khronos Group Inc.
// SPDX-License-Identifier: CC-BY-4.0

= KHR_materials_sheen
:tmtitle: pass:q,r[^™^]
:regtitle: pass:q,r[^®^]
The Khronos{regtitle} 3D Formats Working Group
:data-uri:
:icons: font
:toc2:
:toclevels: 10
:sectnumlevels: 10
:max-width: 100%
:numbered:
:source-highlighter: coderay
:docinfo: shared-head
:docinfodir: ../..
:stem:

// :xrefstyle: short
// :listing-caption: Listing
:leveloffset: 1

= Contributors

  * Sebastien Vandenberghe, Microsoft, https://github.com/sebavan[@sebavan]
  * Alexis Vaginay, Microsoft, https://github.com/Popov72[@Popov72]
  * Tobias Häußler, Dassault System, https://github.com/proog128[@proog128]
  * Ed Mackey, Analytical Graphics, Inc.
  * Romain Guy, Google, https://github.com/romainguy[@romainguy]
  * Mike Bond, Adobe, https://github.com/MiiBond[@MiiBond]
  * Don McCurdy, Google, https://twitter.com/donrmccurdy[@donmccurdy]
  * Gary Hsu, Microsoft, https://twitter.com/bghgary[@bghgary]
  * Jekfer Bichon, Dassault System, https://github.com/EliphasNUIT[@EliphasNUIT]
  * Aidin Abedi, Animech, https://github.com/aidinabedi[@aidinabedi]

Copyright 2018-2022 The Khronos Group Inc. All Rights Reserved. glTF is a trademark of The Khronos Group Inc.
See <<full-copyright, the appendix>> for the full Khronos Copyright Statement.

= Status

Complete, Ratified by the Khronos Group

= Dependencies

Written against the glTF 2.0 spec.

= Exclusions
  * This extension must not be used on a material that also uses `KHR_materials_pbrSpecularGlossiness`.
  * This extension must not be used on a material that also uses `KHR_materials_unlit`.

= Overview

This extension defines a sheen that can be layered on top of an existing glTF material definition. A sheen layer is a common technique used in Physically-Based Rendering to represent cloth and fabric materials, for example. See <<theory-documentation-and-implementations, Theory, Documentation and Implementations>>.

= Extending Materials

The PBR sheen materials are defined by adding the `KHR_materials_sheen` extension to any compatible glTF material (excluding those listed above).
For example, the following defines a material like velvet.

[source,json]
----
{
    "materials": [
        {
            "name": "velvet",
            "extensions": {
                "KHR_materials_sheen": {
                    "sheenColorFactor": [0.9, 0.9, 0.9]
                }
            }
        }
    ]
}
----

== Sheen

The following parameters are contributed by the `KHR_materials_sheen` extension:

[options="header"]
|====
|                         | Type                                                                                               | Description                          | Required
| *sheenColorFactor*      | `array`                                                                                            | The sheen color in linear space      | No, default: `[0.0, 0.0, 0.0]`
| *sheenColorTexture*     | https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#reference-textureinfo[`textureInfo`] | The sheen color (RGB). The sheen color is in sRGB transfer function | No
| *sheenRoughnessFactor*  | `number`                                                                                           | The sheen roughness.                 | No, default: `0.0`
| *sheenRoughnessTexture* | https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#reference-textureinfo[`textureInfo`] | The sheen roughness (Alpha) texture. | No
|====

The sheen BRDF is layered on top of the glTF 2.0 Metallic-Roughness material. If clearcoat (`KHR_materials_clearcoat`) is active at the same time, clearcoat is layered on top of sheen. The `sheenColorFactor` determines the view-independent intensity of the sheen BRDF. If `sheenColorFactor` is zero, the whole sheen layer is disabled. Implementations of the BRDF itself can vary based on device performance and resource constraints.

If a texture is defined:

  * The sheen color is computed with : `sheenColor = sheenColorFactor * sampleLinear(sheenColorTexture).rgb`.
  * The sheen roughness is computed with : `sheenRoughness = sheenRoughnessFactor * sample(sheenRoughnessTexture).a`.

Otherwise, `sheenColor = sheenColorFactor` and `sheenRoughness = sheenRoughnessFactor`

The sheen BRDF simulates the back-scattering of velvet-like materials. The specular response from velvet-like materials can be modeled as the reflection from specular, cylindrical micro-fibers mainly oriented in the normal direction <<Westin1992, Westin et al. (1992)>>. This results in a forest of narrow cylinders extending from a fabric base. The sheen roughness determines how much the micro-fibers diverge from this direction. A small roughness means that the random perturbation around the normal direction is small, resulting in a sharp specular response around grazing angles. A large roughness on the other hand results in a smooth specular response around grazing angles. To model the specular response from micro-fibers, we use the exponentiated sinusoidal distribution term introduced by <<ContyKulla2017, Conty and Kulla (2017)>> which is based on microfacet theory. We use the mapping `r = sheenRoughness^2` which results in more perceptually linear changes in the roughness.

The sheen roughness is independent from the material roughness to allow materials like this one, with high material roughness and small sheen roughness:

.Cushion
image::figures/cushion.png[align="left"]

Not all incoming light is reflected at a micro-fiber. Some of the light may hit the base layer, either directly or as a result of multiple bounces on the micro-geometry. Light that hits the base layer behaves as specified in the glTF 2.0 Metallic-Roughness material.

= Implementation Notes

_This section is non-normative._

All implementations should use the same calculations for the BRDF inputs. See https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#appendix-b-brdf-implementation[Appendix B] for more details on the BRDF calculations.

The sheen formula `f_sheen` follows the common microfacet form:

latexmath:[f_{sheen} = \text{sheenColor} \times \text{sheenFresnel} \times \text{sheenDistribution} \times \text{sheenVisibility} = \text{sheenColor} \times F_S \times G_S \times D_S / (4 \times \left| N \cdot L \right|) \times \left| N \cdot V \right|]

== Sheen distribution

The sheen distribution follows the "`Charlie`" sheen definition from ImageWorks <<ContyKulla2017, Conty and Kulla (2017)>>:

[source,glsl]
----
alphaG = sheenRoughness * sheenRoughness
invR = 1 / alphaG
cos2h = NdotH * NdotH
sin2h = 1 - cos2h
sheenDistribution = (2 + invR) * pow(sin2h, invR * 0.5) / (2 * PI);
----

== Sheen visibility

The "`Charlie`" sheen visibility is also defined in the same document:

[source,glsl]
----
float l(float x, float alphaG)
{
    float oneMinusAlphaSq = (1.0 - alphaG) * (1.0 - alphaG);
    float a = mix(21.5473, 25.3245, oneMinusAlphaSq);
    float b = mix(3.82987, 3.32435, oneMinusAlphaSq);
    float c = mix(0.19823, 0.16801, oneMinusAlphaSq);
    float d = mix(-1.97760, -1.27393, oneMinusAlphaSq);
    float e = mix(-4.32054, -4.85967, oneMinusAlphaSq);
    return a / (1.0 + b * pow(x, c)) + d * x + e;
}

float lambdaSheen(float cosTheta, float alphaG)
{
    return abs(cosTheta) < 0.5 ? exp(l(cosTheta, alphaG)) : exp(2.0 * l(0.5, alphaG) - l(1.0 - cosTheta, alphaG));
}

sheenVisibility = 1.0 / ((1.0 + lambdaSheen(NdotV, alphaG) + lambdaSheen(NdotL, alphaG)) * (4.0 * NdotV * NdotL));
----

However, depending on device performance and resource constraints, one can use a simpler visibility term, like the one defined by <<AshikhminPremoze2007, Ashikhmin and Premoze (2007)>> (but that will make the BRDF not energy conserving when using the albedo-scaling technique described below):

[source,glsl]
----
sheenVisibility = 1 / (4 * (NdotL + NdotV - NdotL * NdotV))
----

== Sheen Fresnel

The Fresnel term may be omitted, i.e., latexmath:[F = 1].

== Sheen layering

=== Albedo-scaling technique

The sheen layer can be combined with the base layer with an albedo-scaling technique described in <<ContyKulla2017, Conty and Kulla (2017)>>. The base layer latexmath:[f_{diffuse} + f_{specular}] from https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#appendix-b-brdf-implementation[Appendix B] is scaled with _sheenAlbedoScaling_ to avoid energy gain.

latexmath:[f = f_{sheen} + (f_{diffuse} + f_{specular}) \times \text{sheenAlbedoScaling}]

[source,glsl]
----
float max3(vec3 v) { return max(max(v.x, v.y), v.z); }

sheenAlbedoScaling = min(1.0 - max3(sheenColor) * E(VdotN), 1.0 - max3(sheenColor) * E(LdotN))
----

The values `E(x)` can be looked up in a table which can be found in section 6.2.3 of <<enterprise2021, Enterprise PBR Shading Model>> if you use the "`Charlie`" visibility term. If you use Ashikhmin instead, you can get the lookup table by using the <<cmgen-filament, cmgen tool from Filament>>, with the `--ibl-dfg` and `--ibl-dfg-cloth` flags: the table is in the blue channel of the generated picture. The lookup must be done with `x = VdotN` and `y = sheenRoughness`.

If you want to trade a bit of accuracy for more performance, you can use the `VdotN` term only and thus avoid doing multiple lookups for `LdotN`. The albedo scaling term is simplified to:

[source,glsl]
----
sheenAlbedoScaling = 1.0 - max3(sheenColor) * E(VdotN)
----

In this simplified form, it can be used to scale the base layer for both direct and indirect lights:

[source,glsl]
----
specular_direct *= sheenAlbedoScaling;
diffuse_direct *= sheenAlbedoScaling;
environmentIrradiance_indirect *= sheenAlbedoScaling
specularEnvironmentReflectance_indirect *= sheenAlbedoScaling
----

= References

[[theory-documentation-and-implementations]]
== Theory, Documentation and Implementations

 * [[Westin1992]] http://www.graphics.cornell.edu/~westin/pubs/siggraph-rebuild.pdf[Stephen H. Westin, James R. Arvo, Kenneth E. Torrance -- "`Predicting Reflectance Functions from Complex Surfaces`", SIGGRAPH 1992]
 * [[ContyKulla2017]] https://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_sheen.pdf[Alejandro Conty Estevez, Christopher Kulla -- "`Production Friendly Microfacet Sheen BRDF`", SIGGRAPH 2017]
 * [[AshikhminPremoze2007]] http://www.cs.utah.edu/~premoze/dbrdf/dBRDF.pdf[Michael Ashikhmin, Simon Premoze -- "`Distribution-based BRDFs`", 2007]
 * https://google.github.io/filament/Materials.md.html#materialmodels/clothmodel[Filament Material models - Cloth model]
 * [[cmgen-filament]] https://github.com/google/filament[cmgen tool from Filament]
 * https://blog.selfshadow.com/publications/s2013-shading-course/rad/s2013_pbs_rad_notes.pdf[David Neubelt, Matt Pettineo -- "`Crafting a Next-Gen Material Pipeline for The Order: 1886`", SIGGRAPH 2013]
 * https://knarkowicz.wordpress.com/2018/01/04/cloth-shading/[cloth-shading]
 * [[enterprise2021]] https://dassaultsystemes-technology.github.io/EnterprisePBRShadingModel/spec-2021x.md.html#components/sheen[Enterprise PBR Shading Model - Sheen]

:numbered!:

[appendix]
[[full-copyright]]
= Full Khronos Copyright Statement

:copyyears: 2018-2022
include::../../speccopyright.txt[]
