<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="khrtextureprocedurals">KHR_texture_procedurals</h1>
<h2 id="contributors">Contributors</h2>
<ul>
<li>Ashwin Bhat, Autodesk, ashwin.bhat@autodesk.com</li>
<li>Alexey Knyazev, Individual Contributor, <a href="https://github.com/lexaknyazev">@lexaknyazev</a></li>
<li>Bernard Kwok, Individual Contributor, <a href="https://github.com/kwokcb">@kwokcb</a></li>
<li>Ed Mackey, AGI, <a href="https://twitter.com/emackey">@emackey</a></li>
<li>Lutz Kettner, NVIDIA, lkettner@nvidia.com</li>
<li>Richard Sahlin, IKEA <a href="https://github.com/rsahlin">@rsahlin</a></li>
<li>Timothy Blut, NVIDIA, tblut@nvidia.com</li>
</ul>
<p>Copyright 2024 The Khronos Group Inc.<br>
See <a href="#appendix-full-khronos-copyright-statement">Appendix</a> for full Khronos Copyright Statement.</p>
<h2 id="status">Status</h2>
<p>Draft</p>
<h2 id="dependencies">Dependencies</h2>
<p>Written against the glTF 2.0 spec.</p>
<h2 id="overview">Overview</h2>
<p>This extension provides a standardized way to represent<br>
procedural graphs which can be mapped to material channels in glTF.</p>
<h3 id="motivation">Motivation</h3>
<p>Textures represented as procedural graphs provides a way to extend the capabilities of glTF materials beyond what is possible with traditional texture maps. Key objectives includes:</p>
<ol>
<li>
<p><strong>Interoperability</strong>: Adhere to an industry a standard node schema (MaterialX) with a runtime friendly JSON representation.</p>
<p>More specifically <strong>only</strong> nodes defined in the MaterialX specification are supported. This ensures that the procedural graphs can be easily converted to MaterialX and USDShade graphs.</p>
<p>For the first version of this extension nodes which are used to define shading models are not allowed. Please refer to the <a href="#resources">resources</a> section for links to supported  MaterialX node definitions.</p>
</li>
<li>
<p><strong>Fidelity</strong>: Provide the ability to generate complex patterns, noise, or other effects that are currently must be &quot;baked&quot; into texture maps. Reduce in runtime memory usage by generating textures programmatically.</p>
</li>
<li>
<p><strong>Editability and Extensibility</strong>: Extend runtime editability by exposing logic and interfaces for procedural graphs as well as providing a means to create new or extend existing node definitions.</p>
</li>
<li>
<p><strong>Validity</strong>: Ensure that procedurals graphs can be validated both against a schema as well as against reference rendering implementations.</p>
</li>
</ol>
<h3 id="definitions">Definitions</h3>
<p>The following is a set of definitions using MaterialX nomenclature to provide context for the procedural graph representation.</p>
<ul>
<li>
<p>A <strong>Node</strong> is a function that generates or operates upon spatially-varying data.  The MaterialX specification provides the set of standard nodes with precise definitions and also supports the creation of custom nodes.</p>
</li>
<li>
<p><strong>Node Input and Output Ports</strong> The interface for a node’s incoming data is declared through <strong>input ports</strong>, which may be spatially-varying or uniform. The interface for a node’s outgoing data is declared through <strong>output ports</strong>.</p>
</li>
<li>
<p>There is a specific set of supported <strong>Data Types</strong>. Every port must have a data type.</p>
</li>
<li>
<p>A <strong>Pattern</strong> is a node that generates or processes simple scalar, vector, and color data, and has access to local properties of any geometry that has been bound to a given material.</p>
</li>
<li>
<p>A <strong>Node Graph</strong> is a directed acyclic graph (DAG) of nodes, which may be used to define arbitrarily complex generation or processing networks.  Node Graphs describe a network of &quot;pattern&quot; nodes flowing into shader inputs, or to define a complex or layered node in terms of simpler nodes. The former is called a <strong>compound nodegraph</strong> and the latter a <strong>functional nodegraph</strong>.</p>
</li>
<li>
<p>A Node Graphs's:</p>
<ul>
<li><strong>Inputs</strong> are nodes that define the interface for a node graph’s incoming data.</li>
<li><strong>Outputs</strong> are nodes that define the interface for a node graph’s outgoing data.</li>
</ul>
</li>
<li>
<p>A <strong>Node Definition</strong> is a specification for a unique function with a given set of input and output ports. The logic for each functions is represented either as a <code>functional graph</code> or as shader code.</p>
</li>
</ul>
<h2 id="extension-declaration">Extension Declaration</h2>
<p>To use the extension the <code>KHR_texture_procedurals</code> extension identifier must be added to the <code>extensionsUsed</code> array in the asset object.</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"extensionsUsed"</span>: [
        <span class="hljs-string">"KHR_texture_procedurals"</span>
    ]
}
</div></code></pre>
<p>with the extension object defined as follows:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"extensions"</span>: {
        <span class="hljs-attr">"KHR_texture_procedurals"</span>: {
            <span class="hljs-attr">"mimetype"</span>: <span class="hljs-string">"application/mtlx+json;version=&lt;MaterialX_version&gt;"</span>,
            <span class="hljs-attr">"procedurals"</span>: []
        }
    }
}
</div></code></pre>
<p>It is assumed that a mimetype is always required. As part of the mimetype a version <code>&lt;MaterialX_version&gt;</code> is specified. This is the version of the MaterialX library specification used when writing to glTF. The version is specified as a string in the form of <code>&lt;major&gt;.&lt;minor&gt;</code>. For example, if the MaterialX library version is 1.39, the mimetype would be <code>application/mtlx+json;version=1.39</code>.</p>
<p>This corresponds to the following XML element in MaterialX:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">materialx</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.39"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">materialx</span>&gt;</span>
</div></code></pre>
<p>The version in the mimetype <strong>is not</strong> the extension version. If in the future the schema needs to be modified (perhaps due to changes in MaterialX) then a new extension version would be required.</p>
<p>The <code>procedurals</code> array specifies the procedural graphs that are used in the glTF asset.</p>
<h2 id="representation">Representation</h2>
<p>For all applicable JSON objects, any / all supported MaterialX  meta-data information may be specified. This includes information such as UI hints, node placement, and documentation, colorspace, and real world units to support interoperability or editability.</p>
<p>Information which is used for resolving input data identifiers is not supported. For example specification of a <code>fileprefix</code> at the graph level is not supported.</p>
<p>Tooling is expected to pre-resolve all resource identifiers for images and streams appropriately.</p>
<h3 id="data-types">Data Types</h3>
<p>The supported data types are:</p>
<ul>
<li>single <code>float</code></li>
<li>single <code>integer</code></li>
<li>tuples:
<ul>
<li><code>color3</code>, <code>color4</code> : 3 and 4 channel color</li>
<li><code>vector2</code>, <code>vector3</code>, <code>vector4</code> : 2, 3, 4 channel float vector</li>
<li><code>integer2</code>, <code>integer3</code>, <code>integer4</code> : 2, 3, 4 channel integer vector</li>
</ul>
</li>
<li>matrix:
<ul>
<li><code>matrix3x3</code>, and <code>matrix4x4</code> : Matrices of floats of size 3 or 4.</li>
</ul>
</li>
</ul>
<p>Tuples and matrices are represented as arrays of values. For example, a <code>color3</code> is represented as an array of 3 floats.</p>
<h3 id="%22procedural%22-graphs">&quot;Procedural&quot; Graphs</h3>
<p>One ore more procedurals graphs can be defined in the <code>procedurals</code> array.</p>
<p>A graph <strong>cannot</strong> be nested (contain another graph), as is allowed for <em>OpenUSD</em> for instance. Any such configurations must be “flattened” to single level graphs. ( As MaterialX does not support nested graphs OpenUSD utilities perform flattening upon conversion to MaterialX. )</p>
<p>Each procedural graph object is composed of:</p>
<ul>
<li>An optional string <code>name</code> identifier</li>
<li>A <code>nodetype</code> which must be <code>nodegraph</code></li>
<li>A <code>type</code> which is the output type of the graph. This is a supported data type, or <code>multioutput</code> if there is more than one output node for the graph.</li>
<li>A set of children nodes:
<ul>
<li><code>inputs</code> input &quot;interface&quot; nodes for passing data into the graph.</li>
<li><code>outputs</code> output &quot;interface&quot; nodes for passing data out of the graph.</li>
<li><code>nodes</code> processing nodes.</li>
</ul>
</li>
</ul>
<p>The structure of atomic nodes is described in  <a href="#procedural-nodes">&quot;Procedural&quot; Nodes</a> section.</p>
<p>Note that input and output node types are <code>input</code> and <code>output</code> respectively.</p>
<h4 id="procedural-graph-object">Procedural Graph Object</h4>
<pre class="hljs"><code><div>{ 
  name<span class="hljs-attr">": "</span>my_procedural<span class="hljs-attr">", 
  "</span>nodetype<span class="hljs-attr">": "</span>nodegraph<span class="hljs-attr">",
  "</span>type<span class="hljs-attr">": "</span>&lt;data-type&gt;<span class="hljs-attr">",
  "</span>inputs<span class="hljs-attr">": [...list of input nodes...],
  "</span>outputs<span class="hljs-attr">": [...list of output nodes...],
  "</span>nodes<span class="hljs-attr">": [...List of processing nodes...],
}
</span></div></code></pre>
<h3 id="%22procedural%22-nodes">&quot;Procedural&quot; Nodes</h3>
<ul>
<li>
<p>An atomic function is represented as a single node with the following properties:</p>
<ul>
<li>
<p>An optional string <code>name</code> identifier</p>
</li>
<li>
<p>A <code>nodetype</code> which is a string identifier for the node type. This is a MaterialX node type or a custom node type.</p>
</li>
<li>
<p>A <code>type</code> which is the output type of the node. This is a supported data type or <code>multioutput</code> if there is more than one output port on a node.</p>
</li>
<li>
<p>A list of input ports under an <code>inputs</code> array.<br>
If an input is specified it's input value overrides that of the node definition default.</p>
</li>
<li>
<p>A list of output ports under an <code>outputs</code> array. Every output port defined for the corresponding node definition must be specified.</p>
</li>
</ul>
<ul>
<li>Each port:
<ul>
<li>Must have a node type: <code>input</code> for input ports and <code>output</code> for output ports.</li>
<li>May have an optional string name identifier</li>
<li>Must have a type which is a supported data type.</li>
<li>Either:
<ul>
<li>A <code>value</code> which is a constant value for the node. or</li>
<li>A connection which can either be:
<ul>
<li>A index</li>
</ul>
</li>
</ul>
</li>
<li>An <code>input</code> which is a reference to another node in the graph. This is only valid for <code>output</code> nodes.</li>
</ul>
</li>
</ul>
<ul>
<li>All output ports specified on a node’s corresponding definition must be specified for each node instance.</li>
</ul>
</li>
</ul>
<h4 id="procedural-graph-node">Procedural Graph Node</h4>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"&lt;node name&gt;"</span>,
  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"&lt;node type&gt;"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"&lt;data type&gt;"</span>,
  <span class="hljs-attr">"inputs"</span>: [...optional list of input ports...],
  <span class="hljs-attr">"outputs"</span>: [...required list of output ports...]
}
</div></code></pre>
<p>Where an input port has the following structure:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"&lt;input name&gt;"</span>,
  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"&lt;data type&gt;"</span>,
  <span class="hljs-attr">"value"</span>: &lt;value&gt; or
  <span class="hljs-string">"node"</span>: &lt;processing node index&gt; or
  <span class="hljs-string">"input"</span>: &lt;input node index&gt;
  <span class="hljs-string">"output"</span>: &lt;output node index&gt;
}
</div></code></pre>
<p>and an output port has the following structure:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"&lt;input name&gt;"</span>,
  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"&lt;data type&gt;"</span>,
}
</div></code></pre>
<h3 id="internal-graph-connections">Internal Graph Connections</h3>
<p>Connections inside a graph can be made between:</p>
<ul>
<li>Between an <code>nodegraph input</code> and a <code>node input</code></li>
<li>Between a node <code>output</code> and an <code>nodegraph output</code></li>
<li>Between a node <code>output</code> and a <code>node input</code>.</li>
</ul>
<h3 id="downstream-material-connections">Downstream Material Connections</h3>
<ul>
<li>
<p>A glTF material requires a root surface shader node. For MaterialX this must be a glTF PBR node (<code>gltf_pbr)</code>. For OpenUSD this would be the equivalent <code>Shader</code>’s identifier would be: <code>info:id=ND_gltf_pbr</code>.</p>
</li>
<li>
<p>Any root node input can be connected to a <code>procedural</code> graph output <strong>if</strong> the PBR node input can currently accept an input texture binding.</p>
</li>
</ul>
<h3 id="upstream-input-connections">Upstream Input Connections</h3>
<p>A procedural graph's <code>input</code>s nodes can either be bound to</p>
<ul>
<li>A uniform value.</li>
<li>A texture</li>
<li>A geometric stream: An input reference to a stream is specified using a meshes <code>primitive</code> index number.</li>
</ul>
<h4 id="uniform-binding">Uniform Binding</h4>
<p>Either constant or animated value may be bound.</p>
<p>It is assumed that the existing animation declarations can be used to reference the procedural input. (TBD if a sampler <code>target</code> can be used to reference a procedural graph input)</p>
<h4 id="texture-binding">Texture Binding</h4>
<p>An <code>input</code> reference to an image is represented by an index to a <code>texture</code> element  within the <code>textures</code> array object. If mapping from a MaterialX <code>filename</code>, then this <code>filename</code> string is used as the corresponding <code>image</code> source.</p>
<p>Placement is specified by the procedural graph and <strong>supersedes</strong> any placement information on the texture reference. That is, texture transforms are procedural in nature are not &quot;baked&quot; into  a single texture coordinate matrix transform.</p>
<h4 id="input-stream-binding">Input Stream Binding</h4>
<p>Streams must be explicitly specified by a procedural node as such as a <code>texcoord</code> node for texture coordinates.<br>
There are two variants of such nodes:</p>
<ol>
<li>Ones which specify the stream by index</li>
<li>Ones which specify the stream by string identifier.<br>
Only the first is supported.</li>
</ol>
<p>The index is a zero-based index used to lookup the corresponding stream type in a bound mesh's <code>primitives</code> array.</p>
<p>For the texture coordinate example if the stream id is 1, then implementations must check for a stream with a label of <code>TEXCOORD_1</code> in a given meshes primitives. The mesh to search would be the one assigned to the material using the procedural graph.</p>
<p>As another example a <code>geomcolor</code> node would be used to specify a color stream. A value of 1 means that an implicit binding to color stream <code>COLOR_1</code> is desired.</p>
<h3 id="a-procedural-definition">A “Procedural Definition”</h3>
<p>Procedural definitions specify the interfaces (inputs and outputs) and its associated node graph implementation. This allows for custom definitions to be specified within a glTF document.</p>
<p>The structure for declaring definitions matches that used in MaterialX. This allows for these definitions to be convertible back into MaterialX and hence be consumable by UsdMtlx to create OpenUSD SDR (shading node registry) entries. That is, it is possible to create custom definitions within glTF which are inherently supported by OpenUSD integrations which support MaterialX definitions.</p>
<ul>
<li>A procedural definition element is composed of:
<ul>
<li>0 or more inputs</li>
<li>1 or more outputs</li>
<li>a definition identifier or “category”</li>
<li>an output type</li>
<li>a globally unique identifier</li>
</ul>
</li>
</ul>
<p>Nodes of a given procedural definition category can be instantiated in the exact same manner as definitions which come provided by MaterialX libraries.</p>
<h3 id="json">JSON</h3>
<ul>
<li>
<p>A flat <code>procedurals</code> structure (<strong>array</strong>):</p>
<ul>
<li>Contains one or more <code>procedural graphs</code></li>
<li>For a given graph:</li>
</ul>
</li>
<li>
<p>An optional read-only flat **procedural_definitions **structure (<strong>array</strong>):</p>
<ul>
<li>Contains one or more procedural definitions and their associated nodegraph implementation.</li>
<li>These elements <strong>cannot be connected to nor modified</strong>.</li>
</ul>
</li>
</ul>
<h2 id="correspondence-with-materialx--openusd">Correspondence with MaterialX / OpenUSD</h2>
<h3 id="procedurals">Procedurals</h3>
<p>Each node instance or &quot;compound&quot; node graph instance:</p>
<ul>
<li>Should have a string identifier (<code>name</code>). This <code>name</code> can be a graph path. it must be unique within the array to allow for reconstruction of a corresponding MaterialX / OpenUSD graph.</li>
<li>Must have a node type. (e.g. an <code>add</code> node, an <code>image</code> node, a <code>noise</code> node, etc. or custom type).</li>
<li>Must have an output <code>type</code>.</li>
<li>Must carry though any <code>version</code> identifiers.</li>
<li>May have additional meta-data for user information such as UI hints,</li>
</ul>
<p>Each procedural definition:</p>
<ul>
<li>Must have a <code>name</code> identifier</li>
<li>Must specify the node type as <code>nodedef</code>.</li>
<li>Must have a 1 or more <code>outputs</code></li>
<li>Can have 1 or more <code>inputs</code></li>
<li>Can have a <code>version</code> identifier and an indication if it is default version</li>
<li>May have additional meta-data for user information such as UI hints,</li>
</ul>
<p>Each procedural &quot;functional&quot; node graph implementation:</p>
<ul>
<li>Has a 1:1 association with a procedural definition.
<ul>
<li>This is denoted by specifying a procedural definition identifier (index into the procedurals_definitions array)</li>
</ul>
</li>
<li>Has **no inputs **as these are defined by the procedural definition</li>
<li>Has 1 or more outputs corresponding to the procedural definition.</li>
</ul>
<p>The node type and output type:</p>
<ul>
<li>Determines the appropriate node graph or code implementation to use. Output type is required as definitions can be polymorphic.</li>
<li>Determines the appropriate MaterialX or OpenUSD elements to be re-instantiated as necessary for interop.</li>
</ul>
<p>It is recommended that real-world units (<code>unit</code>) and color space (<code>colorspace</code>) information be maintained for interop with MaterialX / OpenUSD. If not, then the appropriate conversion will need to be baked in the input values or textures.</p>
<p>Any additional meta-data may be carried through to the procedural declaration as designed. This includes data such as UI hints, node placement, documentation, etc. This should be provided as a tooling option.</p>
<p>It is possible to include precision information as is used by OpenUSD in this manner.</p>
<h2 id="json-schema">JSON Schema</h2>
<p><a href="schema/material.KHR_texture_procedurals_schema.json">material.KHR_texture_procedurals.schema.json</a></p>
<h3 id="example-json">Example JSON</h3>
<p>This example shows a &quot;checkerboard&quot; pattern which is defined as a procedural graph. This graph is mapped to the &quot;base color&quot; on a material.</p>
<img src="./figures/checker_graph.svg" width=100%>
<details>
<summary>glTF Graph</summary>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"materials"</span>: [
    {
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"gltf_pbr_surfaceshader"</span>,
      <span class="hljs-attr">"pbrMetallicRoughness"</span>: {
        <span class="hljs-attr">"baseColorTexture"</span>: {
          <span class="hljs-attr">"index"</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">"extensions"</span>: {
            <span class="hljs-attr">"KHR_texture_procedurals"</span>: {
              <span class="hljs-attr">"index"</span>: <span class="hljs-number">0</span>
            }
          }
        }
      }
    }
  ],
  <span class="hljs-attr">"textures"</span>: [
    {
      <span class="hljs-attr">"source"</span>: <span class="hljs-number">0</span>
    }
  ],
  <span class="hljs-attr">"images"</span>: [
    {
      <span class="hljs-attr">"uri"</span>: <span class="hljs-string">"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAADElEQVQI12P4z/AfAAQAAf/zKSWvAAAAAElFTkSuQmCC"</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"KHR_texture_procedural_fallback"</span>
    }
  ],
  <span class="hljs-attr">"extensionsUsed"</span>: [
    <span class="hljs-string">"KHR_texture_procedurals"</span>
  ],
  <span class="hljs-attr">"extensions"</span>: {
    <span class="hljs-attr">"KHR_texture_procedurals"</span>: {
      <span class="hljs-attr">"mimetype"</span>: <span class="hljs-string">"application/mtlx+json;version=1.38"</span>,
      <span class="hljs-attr">"procedurals"</span>: [
        {
          <span class="hljs-attr">"name"</span>: <span class="hljs-string">"My_Checker"</span>,
          <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"nodegraph"</span>,
          <span class="hljs-attr">"type"</span>: <span class="hljs-string">"color3"</span>,
          <span class="hljs-attr">"inputs"</span>: [
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"color1"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"color3"</span>,
              <span class="hljs-attr">"value"</span>: [
                <span class="hljs-number">1.0</span>,
                <span class="hljs-number">0.0</span>,
                <span class="hljs-number">0.0</span>
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"color2"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"color3"</span>,
              <span class="hljs-attr">"value"</span>: [
                <span class="hljs-number">0.0</span>,
                <span class="hljs-number">1.0</span>,
                <span class="hljs-number">0.0</span>
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"uvtiling"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
              <span class="hljs-attr">"value"</span>: [
                <span class="hljs-number">8.0</span>,
                <span class="hljs-number">8.0</span>
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"uvoffset"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
              <span class="hljs-attr">"value"</span>: [
                <span class="hljs-number">0.0</span>,
                <span class="hljs-number">0.0</span>
              ]
            }
          ],
          <span class="hljs-attr">"outputs"</span>: [
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"out"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"color3"</span>,
              <span class="hljs-attr">"node"</span>: <span class="hljs-number">5</span>
            }
          ],
          <span class="hljs-attr">"nodes"</span>: [
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"N_mtlxmult"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"multiply"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
              <span class="hljs-attr">"inputs"</span>: [
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in1"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
                  <span class="hljs-attr">"node"</span>: <span class="hljs-number">6</span>
                },
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in2"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
                  <span class="hljs-attr">"input"</span>: <span class="hljs-number">2</span>
                }
              ],
              <span class="hljs-attr">"outputs"</span>: [
                {
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"out"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>
                }
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"N_mtlxsubtract"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"subtract"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
              <span class="hljs-attr">"inputs"</span>: [
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in1"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
                  <span class="hljs-attr">"node"</span>: <span class="hljs-number">0</span>
                },
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in2"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
                  <span class="hljs-attr">"input"</span>: <span class="hljs-number">3</span>
                }
              ],
              <span class="hljs-attr">"outputs"</span>: [
                {
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"out"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>
                }
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"N_mtlxfloor"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"floor"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
              <span class="hljs-attr">"inputs"</span>: [
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
                  <span class="hljs-attr">"node"</span>: <span class="hljs-number">1</span>
                }
              ],
              <span class="hljs-attr">"outputs"</span>: [
                {
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"out"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>
                }
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"N_mtlxdotproduct"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"dotproduct"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>,
              <span class="hljs-attr">"inputs"</span>: [
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in1"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
                  <span class="hljs-attr">"node"</span>: <span class="hljs-number">2</span>
                },
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in2"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
                  <span class="hljs-attr">"value"</span>: [
                    <span class="hljs-number">1.0</span>,
                    <span class="hljs-number">1.0</span>
                  ]
                }
              ],
              <span class="hljs-attr">"outputs"</span>: [
                {
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"out"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>
                }
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"N_modulo"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"modulo"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>,
              <span class="hljs-attr">"inputs"</span>: [
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in1"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>,
                  <span class="hljs-attr">"node"</span>: <span class="hljs-number">3</span>
                },
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"in2"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>,
                  <span class="hljs-attr">"value"</span>: <span class="hljs-number">2.0</span>
                }
              ],
              <span class="hljs-attr">"outputs"</span>: [
                {
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"out"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>
                }
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"N_mtlxmix"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"mix"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"color3"</span>,
              <span class="hljs-attr">"inputs"</span>: [
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"bg"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"color3"</span>,
                  <span class="hljs-attr">"input"</span>: <span class="hljs-number">1</span>
                },
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"fg"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"color3"</span>,
                  <span class="hljs-attr">"input"</span>: <span class="hljs-number">0</span>
                },
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"mix"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"float"</span>,
                  <span class="hljs-attr">"node"</span>: <span class="hljs-number">4</span>
                }
              ],
              <span class="hljs-attr">"outputs"</span>: [
                {
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"out"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"color3"</span>
                }
              ]
            },
            {
              <span class="hljs-attr">"name"</span>: <span class="hljs-string">"texcoord"</span>,
              <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"texcoord"</span>,
              <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>,
              <span class="hljs-attr">"inputs"</span>: [
                {
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"index"</span>,
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"input"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"integer"</span>,
                  <span class="hljs-attr">"value"</span>: <span class="hljs-number">1</span>
                }
              ],
              <span class="hljs-attr">"outputs"</span>: [
                {
                  <span class="hljs-attr">"nodetype"</span>: <span class="hljs-string">"output"</span>,
                  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"out"</span>,
                  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"vector2"</span>
                }
              ]
            }
          ]
        }
      ]
    }
  }
}
</div></code></pre>
</details>
<p>
<p>The equivalent MaterialX representation is:</p>
<details>
<summary>MaterialX Graph</summary>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?xml version="1.0"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">materialx</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1.38"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">nodegraph</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"My_Checker"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color1"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color3"</span> <span class="hljs-attr">uiname</span>=<span class="hljs-string">"Color 1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1, 0, 0"</span> <span class="hljs-attr">doc</span>=<span class="hljs-string">"The first color used in the checkerboard pattern."</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"10.144928"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-1.482759"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"color2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color3"</span> <span class="hljs-attr">uiname</span>=<span class="hljs-string">"Color 2"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0, 1, 0"</span> <span class="hljs-attr">doc</span>=<span class="hljs-string">"The second color used in the checkerboard pattern."</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"10.144928"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-0.146552"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"uvtiling"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">uiname</span>=<span class="hljs-string">"UV Tiling"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"8, 8"</span> <span class="hljs-attr">doc</span>=<span class="hljs-string">"The tiling of the checkerboard pattern along each axis, with higher values producing smaller squares. Default is (8, 8)."</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"-7.971014"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"0.370690"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"uvoffset"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">uiname</span>=<span class="hljs-string">"UV Offset"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"0, 0"</span> <span class="hljs-attr">doc</span>=<span class="hljs-string">"The offset of the checkerboard pattern along each axis. Default is (0, 0)."</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"-4.347826"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"0.448276"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">multiply</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"N_mtlxmult"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"-4.347826"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-1.172414"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in1"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">nodename</span>=<span class="hljs-string">"texcoord"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">interfacename</span>=<span class="hljs-string">"uvtiling"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">multiply</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">subtract</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"N_mtlxsubtract"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"-0.724638"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-0.508621"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in1"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">nodename</span>=<span class="hljs-string">"N_mtlxmult"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">interfacename</span>=<span class="hljs-string">"uvoffset"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">subtract</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">floor</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"N_mtlxfloor"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"2.898551"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-0.267241"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">nodename</span>=<span class="hljs-string">"N_mtlxsubtract"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">floor</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dotproduct</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"N_mtlxdotproduct"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"float"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"6.521739"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-0.327586"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in1"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">nodename</span>=<span class="hljs-string">"N_mtlxfloor"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1, 1"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dotproduct</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modulo</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"N_modulo"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"float"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"10.144928"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"1.189655"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in1"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"float"</span> <span class="hljs-attr">nodename</span>=<span class="hljs-string">"N_mtlxdotproduct"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"in2"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"float"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"2"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">modulo</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mix</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"N_mtlxmix"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color3"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"13.768116"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-0.379310"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"bg"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color3"</span> <span class="hljs-attr">interfacename</span>=<span class="hljs-string">"color2"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fg"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color3"</span> <span class="hljs-attr">interfacename</span>=<span class="hljs-string">"color1"</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mix"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"float"</span> <span class="hljs-attr">nodename</span>=<span class="hljs-string">"N_modulo"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mix</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">output</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"out"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color3"</span> <span class="hljs-attr">nodename</span>=<span class="hljs-string">"N_mtlxmix"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"17.391304"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"0.000000"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">texcoord</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"texcoord"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"vector2"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"-7.913043"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-1.362069"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"index"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"integer"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"1"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">texcoord</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">nodegraph</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">gltf_pbr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"gltf_pbr_surfaceshader"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"surfaceshader"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"13.768116"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"-0.086207"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"base_color"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"color3"</span> <span class="hljs-attr">nodegraph</span>=<span class="hljs-string">"My_Checker"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">gltf_pbr</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">surfacematerial</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"surfacematerial"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"material"</span> <span class="hljs-attr">xpos</span>=<span class="hljs-string">"17.391304"</span> <span class="hljs-attr">ypos</span>=<span class="hljs-string">"0.000000"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"surfaceshader"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"surfaceshader"</span> <span class="hljs-attr">nodename</span>=<span class="hljs-string">"gltf_pbr_surfaceshader"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">surfacematerial</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">materialx</span>&gt;</span>
</div></code></pre>
</details>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://github.com/AcademySoftwareFoundation/MaterialX/tree/main/documents/Specification">MaterialX Specification Documents</a></li>
<li><a href="https://openusd.org/dev/api/usd_shade_page_front.html">USDShade Schema</a></li>
<li><a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html">glTF stream names</a>. Note that currently there are no stream names for multiple sets of <em>tangents</em>,_ bitangents_, _normals _ or <em>positions</em>.</li>
</ul>
<h2 id="appendix-full-khronos-copyright-statement">Appendix: Full Khronos Copyright Statement</h2>
<p>Copyright 2024 The Khronos Group Inc.</p>
<p>This Specification is protected by copyright laws and contains material proprietary<br>
to Khronos. Except as described by these terms, it or any components<br>
may not be reproduced, republished, distributed, transmitted, displayed, broadcast<br>
or otherwise exploited in any manner without the express prior written permission<br>
of Khronos.</p>
<p>Khronos grants a conditional copyright license to use and reproduce the unmodified<br>
Specification for any purpose, without fee or royalty, EXCEPT no licenses to any patent,<br>
trademark or other intellectual property rights are granted under these terms.</p>
<p>Khronos makes no, and expressly disclaims any, representations or warranties,<br>
express or implied, regarding this Specification, including, without limitation:<br>
merchantability, fitness for a particular purpose, non-infringement of any<br>
intellectual property, correctness, accuracy, completeness, timeliness, and<br>
reliability. Under no circumstances will Khronos, or any of its Promoters,<br>
Contributors or Members, or their respective partners, officers, directors,<br>
employees, agents or representatives be liable for any damages, whether direct,<br>
indirect, special or consequential damages for lost revenues, lost profits, or<br>
otherwise, arising from or in connection with these materials.</p>
<p>This specification has been created under the Khronos Intellectual Property Rights<br>
Policy, which is Attachment A of the Khronos Group Membership Agreement available at<br>
https://www.khronos.org/files/member_agreement.pdf. Khronos grants a conditional<br>
copyright license to use and reproduce the unmodified specification for any purpose,<br>
without fee or royalty, EXCEPT no licenses to any patent, trademark or other<br>
intellectual property rights are granted under these terms. Parties desiring to<br>
implement the specification and make use of Khronos trademarks in relation to that<br>
implementation, and receive reciprocal patent license protection under the Khronos<br>
IP Policy must become Adopters and confirm the implementation as conformant under<br>
the process defined by Khronos for this specification;<br>
see https://www.khronos.org/conformance/adopters/file-format-adopter-program.</p>
<p>Where this Specification identifies specific sections of external references, only those<br>
specifically identified sections define normative functionality. The Khronos Intellectual<br>
Property Rights Policy excludes external references to materials and associated enabling<br>
technology not created by Khronos from the Scope of this Specification, and any licenses<br>
that may be required to implement such referenced materials and associated technologies<br>
must be obtained separately and may involve royalty payments.</p>
<p>Khronos® is a registered trademark, and glTF™ is a trademark of The Khronos Group Inc. All<br>
other product names, trademarks, and/or company names are used solely for identification<br>
and belong to their respective owners.</p>

</body>
</html>
