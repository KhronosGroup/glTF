// Copyright 2013-2023 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

// :regtitle: is explained in
// https://discuss.asciidoctor.org/How-to-add-markup-to-author-information-in-document-title-td6488.html
= glTF{tmtitle} 2.0 Interactivity Extension Specification
:tmtitle: pass:q,r[^™^]
:regtitle: pass:q,r[^®^]
The Khronos{regtitle} 3D Formats Working Group
:data-uri:
:icons: font
:toc2:
:toclevels: 10
:sectnumlevels: 10
:max-width: 100%
:numbered:
:source-highlighter: coderay
:title-logo-image: image:../figures/glTF_RGB_June16.svg[Logo,pdfwidth=4in,align=right]
:docinfo: shared-head
:docinfodir: ../../../../specification/2.0
:stem:

// This causes cross references to chapters, sections, and tables to be
// rendered as "Section A.B" (for example) rather than rendering the reference
// as the text of the section title.  It also enables cross references to
// [source] blocks as "Listing N", but only if the [source] block has a title.
:xrefstyle: short
:listing-caption: Listing

ifndef::revdate[]
:toc-placement!:

[NOTE]
.Note
====
Khronos posts the AsciiDoc source of the glTF specification to enable community
feedback and remixing under CC-BY 4.0. Published versions of the Specification
are located in the https://www.khronos.org/registry/glTF[glTF Registry].
====
endif::[]

// Table of contents is inserted here
toc::[]

:leveloffset: 1

[[foreword]]
= Foreword

Copyright 2013-2023 The Khronos Group Inc.

This specification is protected by copyright laws and contains material proprietary
to Khronos. Except as described by these terms, it or any components
may not be reproduced, republished, distributed, transmitted, displayed, broadcast,
or otherwise exploited in any manner without the express prior written permission
of Khronos.

This specification has been created under the Khronos Intellectual Property Rights
Policy, which is Attachment A of the Khronos Group Membership Agreement available at
https://www.khronos.org/files/member_agreement.pdf. Khronos grants a conditional
copyright license to use and reproduce the unmodified specification for any purpose,
without fee or royalty, EXCEPT no licenses to any patent, trademark or other
intellectual property rights are granted under these terms. Parties desiring to
implement the specification and make use of Khronos trademarks in relation to that
implementation, and receive reciprocal patent license protection under the Khronos
IP Policy must become Adopters under the process defined by Khronos for this specification;
see https://www.khronos.org/conformance/adopters/file-format-adopter-program.

Some parts of this Specification are non-normative through being explicitly identified as
purely informative, and do not define requirements necessary for compliance and so are
outside the Scope of this Specification.

Where this Specification includes normative references to external documents, only the
specifically identified sections and functionality of those external documents are in
Scope. Requirements defined by external documents not created by Khronos may contain
contributions from non-members of Khronos not covered by the Khronos Intellectual
Property Rights Policy.

Khronos makes no, and expressly disclaims any, representations or warranties,
express or implied, regarding this specification, including, without limitation:
merchantability, fitness for a particular purpose, non-infringement of any
intellectual property, correctness, accuracy, completeness, timeliness, and
reliability. Under no circumstances will Khronos, or any of its Promoters,
Contributors or Members, or their respective partners, officers, directors,
employees, agents or representatives be liable for any damages, whether direct,
indirect, special or consequential damages for lost revenues, lost profits, or
otherwise, arising from or in connection with these materials.

Khronos® and Vulkan® are registered trademarks, and ANARI™, WebGL™, glTF™, NNEF™, OpenVX™,
SPIR™, SPIR&#8209;V™, SYCL™, OpenVG™ and 3D Commerce™ are trademarks of The Khronos Group Inc.
OpenXR™ is a trademark owned by The Khronos Group Inc. and is registered as a trademark in
China, the European Union, Japan and the United Kingdom. OpenCL™ is a trademark of Apple Inc.
and OpenGL® is a registered trademark and the OpenGL ES™ and OpenGL SC™ logos are trademarks
of Hewlett Packard Enterprise used under license by Khronos. ASTC is a trademark of
ARM Holdings PLC. All other product names, trademarks, and/or company names are used solely
for identification and belong to their respective owners.


[[introduction]]
= Introduction

[[introduction-general]]
== General

This document, referred to as the "`glTF Interactivity Extension Specification`" or just the "`Specification`" hereafter, describes the `KHR_interactivity` glTF extension.

This extension aims to enhance glTF 2.0 by adding the ability to encode behavior and interactivity in 3D assets.

[NOTE]
.Note
====
This specification is for single user experiences only and does not deal with any of the complexity involved in multi-user networked experiences.
====

[[introduction-conventions]]
== Document Conventions

The glTF Interactivity Extension Specification is intended for use by both implementers of the asset exporters or converters (e.g., digital content creation tools) and application developers seeking to import or load interactive glTF assets, forming a basis for interoperability between these parties.

Specification text can address either party; typically, the intended audience can be inferred from context, though some sections are defined to address only one of these parties.

Any requirements, prohibitions, recommendations, or options defined by <<introduction-normative-terminology, normative terminology>> are imposed only on the audience of that text.

[[introduction-normative-terminology]]
=== Normative Terminology and References

The key words **MUST**, **MUST NOT**, **REQUIRED**, **SHALL**, **SHALL NOT**, **SHOULD**, **SHOULD NOT**, **RECOMMENDED**,  **MAY**, and **OPTIONAL** in this document are to be interpreted as described in <<bcp14,BCP 14>>.

These key words are highlighted in the specification for clarity.

References to external documents are considered normative if the Specification uses any of the normative terms defined in this section to refer to them or their requirements, either as a whole or in part.

[[introduction-informative-language]]
=== Informative Language

Some language in the specification is purely informative, intended to give background or suggestions to implementers or developers.

If an entire chapter or section contains only informative language, its title is suffixed with "`(Informative)`". If not designated as informative, all chapters, sections, and appendices in this document are normative.

All Notes, Implementation notes, and Examples are purely informative.

[[introduction-technical-terminology]]
=== Technical Terminology

TBD

[[introduction-normative-references]]
=== Normative References

The following documents are referenced by normative sections of the specification:

==== External Specifications

[none]
* [[bcp14]]
Bradner, S., _Key words for use in RFCs to Indicate Requirement Levels_, BCP 14, RFC 2119, March 1997. Leiba, B., _Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words_, BCP 14, RFC 8174, May 2017.
<https://www.rfc-editor.org/info/bcp14>

* [[ieee-754]]
ISO/IEC 60559
_Floating-point arithmetic_
<https://www.iso.org/standard/80985.html>

* [[ecma-262]]
ECMA-262
_ECMAScript® Language Specification_
<https://www.ecma-international.org/publications-and-standards/standards/ecma-262/>

[[motivation]]
== Motivation and Design Goals (Informative)

glTF 2.0 assets are widely used in various industries, including automotive, e-commerce, and gaming. There is a growing demand for adding logic and behavior to glTF assets, particularly in the metaverse. This extension aims to fulfill this demand by providing a portable, easily implementable, safe, and visually accessible solution for adding behavior to glTF assets. The extension is inspired by visual scripting features of leading game engines and aims to deliver a minimum meaningful and extensible feature set.

=== What Is a Behavior Graph?
A behavior graph is a series of interconnected nodes that represent behaviors and interactions in a 3D asset. It can respond to events and cause changes in the asset's appearance and behavior.

=== What Problems Can They Solve?
Behavior graphs offer a flexible and multi-functional approach to encoding behavior, making them useful for various applications. For instance, they can be used to create smart assets with behavior and interactions, AR experiences with user interactions, and immersive game levels with dynamic assets and objectives.

=== What Do They Not Solve?
Behavior graphs are not designed to handle UI presentation or arbitrary scripting. Creating a 3D UI using behavior graphs would be complex, not portable, and not accessible. Similarly, arbitrary scripting is challenging to make safe, portable across platforms, and has a vast surface area.

=== Comparison with Trigger-Action Lists
Behavior graphs and trigger-action lists are the two common models for representing and executing behaviors in the digital world. Common 3D experience commerce tools use trigger-action lists, while behavior graphs are typically used by high-end game engines. In this section, we will explore the differences and similarities between these two models, and explain why glTF chose to adopt behavior graphs.

Behavior graphs and trigger-action lists share common features, such as being safe and sandboxed, offering limited execution models controlled by the viewer, and both supporting the “trigger” and “action” node categories. However, there are also significant differences between the two models. Trigger-action lists lack “Queries”, “Logic”, and “Control Flow” nodes, meaning that sophisticated behavior based on queries, logic, or control flow branches is not possible. This lack of functionality greatly affects the ability to create complex behavior and control structures and rules out the implementation of advanced control flow structures in the future.

On the other hand, behavior graphs are a superset of trigger-action lists, meaning that the former can support everything that trigger-action lists can, and more. Behavior graphs support “Queries”, “Logic” and “Control Flow” nodes, making them more expressive and capable of creating more sophisticated behaviors. This makes behavior graphs the preferred method of choice for high-end game engines, as it offers an identical safety model as trigger-action lists while being more expressive.

=== Turing Completeness
The execution model and node choices for this extension mean that it is Turing-complete. This means that an implementation of this can execute any computation and it is also hard to predict if it will run forever (e.g. halt or not.)

While this may present security implications, it is not a major hindrance and can be safely mitigated so that any implementation does not become susceptible to denial of services by badly behaving behavior graphs, whether intention or not.

The main way to mitigate the risk of non-halting behavior graphs is to limit the amount of time given to them for execution, both in terms of individual time slice as well as overall execution time.

=== Implementation Limitations
There will be limitations in engines and devices to such as:

* Number of nodes in the graph
* Number of variables
* Number of custom events
* Number of concurrent pending events/async nodes
* Number of nodes executed per time slice
* Speed of graph execution

These limitations are not defined in this specification.


[[concepts]]
= Concepts

[[concepts-general]]
== Graphs

A behavior graph is a JSON object containing _nodes_. It **MAY** also contain custom variables and custom events.

Behavior graphs are directed graphs with no directed cycles.

[[nodes]]
== Nodes and Sockets

A _node_ is a JSON object, which represents an executable item. Each node is defined by its _type_ and a set of _sockets_. There are four kinds of sockets.

_Output value sockets_ represent data initialized by the node or produced during its execution. For example, it could be results of math operations or parts of the node's internal state. Accessing these sockets either triggers computing the return value on the fly by executing the node or returns a value based on the node's internal state. Exact behavior depends on the node's type.

_Input value sockets_ represent data accessed during the node's execution. For example, it could be arguments of math operations or execution parameters such as iteration count for loop nodes or duration for time-related nodes. These sockets **MUST** either be given a static value in the node object or connected to an output value socket of a different node. The node **MAY** access its input value sockets multiple times during the execution. The runtime **MUST** guarantee that all input value sockets have defined values when the node execution starts.

_Output flow sockets_ represent "`function pointers`" that the node will call to advance the graph execution. For example, bodies and branches of flow control nodes are output flow sockets that drive further execution when certain condition are fulfilled. Output flow sockets **MAY** be unconnected; in such a case graph execution proceeds as if such sockets are no-ops.

_Input flow sockets_ represent "`methods`" that could be called on the node. For example, flow control nodes (such as loops and conditions) usually have an `in` input flow socket that starts node's execution. Additional operations **MAY** also be defined such as `reset` for nodes having an internal state.

Nodes **MAY** be configurable through static properties collectively called "`node's configuration`" that **MAY** affect the node's behavior and the number of its sockets, such as the number of cases for a switch-case control flow node.

Input and output value sockets have associated data types, e.g., floats, integers, booleans, etc.

Node's sockets and configurations are defined by its _type_. Node types follow `domain/operation` naming pattern.

A node is executed when its input flow socket is reached by or when one of its output value sockets is requested by another node. Usually, the node executes its dependencies (if any), its own logic, and any number (including zero) of outgoing flow sockets.

[[types]]
== Value Types

TBD

[[events]]
== Custom Events

TBD

[[variables]]
== Variables

TBD

== Node Types

=== Math Nodes

In this section, `floatN` is a placeholder for any of `float`, `float2`, `float3`, `float4`, or `float4x4` types. All value sockets of `floatN` types have the same type within a node.

==== Constants

===== E

[cols="1h,1,2"]
|===
| Type | `math/e` | Euler's number
| Output value sockets | `float value` | 2.718281828459045
|===

===== Pi

[cols="1h,1,2"]
|===
| Type | `math/pi` | Ratio of a circle's circumference to its diameter
| Output value sockets | `float value` | 3.141592653589793
|===

==== Arithmetic Nodes

These all operate component-wise. The description is per component.

If any input value is _NaN_, the output value is also _NaN_.

===== Absolute Value

[cols="1h,1,2"]
|===
| Type | `math/abs` | Absolute value operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}a, \text{if } a \ge 0.0 \\ -a, \text{if } a < 0.0 \end{cases}]
|===

===== Sign

[cols="1h,1,2"]
|===
| Type | `math/sign` | Sign operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}-1.0, \text{if } a < 0.0 \\ a, \text{if } a = \pm0.0 \\ 1.0, \text{if } a > 0.0 \end{cases}]
|===

===== Truncate

[cols="1h,1,2"]
|===
| Type | `math/trunc` | Truncate operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | Integer value equal to the nearest integer to stem:[a] whose absolute value is not larger than the absolute value of stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Floor

[cols="1h,1,2"]
|===
| Type | `math/floor` | Floor operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | stem:[floor(a)], value equal to the nearest integer that is less than or equal to stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Ceil

[cols="1h,1,2"]
|===
| Type | `math/ceil` | Ceil operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | stem:[ceil(a)], value equal to the nearest integer that is greater than or equal to stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Fraction

[cols="1h,1,2"]
|===
| Type | `math/fract` | Fractional operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | stem:[a - floor(a)]
|===

===== Negation

[cols="1h,1,2"]
|===
| Type | `math/neg` | Negation operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | stem:[-a]
|===

===== Addition

[cols="1h,1,2"]
|===
| Type | `math/add` | Addition operation
.2+| Input value sockets
| `floatN a` | First addend
| `floatN b` | Second addend
| Output value sockets
| `floatN value` | Sum, stem:[a + b]
|===

===== Subtraction

[cols="1h,1,2"]
|===
| Type | `math/sub` | Subtraction operation
.2+| Input value sockets
| `floatN a` | Minuend
| `floatN b` | Subtrahend
| Output value sockets
| `floatN value` | Difference, stem:[a - b]
|===

===== Multiplication

[cols="1h,1,2"]
|===
| Type | `math/mul` | Multiplication operation
.2+| Input value sockets
| `floatN a` | First factor
| `floatN b` | Second factor
| Output value sockets
| `floatN value` | Product, stem:[a * b]
|===

===== Division

[cols="1h,1,2"]
|===
| Type | `math/div` | Division operation
.2+| Input value sockets
| `floatN a` | Dividend
| `floatN b` | Divisor
| Output value sockets
| `floatN value` | Quotient, stem:[a / b]
|===

===== Remainder

[cols="1h,1,2"]
|===
| Type | `math/rem` | Remainder operation
.2+| Input value sockets
| `floatN a` | Dividend
| `floatN b` | Divisor
| Output value sockets
| `floatN value` | latexmath:[a - (b \cdot trunc(\frac{a}{b}))]
|===

===== Minimum

[cols="1h,1,2"]
|===
| Type | `math/min` | Minimum operation
.2+| Input value sockets
| `floatN a` | First argument
| `floatN b` | Second argument
| Output value sockets
| `floatN value` | Smallest of the arguments
|===

===== Maximum

[cols="1h,1,2"]
|===
| Type | `math/max` | Maximum operation
.2+| Input value sockets
| `floatN a` | First argument
| `floatN b` | Second argument
| Output value sockets
| `floatN value` | Largest of the arguments
|===

===== Clamp

[cols="1h,1,2"]
|===
| Type | `math/clamp` | Clamp operation
.3+| Input value sockets
| `floatN a` | Value to clamp
| `floatN b` | Lower boundary
| `floatN c` | Upper boundary
| Output value sockets
| `floatN value` | latexmath:[min(max(a, b), c)]
|===

===== Saturate

[cols="1h,1,2"]
|===
| Type | `math/saturate` | Saturate operation
| Input value sockets
| `floatN a` | Value to saturate
| Output value sockets
| `floatN value` | latexmath:[clamp(a, 0, 1)]
|===

===== Interpolate

[cols="1h,1,2"]
|===
| Type | `math/mix` | Linear interpolation operation
.3+| Input value sockets
| `floatN a` | Interpolated value at stem:[0.0]
| `floatN b` | Interpolated value at stem:[1.0]
| `floatN c` | Unclamped interpolation coefficient
| Output value sockets
| `floatN value` | stem:[(1.0 - c) * a + c * b]
|===

==== Angle and Trigonometry Nodes

Node parameters specified as angle are assumed to be in units of radians.

These all operate component-wise. The description is per component.

If any input value is _NaN_, the output value is also _NaN_.

===== Degrees-To-Radians

[cols="1h,1,2"]
|===
| Type | `math/rad` | Converts degrees to radians
| Input value sockets
| `floatN a` | Value in degrees
| Output value sockets
| `floatN value` | stem:[a * pi / 180.0]
|===

===== Radians-To-Degrees

[cols="1h,1,2"]
|===
| Type | `math/deg` | Converts radians to degrees
| Input value sockets
| `floatN a` | Value in radians
| Output value sockets
| `floatN value` | stem:[a * 180.0 / pi]
|===

===== Sine

[cols="1h,1,2"]
|===
| Type | `math/sin` | Sine function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}sin(a), \text{if } a \ne \pm\infty \\ \mathit{NaN}, \text{if } a = \pm\infty\end{cases}]
|===

===== Cosine

[cols="1h,1,2"]
|===
| Type | `math/cos` | Cosine function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}cos(a), \text{if } a \ne \pm\infty \\ \mathit{NaN}, \text{if } a = \pm\infty\end{cases}]
|===

===== Tangent

[cols="1h,1,2"]
|===
| Type | `math/tan` | Tangent function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}tan(a), \text{if } a \ne \pm\infty \\ \mathit{NaN}, \text{if } a = \pm\infty\end{cases}]
|===

===== Arcsine

[cols="1h,1,2"]
|===
| Type | `math/asin` | Arcsine function
| Input value sockets
| `floatN a` | Sine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}arcsin(a) \in [-\frac{\pi}{2}; \frac{\pi}{2}\], \text{if } \|a\| \le 1 \\ \mathit{NaN}, \text{if } \|a\| > 1\end{cases}]
|===

===== Arccosine

[cols="1h,1,2"]
|===
| Type | `math/acos` | Arccosine function
| Input value sockets
| `floatN a` | Cosine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}arccos(a) \in [0; \pi\], \text{if } \|a\| \le 1 \\ \mathit{NaN}, \text{if } \|a\| > 1\end{cases}]
|===

===== Arctangent

[cols="1h,1,2"]
|===
| Type | `math/atan` | Arctangent function
| Input value sockets
| `floatN a` | Tangent value
| Output value sockets
| `floatN value` | latexmath:[arctan(a) \in [-\frac{\pi}{2}; \frac{\pi}{2}\]]
|===

===== Arctangent 2

[cols="1h,1,2"]
|===
| Type | `math/atan2` | Arctangent 2 function
.2+| Input value sockets
| `floatN a` | Y coordinate
| `floatN b` | X coordinate
| Output value sockets
| `floatN value` | Angle between the positive X-axis and the vector from the stem:[(0, 0)] origin to the stem:[(X, Y)] point on a 2D plane
|===

Zero and infinity argument values are handled according to <<ecma-262,ECMA-262>> or <<ieee-754,IEEE 754>> standards.

==== Hyperbolic Nodes

These all operate component-wise. The description is per component.

If any input value is _NaN_, the output value is also _NaN_.

===== Hyperbolic Sine

[cols="1h,1,2"]
|===
| Type |`math/sinh`| Hyperbolic sine function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\dfrac{e^a-e^{-a}}{2}]
|===

===== Hyperbolic Cosine

[cols="1h,1,2"]
|===
| Type |`math/cosh`| Hyperbolic cosine function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\dfrac{e^a+e^{-a}}{2}]
|===

===== Hyperbolic Tangent

[cols="1h,1,2"]
|===
| Type |`math/tanh`| Hyperbolic tangent function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\dfrac{e^a-e^{-a}}{e^a+e^{-a}}]
|===

===== Inverse Hyperbolic Sine

[cols="1h,1,2"]
|===
| Type |`math/asinh`| Inverse hyperbolic sine function
| Input value sockets
| `floatN a` | Hyperbolic sine value
| Output value sockets
| `floatN value` | latexmath:[ln(a+\sqrt{a^2+1})]
|===

===== Inverse Hyperbolic Cosine

[cols="1h,1,2"]
|===
| Type |`math/acosh`| Inverse hyperbolic cosine function
| Input value sockets
| `floatN a` | Hyperbolic cosine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}ln(a+\sqrt{a^2-1}), \text{if } a \ge 1 \\ \mathit{NaN}, \text{if } a < 1\end{cases}]
|===

===== Inverse Hyperbolic Tangent

[cols="1h,1,2"]
|===
| Type |`math/atanh`| Inverse hyperbolic tangent function
| Input value sockets
| `floatN a` | Hyperbolic tangent value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}\dfrac{1}{2}ln\dfrac{1+a}{1-a}, \text{if } \|a\| \le 1 \\ \mathit{NaN}, \text{if } \|a\| > 1\end{cases}]
|===

==== Exponential Nodes

These all operate component-wise. The description is per component.

If any input value is _NaN_, the output value is also _NaN_.

===== Exponent

[cols="1h,1,2"]
|===
| Type | `math/exp` | Exponent function
| Input value sockets
| `floatN a` | Power value
| Output value sockets
| `floatN value` | stem:[e^a]
|===

===== Natural Logarithm

[cols="1h,1,2"]
|===
| Type | `math/log` | Natural logarithm function
| Input value sockets
| `floatN a` | Argument value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}ln(a), \text{if } a \ge 0 \\ \mathit{NaN}, \text{if } a < 0\end{cases}]
|===

===== Base-2 Logarithm

[cols="1h,1,2"]
|===
| Type | `math/log2` | Base-2 logarithm function
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}log_2(a), \text{if } a \ge 0 \\ \mathit{NaN}, \text{if } a < 0\end{cases}]
|===

===== Base-10 Logarithm

[cols="1h,1,2"]
|===
| Type | `math/log10` | Base-10 logarithm function
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}log_{10}(a), \text{if } a \ge 0 \\ \mathit{NaN}, \text{if } a < 0\end{cases}]
|===

===== Square Root

[cols="1h,1,2"]
|===
| Type | `math/sqrt` | Square root function
| Input value sockets
| `floatN a` | Radicand
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}\sqrt{a}, \text{if } a \ge 0 \\ \mathit{NaN}, \text{if } a < 0\end{cases}]
|===

===== Cube Root

[cols="1h,1,2"]
|===
| Type | `math/cbrt` | Cube root function
| Input value sockets
| `floatN a` | Radicand
| Output value sockets
| `floatN value` | latexmath:[\sqrt[3\]{a}]
|===

===== Power

[cols="1h,1,2"]
|===
| Type | `math/pow` | Power function
.2+| Input value sockets
| `floatN a` | Base
| `floatN b` | Exponent
| Output value sockets
| `floatN value` | stem:[a^b]
|===

Zero and infinity argument values are handled according to the <<ecma-262,ECMA-262>> standard.

==== Vector Nodes

If any input value is _NaN_, the output value is also _NaN_.

===== Length

[cols="1h,1,2"]
|===
| Type | `math/length` | Vector length
| Input value sockets
| `float{2\|3\|4} a` | Vector
| Output value sockets
| `float value` | Length of stem:[a], e.g., stem:[sqrt(a_x^2 + a_y^2)] for `float2`
|===

===== Normalize

[cols="1h,1,2"]
|===
| Type | `math/normalize` | Vector normalization
| Input value sockets
| `float{2\|3\|4} a` | Vector
| Output value sockets
| `floatN value` | Vector in the same direction as stem:[a] but with a unit length, e.g., stem:[a/sqrt(a_x^2 + a_y^2)] for `float2`
|===

===== Dot Product

[cols="1h,1,2"]
|===
| Type | `math/dot` | Dot product
.2+| Input value sockets
| `float{2\|3\|4} a` | First vector
| `float{2\|3\|4} b` | Second vector of the same type as stem:[a]
| Output value sockets
| `float value` | Sum of per-component products of stem:[a] and stem:[b], e.g., stem:[a_x * b_x + a_y * b_y] for `float2`
|===

===== Cross Product

[cols="1h,1,2"]
|===
| Type | `math/cross` | Cross product
.2+| Input value sockets
| `float3 a` | Vector
| `float3 b` | Vector
| Output value sockets
| `float3 value` | Cross product of stem:[a] and stem:[b], i.e., stem:[(a_y * b_z - a_z * b_y, a_z * b_x - a_x * b_z, a_x * b_y - a_y * b_x)]
|===

===== Rotate 2D

[cols="1h,1,2"]
|===
| Type | `math/rotate` | 2D rotation
.2+| Input value sockets
| `float2 a` | Vector to rotate
| `float b`  | Angle in radians
| Output value sockets
| `float2 value` | Vector stem:[a] rotated counter-clockwise by stem:[b]
|===

===== Rotate 3D

[cols="1h,1,2"]
|===
| Type | `math/rotate` | 3D rotation
.3+| Input value sockets
| `float3 a` | Vector to rotate
| `float3 b` | Vector representing an axis to rotate around
| `float c`  | Angle in radians
| Output value sockets
| `float3 value` | Vector stem:[a] rotated around vector stem:[b] counter-clockwise by stem:[c]
|===

If the vector stem:[b] is not unit, rotation results may be undefined.
