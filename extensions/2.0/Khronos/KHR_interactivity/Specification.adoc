// Copyright 2013-2023 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

// :regtitle: is explained in
// https://discuss.asciidoctor.org/How-to-add-markup-to-author-information-in-document-title-td6488.html
= glTF{tmtitle} 2.0 Interactivity Extension Specification
:tmtitle: pass:q,r[^™^]
:regtitle: pass:q,r[^®^]
The Khronos{regtitle} 3D Formats Working Group
:data-uri:
:icons: font
:toc2:
:toclevels: 10
:sectnumlevels: 10
:max-width: 100%
:numbered:
:source-highlighter: coderay
:title-logo-image: image:../figures/glTF_RGB_June16.svg[Logo,pdfwidth=4in,align=right]
:docinfo: shared-head
:docinfodir: ../../../../specification/2.0
:stem:

// This causes cross references to chapters, sections, and tables to be
// rendered as "Section A.B" (for example) rather than rendering the reference
// as the text of the section title.  It also enables cross references to
// [source] blocks as "Listing N", but only if the [source] block has a title.
:xrefstyle: short
:listing-caption: Listing

ifndef::revdate[]
:toc-placement!:

[NOTE]
.Note
====
Khronos posts the AsciiDoc source of the glTF specification to enable community
feedback and remixing under CC-BY 4.0. Published versions of the Specification
are located in the https://www.khronos.org/registry/glTF[glTF Registry].
====
endif::[]

// Table of contents is inserted here
toc::[]

:leveloffset: 1

[[foreword]]
= Foreword

Copyright 2013-2023 The Khronos Group Inc.

This specification is protected by copyright laws and contains material proprietary
to Khronos. Except as described by these terms, it or any components
may not be reproduced, republished, distributed, transmitted, displayed, broadcast,
or otherwise exploited in any manner without the express prior written permission
of Khronos.

This specification has been created under the Khronos Intellectual Property Rights
Policy, which is Attachment A of the Khronos Group Membership Agreement available at
https://www.khronos.org/files/member_agreement.pdf. Khronos grants a conditional
copyright license to use and reproduce the unmodified specification for any purpose,
without fee or royalty, EXCEPT no licenses to any patent, trademark or other
intellectual property rights are granted under these terms. Parties desiring to
implement the specification and make use of Khronos trademarks in relation to that
implementation, and receive reciprocal patent license protection under the Khronos
IP Policy must become Adopters under the process defined by Khronos for this specification;
see https://www.khronos.org/conformance/adopters/file-format-adopter-program.

Some parts of this Specification are non-normative through being explicitly identified as
purely informative, and do not define requirements necessary for compliance and so are
outside the Scope of this Specification.

Where this Specification includes normative references to external documents, only the
specifically identified sections and functionality of those external documents are in
Scope. Requirements defined by external documents not created by Khronos may contain
contributions from non-members of Khronos not covered by the Khronos Intellectual
Property Rights Policy.

Khronos makes no, and expressly disclaims any, representations or warranties,
express or implied, regarding this specification, including, without limitation:
merchantability, fitness for a particular purpose, non-infringement of any
intellectual property, correctness, accuracy, completeness, timeliness, and
reliability. Under no circumstances will Khronos, or any of its Promoters,
Contributors or Members, or their respective partners, officers, directors,
employees, agents or representatives be liable for any damages, whether direct,
indirect, special or consequential damages for lost revenues, lost profits, or
otherwise, arising from or in connection with these materials.

Khronos® and Vulkan® are registered trademarks, and ANARI™, WebGL™, glTF™, NNEF™, OpenVX™,
SPIR™, SPIR&#8209;V™, SYCL™, OpenVG™ and 3D Commerce™ are trademarks of The Khronos Group Inc.
OpenXR™ is a trademark owned by The Khronos Group Inc. and is registered as a trademark in
China, the European Union, Japan and the United Kingdom. OpenCL™ is a trademark of Apple Inc.
and OpenGL® is a registered trademark and the OpenGL ES™ and OpenGL SC™ logos are trademarks
of Hewlett Packard Enterprise used under license by Khronos. ASTC is a trademark of
ARM Holdings PLC. All other product names, trademarks, and/or company names are used solely
for identification and belong to their respective owners.


[[introduction]]
= Introduction

[[introduction-general]]
== General

This document, referred to as the "`glTF Interactivity Extension Specification`" or just the "`Specification`" hereafter, describes the `KHR_interactivity` glTF extension.

This extension aims to enhance glTF 2.0 by adding the ability to encode behavior and interactivity in 3D assets.

[NOTE]
.Note
====
This specification is for single user experiences only and does not deal with any of the complexity involved in multi-user networked experiences.
====

[[introduction-conventions]]
== Document Conventions

The glTF Interactivity Extension Specification is intended for use by both implementers of the asset exporters or converters (e.g., digital content creation tools) and application developers seeking to import or load interactive glTF assets, forming a basis for interoperability between these parties.

Specification text can address either party; typically, the intended audience can be inferred from context, though some sections are defined to address only one of these parties.

Any requirements, prohibitions, recommendations, or options defined by <<introduction-normative-terminology, normative terminology>> are imposed only on the audience of that text.

[[introduction-normative-terminology]]
=== Normative Terminology and References

The key words **MUST**, **MUST NOT**, **REQUIRED**, **SHALL**, **SHALL NOT**, **SHOULD**, **SHOULD NOT**, **RECOMMENDED**,  **MAY**, and **OPTIONAL** in this document are to be interpreted as described in <<bcp14,BCP 14>>.

These key words are highlighted in the specification for clarity.

References to external documents are considered normative if the Specification uses any of the normative terms defined in this section to refer to them or their requirements, either as a whole or in part.

[[introduction-informative-language]]
=== Informative Language

Some language in the specification is purely informative, intended to give background or suggestions to implementers or developers.

If an entire chapter or section contains only informative language, its title is suffixed with "`(Informative)`". If not designated as informative, all chapters, sections, and appendices in this document are normative.

All Notes, Implementation notes, and Examples are purely informative.

[[introduction-technical-terminology]]
=== Technical Terminology

TBD

[[introduction-normative-references]]
=== Normative References

The following documents are referenced by normative sections of the specification:

==== External Specifications

[none]
* [[bcp14]]
Bradner, S., _Key words for use in RFCs to Indicate Requirement Levels_, BCP 14, RFC 2119, March 1997. Leiba, B., _Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words_, BCP 14, RFC 8174, May 2017.
<https://www.rfc-editor.org/info/bcp14>

* [[ieee-754]]
ISO/IEC 60559
_Floating-point arithmetic_
<https://www.iso.org/standard/80985.html>

* [[ecma-262]]
ECMA-262
_ECMAScript® Language Specification_
<https://www.ecma-international.org/publications-and-standards/standards/ecma-262/>

[[motivation]]
== Motivation and Design Goals (Informative)

glTF 2.0 assets are widely used in various industries, including automotive, e-commerce, and gaming. There is a growing demand for adding logic and behavior to glTF assets, particularly in the metaverse. This extension aims to fulfill this demand by providing a portable, easily implementable, safe, and visually accessible solution for adding behavior to glTF assets. The extension is inspired by visual scripting features of leading game engines and aims to deliver a minimum meaningful and extensible feature set.

=== What Is a Behavior Graph?
A behavior graph is a series of interconnected nodes that represent behaviors and interactions in a 3D asset. It can respond to events and cause changes in the asset's appearance and behavior.

=== What Problems Can They Solve?
Behavior graphs offer a flexible and multi-functional approach to encoding behavior, making them useful for various applications. For instance, they can be used to create smart assets with behavior and interactions, AR experiences with user interactions, and immersive game levels with dynamic assets and objectives.

=== What Do They Not Solve?
Behavior graphs are not designed to handle UI presentation or arbitrary scripting. Creating a 3D UI using behavior graphs would be complex, not portable, and not accessible. Similarly, arbitrary scripting is challenging to make safe, portable across platforms, and has a vast surface area.

=== Comparison with Trigger-Action Lists
Behavior graphs and trigger-action lists are the two common models for representing and executing behaviors in the digital world. Common 3D experience commerce tools use trigger-action lists, while behavior graphs are typically used by high-end game engines. In this section, we will explore the differences and similarities between these two models, and explain why glTF chose to adopt behavior graphs.

Behavior graphs and trigger-action lists share common features, such as being safe and sandboxed, offering limited execution models controlled by the viewer, and both supporting the “trigger” and “action” node categories. However, there are also significant differences between the two models. Trigger-action lists lack “Queries”, “Logic”, and “Control Flow” nodes, meaning that sophisticated behavior based on queries, logic, or control flow branches is not possible. This lack of functionality greatly affects the ability to create complex behavior and control structures and rules out the implementation of advanced control flow structures in the future.

On the other hand, behavior graphs are a superset of trigger-action lists, meaning that the former can support everything that trigger-action lists can, and more. Behavior graphs support “Queries”, “Logic” and “Control Flow” nodes, making them more expressive and capable of creating more sophisticated behaviors. This makes behavior graphs the preferred method of choice for high-end game engines, as it offers an identical safety model as trigger-action lists while being more expressive.

=== Turing Completeness
The execution model and node choices for this extension mean that it is Turing-complete. This means that an implementation of this can execute any computation and it is also hard to predict if it will run forever (e.g. halt or not.)

While this may present security implications, it is not a major hindrance and can be safely mitigated so that any implementation does not become susceptible to denial of services by badly behaving behavior graphs, whether intention or not.

The main way to mitigate the risk of non-halting behavior graphs is to limit the amount of time given to them for execution, both in terms of individual time slice as well as overall execution time.

=== Implementation Limitations
There will be limitations in engines and devices to such as:

* Number of nodes in the graph
* Number of variables
* Number of custom events
* Number of concurrent pending events/async nodes
* Number of nodes executed per time slice
* Speed of graph execution

These limitations are not defined in this specification.


[[concepts]]
= Concepts

[[concepts-general]]
== Graphs

A behavior graph is a JSON object containing _nodes_. It **MAY** also contain custom variables and custom events.

Behavior graphs are directed graphs with no directed cycles.

[[nodes]]
== Nodes and Sockets

A _node_ is a JSON object, which represents an executable item. Each node is defined by its _type_ and a set of _sockets_. There are four kinds of sockets.

_Output value sockets_ represent data initialized by the node or produced during its execution. For example, it could be results of math operations or parts of the node's internal state. Accessing these sockets either triggers computing the return value on the fly by executing the node or returns a value based on the node's internal state. Exact behavior depends on the node's type.

_Input value sockets_ represent data accessed during the node's execution. For example, it could be arguments of math operations or execution parameters such as iteration count for loop nodes or duration for time-related nodes. These sockets **MUST** either be given a static value in the node object or connected to an output value socket of a different node. The node **MAY** access its input value sockets multiple times during the execution. The runtime **MUST** guarantee that all input value sockets have defined values when the node execution starts.

_Output flow sockets_ represent "`function pointers`" that the node will call to advance the graph execution. For example, bodies and branches of flow control nodes are output flow sockets that drive further execution when certain condition are fulfilled. Output flow sockets **MAY** be unconnected; in such a case graph execution proceeds as if such sockets are no-ops.

_Input flow sockets_ represent "`methods`" that could be called on the node. For example, flow control nodes (such as loops and conditions) usually have an `in` input flow socket that starts node's execution. Additional operations **MAY** also be defined such as `reset` for nodes having an internal state.

Nodes **MAY** be configurable through static properties collectively called "`node's configuration`" that **MAY** affect the node's behavior and the number of its sockets, such as the number of cases for a switch-case control flow node.

Input and output value sockets have associated data types, e.g., floats, integers, booleans, etc.

Node's sockets and configurations are defined by its _type_. Node types follow `domain/operation` naming pattern.

A node is executed when its input flow socket is reached by or when one of its output value sockets is requested by another node. Usually, the node executes its dependencies (if any), its own logic, and any number (including zero) of outgoing flow sockets.

[[types]]
== Value Types

TBD

[[events]]
== Custom Events

TBD

[[variables]]
== Variables

TBD

== Node Types

=== Math Nodes

In this section, `floatN` is a placeholder for any of `float`, `float2`, `float3`, `float4`, or `float4x4` types. All value sockets of `floatN` types have the same type within a node.

==== Constants

===== E

[cols="1h,1,2"]
|===
| Type | `math/e` | Euler's number
| Output value sockets | `float value` | 2.718281828459045
|===

===== Pi

[cols="1h,1,2"]
|===
| Type | `math/pi` | Ratio of a circle's circumference to its diameter
| Output value sockets | `float value` | 3.141592653589793
|===

===== Infinity

[cols="1h,1,2"]
|===
| Type | `math/inf` | Positive infinity
| Output value sockets | `float value` | _Infinity_
|===

===== Not a Number

[cols="1h,1,2"]
|===
| Type | `math/nan` | Not a Number
| Output value sockets | `float value` | _NaN_
|===

==== Arithmetic Nodes

These all operate component-wise. The description is per component.

If any input value is _NaN_, the output value is also _NaN_.

===== Absolute Value

[cols="1h,1,2"]
|===
| Type | `math/abs` | Absolute value operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                -a & \text{if } a \lt 0 \\
                                 0 & \text{if } a = 0 \\
                                 a & \text{if } a \gt 0
                              \end{cases}]
|===

===== Sign

[cols="1h,1,2"]
|===
| Type | `math/sign` | Sign operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                -1 & \text{if } a \lt 0 \\
                                 a & \text{if } a = \pm0 \\
                                +1 & \text{if } a \gt 0
                              \end{cases}]
|===

===== Truncate

[cols="1h,1,2"]
|===
| Type | `math/trunc` | Truncate operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | Integer value equal to the nearest integer to stem:[a] whose absolute value is not larger than the absolute value of stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Floor

[cols="1h,1,2"]
|===
| Type | `math/floor` | Floor operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | stem:[floor(a)], value equal to the nearest integer that is less than or equal to stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Ceil

[cols="1h,1,2"]
|===
| Type | `math/ceil` | Ceil operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | stem:[ceil(a)], value equal to the nearest integer that is greater than or equal to stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Fraction

[cols="1h,1,2"]
|===
| Type | `math/fract` | Fractional operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | stem:[a - floor(a)]
|===

===== Negation

[cols="1h,1,2"]
|===
| Type | `math/neg` | Negation operation
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | stem:[-a]
|===

===== Addition

[cols="1h,1,2"]
|===
| Type | `math/add` | Addition operation
.2+| Input value sockets
| `floatN a` | First addend
| `floatN b` | Second addend
| Output value sockets
| `floatN value` | Sum, stem:[a + b]
|===

===== Subtraction

[cols="1h,1,2"]
|===
| Type | `math/sub` | Subtraction operation
.2+| Input value sockets
| `floatN a` | Minuend
| `floatN b` | Subtrahend
| Output value sockets
| `floatN value` | Difference, stem:[a - b]
|===

===== Multiplication

[cols="1h,1,2"]
|===
| Type | `math/mul` | Multiplication operation
.2+| Input value sockets
| `floatN a` | First factor
| `floatN b` | Second factor
| Output value sockets
| `floatN value` | Product, stem:[a * b]
|===

[NOTE]
.Note
====
For `float4x4` arguments, this operation performs per-component multiplication.
====

===== Division

[cols="1h,1,2"]
|===
| Type | `math/div` | Division operation
.2+| Input value sockets
| `floatN a` | Dividend
| `floatN b` | Divisor
| Output value sockets
| `floatN value` | Quotient, stem:[a / b]
|===

===== Remainder

[cols="1h,1,2"]
|===
| Type | `math/rem` | Remainder operation
.2+| Input value sockets
| `floatN a` | Dividend
| `floatN b` | Divisor
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \mathit{NaN} & \text{if } a = \pm \infty \text{ or } b = \pm 0 \\
                                a & \text{if } a \ne \pm \infty \text{ and } b = \pm \infty \\
                                a - (b \cdot trunc(\frac{a}{b})) & \text{otherwise}
                              \end{cases}]
|===

===== Minimum

[cols="1h,1,2"]
|===
| Type | `math/min` | Minimum operation
.2+| Input value sockets
| `floatN a` | First argument
| `floatN b` | Second argument
| Output value sockets
| `floatN value` | Smallest of the arguments
|===

===== Maximum

[cols="1h,1,2"]
|===
| Type | `math/max` | Maximum operation
.2+| Input value sockets
| `floatN a` | First argument
| `floatN b` | Second argument
| Output value sockets
| `floatN value` | Largest of the arguments
|===

===== Clamp

[cols="1h,1,2"]
|===
| Type | `math/clamp` | Clamp operation
.3+| Input value sockets
| `floatN a` | Value to clamp
| `floatN b` | First boundary
| `floatN c` | Second boundary
| Output value sockets
| `floatN value` | latexmath:[min(max(a, min(b, c)), max(b, c))]
|===

[NOTE]
.Note
====
This operation correctly handles a case when stem:[b] is greater than stem:[c].
====

===== Saturate

[cols="1h,1,2"]
|===
| Type | `math/saturate` | Saturate operation
| Input value sockets
| `floatN a` | Value to saturate
| Output value sockets
| `floatN value` | latexmath:[min(max(a, 0), 1)]
|===

===== Interpolate

[cols="1h,1,2"]
|===
| Type | `math/mix` | Linear interpolation operation
.3+| Input value sockets
| `floatN a` | Interpolated value at stem:[0]
| `floatN b` | Interpolated value at stem:[1]
| `floatN c` | Unclamped interpolation coefficient
| Output value sockets
| `floatN value` | stem:[(1 - c) * a + c * b]
|===

==== Comparison Nodes

If any input value is _NaN_, the output value is false.

===== Equality

[cols="1h,1,2"]
|===
| Type | `math/eq` | Equality operation
.2+| Input value sockets
| `floatN a` | First argument
| `floatN b` | Second argument
| Output value sockets
| `bool value` | True if the input arguments are equal, per-component; false otherwise
|===

===== Less Than

[cols="1h,1,2"]
|===
| Type | `math/lt` | Less than operation
.2+| Input value sockets
| `float a` | First argument
| `float b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a < b]; false otherwise
|===

===== Less Than Or Equal To

[cols="1h,1,2"]
|===
| Type | `math/le` | Less than or equal to operation
.2+| Input value sockets
| `float a` | First argument
| `float b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a <= b]; false otherwise
|===

===== Greater Than

[cols="1h,1,2"]
|===
| Type | `math/gt` | Greater than operation
.2+| Input value sockets
| `float a` | First argument
| `float b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a > b]; false otherwise
|===

===== Greater Than Or Equal To

[cols="1h,1,2"]
|===
| Type | `math/ge` | Greater than or equal operation
.2+| Input value sockets
| `float a` | First argument
| `float b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a >= b]; false otherwise
|===

==== Special Nodes

===== Is Not a Number

[cols="1h,1,2"]
|===
| Type | `math/isnan` | Not a Number check operation
| Input value sockets
| `float a` | Argument
| Output value sockets
| `bool value` | True if stem:[a] is _NaN_; false otherwise
|===

===== Is Infinity

[cols="1h,1,2"]
|===
| Type | `math/isinf` | Infinity check operation
| Input value sockets
| `float a` | Argument
| Output value sockets
| `bool value` | True if stem:[a] is positive or negative infinity; false otherwise
|===

===== Select

[cols="1h,1,2"]
|===
| Type | `math/select` | Conditional selection operation
.3+| Input value sockets
| `bool condition` | Value selecting the value returned
| `T a` | Positive selection option
| `T b` | Negative selection option
| Output value sockets
| `T value` | stem:[a] if the the `condition` input value is true; stem:[b] otherwise
|===

The type `T` represents any type. It **MUST** be the same for the output value socket and the input value sockets stem:[a] and stem:[b], otherwise the node is invalid.

==== Angle and Trigonometry Nodes

Node parameters specified as angle are assumed to be in units of radians.

These all operate component-wise. The description is per component.

If any input value is _NaN_, the output value is also _NaN_.

===== Degrees-To-Radians

[cols="1h,1,2"]
|===
| Type | `math/rad` | Converts degrees to radians
| Input value sockets
| `floatN a` | Value in degrees
| Output value sockets
| `floatN value` | stem:[a * pi / 180]
|===

===== Radians-To-Degrees

[cols="1h,1,2"]
|===
| Type | `math/deg` | Converts radians to degrees
| Input value sockets
| `floatN a` | Value in radians
| Output value sockets
| `floatN value` | stem:[a * 180 / pi]
|===

===== Sine

[cols="1h,1,2"]
|===
| Type | `math/sin` | Sine function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                sin(a) & \text{if } a \ne \pm\infty \\
                                \mathit{NaN} & \text{if } a = \pm\infty
                              \end{cases}]
|===

===== Cosine

[cols="1h,1,2"]
|===
| Type | `math/cos` | Cosine function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                cos(a) & \text{if } a \ne \pm\infty \\
                                \mathit{NaN} & \text{if } a = \pm\infty
                              \end{cases}]
|===

===== Tangent

[cols="1h,1,2"]
|===
| Type | `math/tan` | Tangent function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                tan(a) & \text{if } a \ne \pm\infty \\
                                \mathit{NaN} & \text{if } a = \pm\infty
                              \end{cases}]
|===

[NOTE]
.Note
====
Since stem:[a] cannot exactly represent latexmath:[\pm\frac{\pi}{2}], this function does not return infinity.
The closest representable argument values would likely produce latexmath:[\pm16331239353195370].
====

===== Arcsine

[cols="1h,1,2"]
|===
| Type | `math/asin` | Arcsine function
| Input value sockets
| `floatN a` | Sine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                arcsin(a) \in [-\frac{\pi}{2}; \frac{\pi}{2}\] & \text{if } \|a\| \le 1 \\
                                \mathit{NaN} & \text{if } \|a\| \gt 1
                              \end{cases}]
|===

===== Arccosine

[cols="1h,1,2"]
|===
| Type | `math/acos` | Arccosine function
| Input value sockets
| `floatN a` | Cosine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                arccos(a) \in [0; \pi\] & \text{if } \|a\| \le 1 \\
                                \mathit{NaN} & \text{if } \|a\| \gt 1
                              \end{cases}]
|===

===== Arctangent

[cols="1h,1,2"]
|===
| Type | `math/atan` | Arctangent function
| Input value sockets
| `floatN a` | Tangent value
| Output value sockets
| `floatN value` | latexmath:[arctan(a) \in [-\frac{\pi}{2}; \frac{\pi}{2}\]]
|===

===== Arctangent 2

[cols="1h,1,2"]
|===
| Type | `math/atan2` | Arctangent 2 function
.2+| Input value sockets
| `floatN a` | Y coordinate
| `floatN b` | X coordinate
| Output value sockets
| `floatN value` | Angle between the positive X-axis and the vector from the stem:[(0, 0)] origin to the stem:[(X, Y)] point on a 2D plane
|===

Zero and infinity argument values are handled according to <<ecma-262,ECMA-262>> or <<ieee-754,IEEE 754>> standards.

==== Hyperbolic Nodes

These all operate component-wise. The description is per component.

If any input value is _NaN_, the output value is also _NaN_.

===== Hyperbolic Sine

[cols="1h,1,2"]
|===
| Type |`math/sinh`| Hyperbolic sine function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\dfrac{e^a-e^{-a}}{2}]
|===

===== Hyperbolic Cosine

[cols="1h,1,2"]
|===
| Type |`math/cosh`| Hyperbolic cosine function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\dfrac{e^a+e^{-a}}{2}]
|===

===== Hyperbolic Tangent

[cols="1h,1,2"]
|===
| Type |`math/tanh`| Hyperbolic tangent function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\dfrac{e^a-e^{-a}}{e^a+e^{-a}}]
|===

===== Inverse Hyperbolic Sine

[cols="1h,1,2"]
|===
| Type |`math/asinh`| Inverse hyperbolic sine function
| Input value sockets
| `floatN a` | Hyperbolic sine value
| Output value sockets
| `floatN value` | latexmath:[ln(a+\sqrt{a^2+1})]
|===

===== Inverse Hyperbolic Cosine

[cols="1h,1,2"]
|===
| Type |`math/acosh`| Inverse hyperbolic cosine function
| Input value sockets
| `floatN a` | Hyperbolic cosine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                ln(a+\sqrt{a^2-1}) & \text{if } a \ge 1 \\
                                \mathit{NaN} & \text{if } a \lt 1
                              \end{cases}]
|===

===== Inverse Hyperbolic Tangent

[cols="1h,1,2"]
|===
| Type |`math/atanh`| Inverse hyperbolic tangent function
| Input value sockets
| `floatN a` | Hyperbolic tangent value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \dfrac{1}{2}ln\dfrac{1+a}{1-a} & \text{if } \|a\| \lt 1 \\
                                \pm\infty & \text{if } a = \pm1 \\
                                \mathit{NaN} & \text{if } \|a\| \gt 1
                              \end{cases}]
|===

==== Exponential Nodes

These all operate component-wise. The description is per component.

If any input value is _NaN_, the output value is also _NaN_.

===== Exponent

[cols="1h,1,2"]
|===
| Type | `math/exp` | Exponent function
| Input value sockets
| `floatN a` | Power value
| Output value sockets
| `floatN value` | stem:[e^a]
|===

===== Natural Logarithm

[cols="1h,1,2"]
|===
| Type | `math/log` | Natural logarithm function
| Input value sockets
| `floatN a` | Argument value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                ln(a) & \text{if } a \gt 0 \\
                                -\infty & \text{if } a = 0 \\
                                \mathit{NaN} & \text{if } a \lt 0
                              \end{cases}]
|===

===== Base-2 Logarithm

[cols="1h,1,2"]
|===
| Type | `math/log2` | Base-2 logarithm function
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                log_2(a) & \text{if } a \gt 0 \\
                                -\infty & \text{if } a = 0 \\
                                \mathit{NaN} & \text{if } a \lt 0
                              \end{cases}]
|===

===== Base-10 Logarithm

[cols="1h,1,2"]
|===
| Type | `math/log10` | Base-10 logarithm function
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                log_{10}(a) & \text{if } a \gt 0 \\
                                -\infty & \text{if } a = 0 \\
                                \mathit{NaN} & \text{if } a \lt 0
                              \end{cases}]
|===

===== Square Root

[cols="1h,1,2"]
|===
| Type | `math/sqrt` | Square root function
| Input value sockets
| `floatN a` | Radicand
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \sqrt{a} & \text{if } a \ge 0 \\
                                \mathit{NaN} & \text{if } a \lt 0
                              \end{cases}]
|===

===== Cube Root

[cols="1h,1,2"]
|===
| Type | `math/cbrt` | Cube root function
| Input value sockets
| `floatN a` | Radicand
| Output value sockets
| `floatN value` | latexmath:[\sqrt[3\]{a}]
|===

===== Power

[cols="1h,1,2"]
|===
| Type | `math/pow` | Power function
.2+| Input value sockets
| `floatN a` | Base
| `floatN b` | Exponent
| Output value sockets
| `floatN value` | stem:[a^b]
|===

Zero and infinity argument values are handled according to the <<ecma-262,ECMA-262>> standard.

==== Vector Nodes

If any input value is _NaN_, the output value is also _NaN_.

===== Length

[cols="1h,1,2"]
|===
| Type | `math/length` | Vector length
| Input value sockets
| `float{2\|3\|4} a` | Vector
| Output value sockets
| `float value` | Length of stem:[a], e.g., stem:[sqrt(a_x^2 + a_y^2)] for `float2`
|===

===== Normalize

[cols="1h,1,2"]
|===
| Type | `math/normalize` | Vector normalization
| Input value sockets
| `float{2\|3\|4} a` | Vector
| Output value sockets
| `floatN value` | Vector in the same direction as stem:[a] but with a unit length, e.g., stem:[a/sqrt(a_x^2 + a_y^2)] for `float2`
|===

===== Dot Product

[cols="1h,1,2"]
|===
| Type | `math/dot` | Dot product
.2+| Input value sockets
| `float{2\|3\|4} a` | First vector
| `float{2\|3\|4} b` | Second vector of the same type as stem:[a]
| Output value sockets
| `float value` | Sum of per-component products of stem:[a] and stem:[b], e.g., stem:[a_x * b_x + a_y * b_y] for `float2`
|===

===== Cross Product

[cols="1h,1,2"]
|===
| Type | `math/cross` | Cross product
.2+| Input value sockets
| `float3 a` | Vector
| `float3 b` | Vector
| Output value sockets
| `float3 value` | Cross product of stem:[a] and stem:[b], i.e., stem:[(a_y * b_z - a_z * b_y, a_z * b_x - a_x * b_z, a_x * b_y - a_y * b_x)]
|===

===== Rotate 2D

[cols="1h,1,2"]
|===
| Type | `math/rotate2d` | 2D rotation
.2+| Input value sockets
| `float2 a` | Vector to rotate
| `float b`  | Angle in radians
| Output value sockets
| `float2 value` | Vector stem:[a] rotated counter-clockwise by stem:[b]
|===

===== Rotate 3D

[cols="1h,1,2"]
|===
| Type | `math/rotate3d` | 3D rotation
.3+| Input value sockets
| `float3 a` | Vector to rotate
| `float3 b` | Vector representing an axis to rotate around
| `float c`  | Angle in radians
| Output value sockets
| `float3 value` | Vector stem:[a] rotated around vector stem:[b] counter-clockwise by stem:[c]
|===

If the vector stem:[b] is not unit, rotation results may be undefined.

===== Transform

[cols="1h,1,2"]
|===
| Type | `math/transform` | Vector transformation
.2+| Input value sockets
| `float4 a`   | Vector to transform
| `float4x4 b` | Transformation matrix
| Output value sockets
| `float4 value` | Transformed vector
|===

===== Combine

[cols="1h,1,2"]
|===
| Type | `math/combine2` | Combine two floats into a two-component vector
.2+| Input value sockets
| `float a` | First component
| `float b` | Second component
| Output value sockets
| `float2 value` | Vector
|===

[cols="1h,1,2"]
|===
| Type | `math/combine3` | Combine three floats into a three-component vector
.3+| Input value sockets
| `float a` | First component
| `float b` | Second component
| `float c` | Third component
| Output value sockets
| `float3 value` | Vector
|===

[cols="1h,1,2"]
|===
| Type | `math/combine4` | Combine four floats into a four-component vector
.4+| Input value sockets
| `float a` | First component
| `float b` | Second component
| `float c` | Third component
| `float d` | Fourth component
| Output value sockets
| `float4 value` | Vector
|===

===== Extract

[cols="1h,1,2"]
|===
| Type | `math/extract2` | Extract two floats from a two-component vector
| Input value sockets
| `float2 a` | Vector
.2+| Output value sockets
| `float 0` | First component
| `float 1` | Second component
|===

[cols="1h,1,2"]
|===
| Type | `math/extract3` | Extract three floats from a three-component vector
| Input value sockets
| `float3 a` | Vector
.3+| Output value sockets
| `float 0` | First component
| `float 1` | Second component
| `float 2` | Third component
|===

[cols="1h,1,2"]
|===
| Type | `math/extract4` | Extract four floats from a four-component vector
| Input value sockets
| `float4 a` | Vector
.4+| Output value sockets
| `float 0` | First component
| `float 1` | Second component
| `float 2` | Third component
| `float 3` | Fourth component
|===

==== Matrix Nodes

===== Transpose

[cols="1h,1,2"]
|===
| Type | `math/transpose` | Transpose operation
| Input value sockets
| `float4x4 a` | Matrix to transpose
| Output value sockets
| `float4x4 value` | Matrix that is the transpose of stem:[a]
|===

===== Determinant

[cols="1h,1,2"]
|===
| Type | `math/determinant` | Dot product
| Input value sockets
| `float4x4 a` | Matrix
| Output value sockets
| `float value` | Determinant of stem:[a]
|===

===== Inverse

[cols="1h,1,2"]
|===
| Type | `math/inverse` | Inverse operation
| Input value sockets
| `float4x4 a` | Matrix to inverse
| Output value sockets
| `float4x4 value` | Matrix that is the inverse of stem:[a]
|===

===== Multiplication

[cols="1h,1,2"]
|===
| Type | `math/matmul` | Matrix multiplication operation
.2+| Input value sockets
| `float4x4 a` | First matrix
| `float4x4 b` | Second matrix
| Output value sockets
| `float4x4 value` | Matrix product
|===

===== Combine

[cols="1h,1,2"]
|===
| Type | `math/combine4x4` | Combine 16 floats into a 4x4 matrix
.16+| Input value sockets
| `float a` | First row, first column element
| `float b` | Second row, first column element
| `float c` | Third row, first column element
| `float d` | Fourth row, first column element
| `float e` | First row, second column element
| `float f` | Second row, second column element
| `float g` | Third row, second column element
| `float h` | Fourth row, second column element
| `float i` | First row, third column element
| `float j` | Second row, third column element
| `float k` | Third row, third column element
| `float l` | Fourth row, third column element
| `float m` | First row, fourth column element
| `float n` | Second row, fourth column element
| `float o` | Third row, fourth column element
| `float p` | Fourth row, fourth column element
| Output value sockets
| `float4x4 value` | Matrix
|===

===== Extract

[cols="1h,1,2"]
|===
| Type | `math/extract4x4` | Extract 16 floats from a 4x4 matrix
| Input value sockets
| `float4x4 a` | Matrix
.16+| Output value sockets
| `float 0`  | First row, first column element
| `float 1`  | Second row, first column element
| `float 2`  | Third row, first column element
| `float 3`  | Fourth row, first column element
| `float 4`  | First row, second column element
| `float 5`  | Second row, second column element
| `float 6`  | Third row, second column element
| `float 7`  | Fourth row, second column element
| `float 8`  | First row, third column element
| `float 9`  | Second row, third column element
| `float 10` | Third row, third column element
| `float 11` | Fourth row, third column element
| `float 12` | First row, fourth column element
| `float 13` | Second row, fourth column element
| `float 14` | Third row, fourth column element
| `float 15` | Fourth row, fourth column element
|===

==== Integer Arithmetic Nodes

All inputs to these nodes are two's complement 32-bit signed integers.

===== Absolute Value

[cols="1h,1,2"]
|===
| Type | `math/abs` | Absolute value operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | latexmath:[\begin{cases}
                             -a & \text{if } a \lt 0 \\
                              a & \text{if } a \ge 0
                           \end{cases}]
|===

As this node is defined in terms of the negation node (see below), the absolute value of `-2147483648` is `-2147483648`.

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.abs(a)|0
----
====

===== Sign

[cols="1h,1,2"]
|===
| Type | `math/sign` | Sign operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | latexmath:[\begin{cases}
                             -1 & \text{if } a \lt 0 \\
                              0 & \text{if } a = 0 \\
                             +1 & \text{if } a \gt 0
                           \end{cases}]
|===

===== Negation

[cols="1h,1,2"]
|===
| Type | `math/neg` | Negation operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | stem:[-a]
|===

Negating `-2147483648` **MUST** return `-2147483648`.

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(-a)|0
----
====

===== Addition

[cols="1h,1,2"]
|===
| Type | `math/add` | Addition operation
.2+| Input value sockets
| `int a` | First addend
| `int b` | Second addend
| Output value sockets
| `int value` | Sum, stem:[a + b]
|===

Arithmetic overflow **MUST** wrap around, for example:

[source]
----
2147483647 + 1 == -2147483648
----

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(a + b)|0
----
====

===== Subtraction

[cols="1h,1,2"]
|===
| Type | `math/sub` | Subtraction operation
.2+| Input value sockets
| `int a` | Minuend
| `int b` | Subtrahend
| Output value sockets
| `int value` | Difference, stem:[a - b]
|===

Arithmetic overflow **MUST** wrap around, for example:

[source]
----
-2147483648 - 1 == 2147483647
----

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(a - b)|0
----
====

===== Multiplication

[cols="1h,1,2"]
|===
| Type | `math/mul` | Multiplication operation
.2+| Input value sockets
| `int a` | First factor
| `int b` | Second factor
| Output value sockets
| `int value` | Product, stem:[a * b]
|===

Arithmetic overflow **MUST** wrap around, for example:

[source]
----
 2147483647 * 2147483647 == 1

-2147483648 * (-1)       == -2147483648
----

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.imul(a, b)
----
====

===== Division

[cols="1h,1,2"]
|===
| Type | `math/div` | Division operation
.2+| Input value sockets
| `int a` | Dividend
| `int b` | Divisor
| Output value sockets
| `int value` | latexmath:[\begin{cases}
                             \frac{a}{b} & \text{if } b \ne 0 \\
                             0 & \text{if } b = 0
                           \end{cases}]
|===

The quotient **MUST** be truncated towards zero.

Arithmetic overflow is defined as follows:
[source]
----
-2147483648 / (-1) == -2147483648
----

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(a / b)|0
----
====

===== Remainder

[cols="1h,1,2"]
|===
| Type | `math/rem` | Remainder operation
.2+| Input value sockets
| `int a` | Dividend
| `int b` | Divisor
| Output value sockets
| `int value` | latexmath:[\begin{cases}
                             a - (b \cdot trunc(\frac{a}{b})) & \text{if } b \ne 0 \\
                             0 & \text{if } b = 0
                           \end{cases}]
|===

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(a % b)|0
----
====

===== Minimum

[cols="1h,1,2"]
|===
| Type | `math/min` | Minimum operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `int value` | Smallest of the arguments
|===

===== Maximum

[cols="1h,1,2"]
|===
| Type | `math/max` | Maximum operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `int value` | Largest of the arguments
|===

===== Clamp

[cols="1h,1,2"]
|===
| Type | `math/clamp` | Clamp operation
.3+| Input value sockets
| `int a` | Value to clamp
| `int b` | First boundary
| `int c` | Second boundary
| Output value sockets
| `int value` | latexmath:[min(max(a, min(b, c)), max(b, c))]
|===

[NOTE]
.Note
====
This operation correctly handles a case when stem:[b] is greater than stem:[c].
====

==== Integer Comparison Nodes

All inputs to these nodes are two's complement 32-bit signed integers.

===== Equality

[cols="1h,1,2"]
|===
| Type | `math/eq` | Equality operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `bool value` | True if the input arguments are equal; false otherwise
|===

===== Less Than

[cols="1h,1,2"]
|===
| Type | `math/lt` | Less than operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a < b]; false otherwise
|===

===== Less Than Or Equal To

[cols="1h,1,2"]
|===
| Type | `math/le` | Less than or equal to operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a <= b]; false otherwise
|===

===== Greater Than

[cols="1h,1,2"]
|===
| Type | `math/gt` | Greater than operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a > b]; false otherwise
|===

===== Greater Than Or Equal To

[cols="1h,1,2"]
|===
| Type | `math/ge` | Greater than or equal operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a >= b]; false otherwise
|===

==== Integer Bitwise Nodes

All inputs to these nodes are two's complement 32-bit signed integers.

===== Bitwise NOT

[cols="1h,1,2"]
|===
| Type | `math/not` | Bitwise NOT operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | `~a`
|===

===== Bitwise AND

[cols="1h,1,2"]
|===
| Type | `math/and` | Bitwise AND operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `int value` | `a & b`
|===

===== Bitwise OR

[cols="1h,1,2"]
|===
| Type | `math/or` | Bitwise OR operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `int value` | `a \| b`
|===

===== Bitwise XOR

[cols="1h,1,2"]
|===
| Type | `math/xor` | Bitwise XOR operation
.2+| Input value sockets
| `int a` | First argument
| `int b` | Second argument
| Output value sockets
| `int value` | `a ^ b`
|===

===== Right Shift

[cols="1h,1,2"]
|===
| Type | `math/asr` | Right Shift
.2+| Input value sockets
| `int a` | Value to be shifted
| `int b` | Number of bits to shift by
| Output value sockets
| `int value` | `a >> b`
|===

Only the lowest 5 bits of stem:[b] are considered, i.e., its effective range is [0, 31]. The result **MUST** be truncated to 32 bits and interpreted as a two's complement signed integer. The most significant bit of stem:[a] **MUST** be propagated.

===== Left Shift

[cols="1h,1,2"]
|===
| Type | `math/lsl` | Left Shift
.2+| Input value sockets
| `int a` | Value to be shifted
| `int b` | Number of bits to shift by
| Output value sockets
| `int value` | `a << b`
|===

Only the lowest 5 bits of stem:[b] are considered, i.e., its effective range is [0, 31]. The result **MUST** be truncated to 32 bits and interpreted as a two's complement signed integer.

===== Count Leading Zeros

[cols="1h,1,2"]
|===
| Type | `math/clz` | Count leading zeros operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | Number of leading zero bits in stem:[a]
|===

If stem:[a] is 0, the operation returns 32; if stem:[a] is negative, the operation returns 0.

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.clz32(a)
----
====

===== Count Trailing Zeros

[cols="1h,1,2"]
|===
| Type | `math/ctz` | Count trailing zeros operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | Number of trailing zero bits in stem:[a]
|===

If stem:[a] is 0, the operation returns 32.

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
a ? (31 - Math.clz32(a & -a)) : 32;
----
====

===== Count One Bits

[cols="1h,1,2"]
|===
| Type | `math/popcnt` | Count set bits operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | Number of set bits in stem:[a]
|===

If stem:[a] is 0, the operation returns 0; if stem:[a] is -1, the operation returns 32.

==== Boolean Arithmetic Nodes

===== Equality

[cols="1h,1,2"]
|===
| Type | `math/eq` | Equality operation
.2+| Input value sockets
| `bool a` | First argument
| `bool b` | Second argument
| Output value sockets
| `bool value` | True if and only if both stem:[a] and stem:[b] have the same value; false otherwise
|===

===== Boolean NOT

[cols="1h,1,2"]
|===
| Type | `math/not` | Boolean NOT operation
| Input value sockets
| `bool a` | Argument
| Output value sockets
| `bool value` | True if stem:[a] is false; false if stem:[a] is true
|===

===== Boolean AND

[cols="1h,1,2"]
|===
| Type | `math/and` | Boolean AND operation
.2+| Input value sockets
| `bool a` | First argument
| `bool b` | Second argument
| Output value sockets
| `bool value` | True if and only if both stem:[a] and stem:[b] are true; false otherwise
|===

===== Boolean OR

[cols="1h,1,2"]
|===
| Type | `math/or` | Boolean OR operation
.2+| Input value sockets
| `bool a` | First argument
| `bool b` | Second argument
| Output value sockets
| `bool value` | False if and only if both stem:[a] and stem:[b] are false; true otherwise
|===

===== Boolean XOR

[cols="1h,1,2"]
|===
| Type | `math/xor` | Boolean XOR operation
.2+| Input value sockets
| `bool a` | First argument
| `bool b` | Second argument
| Output value sockets
| `bool value` | True if and only if stem:[a] is not equal to stem:[b]; false otherwise
|===

=== Type Conversion Nodes

==== Boolean Conversion Nodes

===== Boolean to Integer

[cols="1h,1,2"]
|===
| Type | `type/boolToInt` | Boolean to integer conversion
| Input value sockets
| `bool a` | Argument
| Output value sockets
| `int value` | stem:[1] if stem:[a] is true; stem:[0] otherwise
|===

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
a|0
----
====

===== Boolean to Float

[cols="1h,1,2"]
|===
| Type | `type/boolToFloat` | Boolean to float conversion
| Input value sockets
| `bool a` | Argument
| Output value sockets
| `float value` | stem:[1] if stem:[a] is true; stem:[0] otherwise
|===

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
+a
----
====

==== Integer Conversion Nodes

===== Integer to Boolean

[cols="1h,1,2"]
|===
| Type | `type/intToBool` | Integer to boolean conversion
| Input value sockets
| `int a` | Argument
| Output value sockets
| `bool value` | True if stem:[a] is not equal to zero; false otherwise
|===

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
!!a
----
====

===== Integer to Float

[cols="1h,1,2"]
|===
| Type | `type/intToFloat` | Integer to float conversion
| Input value sockets
| `int a` | Argument
| Output value sockets
| `float value` | Floating-point value equal to stem:[a]
|===

Since floating-point values have double precision, this conversion **MUST** be lossless.

This operation **MUST NOT** produce negative zero.

[NOTE]
.Note
====
This operation is no-op in ECMAScript.
====

==== Float Conversion Nodes

===== Float to Boolean

[cols="1h,1,2"]
|===
| Type | `type/floatToBool` | Float to boolean conversion
| Input value sockets
| `float a` | Argument
| Output value sockets
| `bool value` | False if stem:[a] is NaN or equal to zero; true otherwise
|===

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
!!a
----
====

===== Float to Integer

[cols="1h,1,2"]
|===
| Type | `type/floatToInt` | Float to integer conversion
| Input value sockets
| `float a` | Argument
| Output value sockets
| `int value` | Integer value produced as described below
|===

1. If the stem:[a] input value is zero, infinite, or NaN, return zero and skip the next steps.
2. Let stem:[t] be stem:[a] with its fractional part removed by rounding towards zero.
3. Let stem:[k] be a value of the same sign as stem:[t] such that its absolute value is less than stem:[2^32] and stem:[k] is equal to stem:[t - q * 2^32] for some integer stem:[q].
4. If stem:[k] is greater than or equal to stem:[2^31], return stem:[k - 2^32]; otherwise return stem:[k].

[NOTE]
.Note
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
a|0
----
====

=== Control Flow Nodes

==== Sync Nodes

===== Sequence

[cols="1h,1,2"]
|===
| Type | `flow/sequence` | Sequentially activate all connected output flows
| Input flow sockets
|  `in`  | The entry flow into this node
| Output flow sockets
| `<name>` | One or more output flows; their names are purely informative
|===

This node has no internal state.

When the `in` input flow is activated, all output flows are activated one by one in the order they are defined in JSON.

===== Branch

[cols="1h,1,2"]
|===
| Type | `flow/branch` | Branch the execution flow based on a condition
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `bool condition` | Value selecting the branch taken
.2+| Output flow sockets
| `true`  | The flow to be activated if the `condition` input value is true
| `false` | The flow to be activated if the `condition` input value is false
|===

This node has no internal state.

The `condition` input value is evaluated each time the node is executed.

===== Switch

[cols="1h,1,2"]
|===
| Type | `flow/switch` | Conditionally route the execution flow to one of the outputs
| Configuration
| `int[] cases` | The cases on which to perform the switch on; values **MUST** be unique 32-bit signed integers; at least one value **MUST** be present
| Input flow sockets
|   `in`  | The entry flow into this node
| Input value sockets
| `int selection` | The value on which the switch operates
.2+| Output flow sockets
| `<case>`  | The output flow, `case` is an integer decimal number present in the `cases` configuration array
| `default` | The output flow used when the `selection` input value is not present in the `cases` configuration array
|===

The node has one or more `<case>` output flow sockets named as decimal integers equal to the elements of the `cases` configuration array. Encoded as JSON strings, these output flow socket names **MUST** contain only decimal integers (ASCII characters `0x30 ... 0x39`) and optionally a leading minus sign (ASCII character `0x2D`); other characters and leading zeros are not allowed.

For example, if the `cases` configuration array is `[-1, 0, 1]`, the output socket names are exactly `"-1"`, `"0"`, and `"1"`.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate the `selection` input value.
2. If the `cases` configuration array does not contain the `selection` input value:
.. activate the `default` output flow if it is connected.
3. If the `cases` configuration array contains the `selection` input value:
.. activate the output flow named `<selection>` if it is connected.

===== While Loop

[cols="1h,1,2"]
|===
| Type | `flow/while` | Repeatedly activate the output flow based on a condition
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `bool condition` | Loop condition
.2+| Output flow sockets
| `loopBody`  | The flow to be activated while the `condition` input value is true
| `completed` | The flow to be activated once the `condition` input value is false
|===

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate the `condition`. The `condition` **MUST NOT** statically evaluate to true, otherwise the node is invalid.
2. If the `condition` is true,
.. activate the `loopBody` output flow;
.. after completion of the `loopBody` output flow, goto step 1.
3. If the `condition` is false,
.. activate the `completed` output flow.

===== For Loop

[cols="1h,1,2"]
|===
| Type | `flow/for` | Repeatedly activate the output flow based on an incrementing index value
| Configuration
| `int initialIndex` | The index value before the loop starts
| Input flow sockets
| `in` | The entry flow into this node
.2+| Input value sockets
| `int startIndex` | The start index of the loop
| `int endIndex` | The end index of the loop
.2+| Output flow sockets
| `loopBody`  | The flow to be activated if the `index` value is less than the `endIndex` input value
| `completed` | The flow to be activated if the `index` value is greater than or equal to the `endIndex` input value
| Output value sockets
| `int index` | The current index value if the node has ever been activated, `initialIndex` otherwise
|===

The internal state of this node consists of one 32-bit signed integer value `index` initialized to `initialIndex`.

When the `in` input flow is activated:

1. Evaluate the `startIndex` input value.
2. Set `index` to `startIndex`.
3. Evaluate the `endIndex` input value.
4. If `index` is less than the `endIndex` input value,
.. activate the `loopBody` output flow;
.. after completion of the `loopBody` output flow, increment the `index` value by 1;
.. goto step 3.
5. If the `index` value is greater than or equal to the `endIndex` input value,
.. activate the `completed` output flow.

===== Do N

[cols="1h,1,2"]
|===
| Type | `flow/doN` | Activate the output flow no more than N times
.2+| Input flow sockets
|   `in`  | The entry flow into this node
| `reset` | When this flow is activated, the `currentCount` value is reset to 0
| Input value sockets
| `int n` | Maximum number of times the `out` output flow is activated
| Output flow sockets
| `out` | The flow to be activated if the `currentCount` value is less than the `n` input value
| Output value sockets
| `int currentCount` | The current execution count
|===

The internal state of this node consists of one 32-bit signed integer value `currentCount` initialized to 0.

When the `reset` input flow is activated:

1. Reset `currentCount` to 0.

When the `in` input flow is activated:

1. Evaluate the `n` input value.
2. If `currentCount` is less than `n`,
.. increment `currentCount` by 1;
.. activate the `out` output flow.

===== Multi Gate

[cols="1h,1,2"]
|===
| Type | `flow/multiGate` | Route the execution flow to one of the outputs sequentially or randomly
.2+| Configuration
| `bool isRandom` | If set to true, output flows are executed in random order, picking a random not used output flow each time until all are done
| `bool isLoop` | If set to true, the outputs will repeat in a loop continuously after all are done
.2+| Input flow sockets
|   `in`  | The entry flow into this node
| `reset` | When this flow is activated, the `lastIndex` value is reset to -1 and all outputs are marked as not used
| Output flow sockets
| `<name>`  | One or more output flows; their names are purely informative
| Output value sockets
| `int lastIndex` | The index of the last used output; `-1` if the node has not been activated
|===

The internal state of this node consists of one 32-bit signed integer value `lastIndex` initialized to -1 and an array of booleans with all values initialized to false representing used output flows. The size of the boolean array is equal to the number of output flows.

The output flows are ordered as they are defined in JSON.

When the `reset` input flow is activated:

1. Reset the `lastIndex` value to -1.
2. Mark all output flows as not used in the boolean array.

When the `in` input flow is activated:

1. If the `isRandom` configuration value is false,
.. let `i` be the smallest not used output flow index according to the boolean array or -1 if all output flows are marked as used.
2. If the `isRandom` configuration value is true,
.. let `i` be a random not used output flow index according to the boolean array or -1 if all output flows are marked as used.
3. If `i` is greater than -1,
.. mark the output flow with index `i` as used in the boolean array;
.. set the `lastIndex` value to `i`;
.. activate the output flow with index `i`.
4. If `i` is equal to -1 and the `isLoop` configuration value is true,
.. mark all output flows as not used in the boolean array;
.. if the `isRandom` configuration value is false,
... set `i` to 0;
.. if the `isRandom` configuration value is true,
... set `i` to a random output flow index;
.. mark the output flow with index `i` as used in the boolean array;
.. set the `lastIndex` value to `i`;
.. activate the output flow with index `i`.

===== Wait All

[cols="1h,1,2"]
|===
| Type | `flow/waitAll` | Activate the output flow when all input flows have been activated at least once.
| Configuration
| `int inputFlows` | The number of input flows, **MUST** be greater than 0 and less than or equal to 2147483647
.2+| Input flow sockets
|   `<i>`  | The `i`-th input flow, `i` is a non-negative integer decimal number less than the `inputFlows` configuration value
| `reset` | When this flow is activated, all input flows are marked as unused
.2+| Output flow sockets
|    `out`    | The flow to be activated after every input flow activation except the last missing input
| `completed` | The flow to be activated when the last missing input flow is activated
| Output value sockets
| `int remainingInputs` | The number of not yet activated input flows
|===

The node has one or more input flow sockets named as sequential non-negative decimal integers depending on the `inputFlows` configuration value. Encoded as JSON strings, these input flow socket names contain only decimal integers (ASCII characters `0x30 ... 0x39`); other characters and leading zeros are not allowed.

For example, if `inputFlows` is 3, the input socket names are `"0"`, `"1"`, and `"2"` exactly.

The internal state of this node consists of one 32-bit signed integer value `remainingInputs` initialized to the number of connected input flows not including the `reset` input flow and a map of booleans with all values initialized to false representing used input flow sockets. The size of the boolean map is equal to the initial `remainingInputs` value.

When the `reset` input flow is activated:

1. Reset `remainingInputs` to the number of connected input flows not including the `reset` input flow.
2. Mark all connected input flows as not used in the boolean map.

When any of the `<i>` input flows is activated:

1. If the `<i>`-th input flow is not marked as used in the boolean map:
.. mark the `<i>`-th input flow as used in the boolean map.
.. decrement the `remainingInputs` value by 1;
2. If the `remainingInputs` value is zero:
.. activate the `completed` output flow.
3. If the `remainingInputs` value is not zero:
.. activate the `out` output flow.

===== Throttle

[cols="1h,1,2"]
|===
| Type | `flow/throttle` | Activate the output flow unless it has been activated less than a certain time ago
.2+| Input flow sockets
|   `in`  | The entry flow into this node
| `reset` | When this flow is activated, the output flow throttling state is reset
| Input value sockets
| `float duration` | The time, in seconds, to wait after an output flow activation before allowing subsequent output flow activations
.2+| Output flow sockets
| `out` | The flow to be activated if the output flow is not currently throttled
| `err` | The flow to be activated if the `duration` input value is negative, infinite, or NaN
| Output value sockets
| `float lastRemainingTime` | The remaining throttling time, in seconds, at the moment of the last valid activation of the input flow or NaN if the input flow has never been activated with a valid `duration` input value
|===

The internal state of this node consists of an uninitialized _timestamp_ value of an implementation-defined high-precision time type and a floating-point `lastRemainingTime` value initialized to NaN.

When the `reset` input flow is activated:

1. Reset the `lastRemainingTime` value to NaN.

When the `in` input flow is activated:

1. Evaluate the `duration` input value.
2. If the `duration` input value is NaN, infinite, negative, or not convertible into an implementation-specific time type used for the internal _timestamp_ value,
.. activate the `err` output flow and skip the next steps.
3. If the `lastRemainingTime` value is not NaN:
.. Let `elapsed` be a non-negative difference, in seconds, between the _timestamp_ and the current time.
.. If the `duration` input value is less than or equal to the `elapsed` value,
... set the _timestamp_ value to the current time;
... set the `lastRemainingTime` value to zero;
... activate the `out` output flow.
.. If the `duration` input value is greater than the `elapsed` value,
... set the `lastRemainingTime` value to the positive difference, in seconds, between the `duration` and `elapsed` values.
4. If the `lastRemainingTime` value is NaN,
.. set the _timestamp_ value to the current time;
.. set the `lastRemainingTime` value to zero;
.. activate the `out` output flow.

==== Delay Nodes

===== Set Delay

[cols="1h,1,2"]
|===
| Type | `flow/setDelay` | Schedule the output flow activation after a certain delay
.2+| Input flow sockets
|   `in`   | The entry flow into this node
| `cancel` | When this flow is activated, all delayed activations scheduled by this node are cancelled
| Input value sockets
| `float duration` | The duration, in seconds, to delay the `completed` output flow activation
| Output value sockets
| `int lastDelayIndex` | The delay index assigned during the last successful node execution
.3+| Output flow sockets
| `out` | The flow to be activated if the `duration` value is valid
| `err` | The flow to be activated if the `duration` value is invalid
| `completed` | The flow to be activated after the delay
|===

The internal state of this node consists of an integer `lastDelayIndex` value initialized to -1 and a dynamic array of activation indices scheduled by the node. This array is initially empty and its maximum size is implementation-specific.

The internal state of an execution graph having one or more `flow/setDelay` nodes includes a dynamic array of activation indices scheduled from all such nodes. This array is initially empty and its maximum size is implementation-specific.

Implementations **MUST** be aware of their effective limit on the maximum supported `duration` input value to avoid any implicit behavior changes, e.g., due to numeric overflows; exceeding such value **MUST** lead to the `err` output flow activation as described below.

When the `in` input flow is activated:

1. Evaluate the `duration` input value.
2. If the `duration` input value is NaN, infinite, negative, or not convertible into an implementation-specific time type,
.. activate the `err` output flow and skip the next steps.
3. If scheduling a new activation exceeds any implementation-specific limit,
.. activate the `err` output flow and skip the next steps.
4. Let _activationTime_ be an implementation-defined high-precision time value equal to the sum of the current time value and the `duration` input value converted to the same time type.
5. If _activationTime_ is not valid according to implementation-specific validation rules, e.g., it exceeds an internal threshold value,
.. activate the `err` output flow and skip the next steps.
6. Set `lastDelayIndex` to a positive value representing the delayed flow activation being scheduled. This value **MUST** be unique across all previous activations of all `flow/setDelay` nodes of the graph.
7. Push the value of `lastDelayIndex` to the graph and node arrays of activation indices.
8. Schedule the following actions at the _activationTime_ time:
.. Removal of the activation index value from both arrays of activation indices.
.. Activation of the `completed` output flow.
9. Activate the `out` output flow.

When the `cancel` input flow is activated:

1. Set the `lastDelayIndex` value to -1.
2. For each activation index value in the node's array of activation indices:
.. Remove this activation index value from the node's and the graph's arrays of activation indices.
.. Cancel the corresponding scheduled activation.

===== Cancel Delay

[cols="1h,1,2"]
|===
| Type | `flow/cancelDelay` | Cancel a previously scheduled output flow activation
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `int delayIndex` | The index value of the scheduled activation to be cancelled
| Output flow sockets
| `out` | The flow to be activated after executing this node
|===

This node has no internal state but its execution **MAY** affect internal states of other nodes and the graph. 

When the `in` input flow is activated:

1. Evaluate the `delayIndex` input value.
2. Remove this activation index value from all arrays of activation indices if it exists.
3. Cancel the corresponding scheduled activation if it exists.
4. Activate the `out` output flow.

Non-positive or not existing delay index values **MUST NOT** cause any runtime errors.

=== State Manipulation Nodes

==== Custom Variable Access

===== Variable Get

[cols="1h,1,2"]
|===
| Type | `variable/get` | Get a custom variable value
| Configuration
| `int variable` | The custom variable index
| Output value sockets
| `T value`  | The custom variable value
|===

This node gets a custom variable value using the variable index provided by the `variable` configuration value. The type `T` is determined by the referenced variable. The variable index **MUST** be non-negative and less than the total number of custom variables, otherwise the node is invalid.

This node has no internal state.

===== Variable Set

[cols="1h,1,2"]
|===
| Type | `variable/set` | Set a custom variable value
| Configuration
| `int variable` | The custom variable index
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `T value` | The new variable value
| Output flow sockets
| `out` | The flow to be activated after the value is set
|===

This node sets a custom variable value using the variable index provided by the `variable` configuration value and the `value` input value. The type `T` is determined by the referenced variable. The variable index **MUST** be non-negative and less than the total number of custom variables, otherwise the node is invalid.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate the `value` input value.
2. Set the custom variable with the `variable` configuration value index to the `value` input value.
3. Activate the `out` output flow.

==== Object Model Access

===== Pointer Get

[cols="1h,1,2"]
|===
| Type | `pointer/get` | Get an object model property value
| Configuration
| `string pointer` | The JSON pointer or JSON pointer template
| Input value sockets
| `int <segment>` | The JSON pointer template path segment to be substituted at runtime
.2+| Output value sockets
| `T value`  | The resolved property value
| `bool isValid`  | True if the property value can be resolved, false otherwise
|===

This node gets a glTF Asset Object Model value using the provided JSON pointer. The type `T` is determined by the pointer string according to the glTF Asset Object Model Specification. If the type of the pointer cannot be statically determined, the node is invalid. Pointers containing `extras` properties are out of scope of this specification but **MAY** be supported by implementations.

[NOTE]
.Examples
====
The `pointer` configuration value `"/nodes/0/scale"` is valid; its output value socket is of `float3` type.

The `pointer` configuration value `"/myProperty"` is invalid because this path is not defined.
====

The pointer string **MAY** be a template pointer string, i.e., it **MAY** contain path segments substituted at runtime using the input values. All input values **MUST** be of `int` type. Path segments, if used, **MUST** substitute only array indices in the pointer templates as listed in the glTF Asset Object Model Specification.

[NOTE]
.Example
====
If the `pointer` configuration value is `"/nodes/{myId}/scale"`, the node has the `myId` input value socket, which value denotes the node index.
====

This node has no internal state.

If the pointer or the pointer template with all its substitutions applied can be resolved, the `value` output value is the resolved property value and the `isValid` output value is true.

If the pointer or the pointer template with all its substitutions applied cannot be resolved, the `value` output value is the default value for its type and the `isValid` output value is false.

[NOTE]
.Note
====
Unresolvable pointers include those with negative or out-of-bounds array indices and/or non-existent JSON objects.
====

===== Pointer Set

[cols="1h,1,2"]
|===
| Type | `pointer/set` | Set an object model property value
| Configuration
| `string pointer` | The JSON pointer or JSON pointer template
| Input flow sockets
| `in` | The entry flow into this node
.2+| Input value sockets
| `int <segment>` | The JSON pointer template path segment to be substituted at runtime
| `T value` | The new property value
.2+| Output flow sockets
| `out` | The flow to be activated if the JSON pointer can be resolved
| `err` | The flow to be activated if the JSON pointer cannot be resolved
|===

This node sets a glTF Asset Object Model value using the provided JSON pointer. The type `T` is determined by the pointer string according to the glTF Asset Object Model Specification. If the type of the pointer cannot be statically determined, the node is invalid. Pointers containing `extras` properties are out of scope of this specification but **MAY** be supported by implementations.

The pointer string **MAY** be a template pointer string, i.e., it **MAY** contain path segments substituted at runtime using the input values. All input values used for path segment substitutions **MUST** be of `int` type. Path segments, if used, **MUST** substitute only array indices in the pointer templates as listed in the glTF Asset Object Model Specification.

If the `value` input value is not valid for the resolved property, the effective property value becomes implementation-defined and subsequent `pointer/get` evaluations of the property **MAY** return any value of the corresponding type until the property is updated with a valid value.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate all input values.
2. If the pointer or the pointer template with all its substitutions applied can be resolved,
.. if the _pointer interpolation state dynamic array_ (defined below) contains an entry with the same resolved JSON Pointer value, remove it from the array;
.. set the resolved property to the `value` input value;
.. activate the `out` output flow.
3. If the pointer or the pointer template with all its substitutions applied cannot be resolved,
.. activate the `err` output flow.

===== Pointer Interpolate

[cols="1h,1,2"]
|===
| Type | `pointer/interpolate` | Interpolate an object model property value
| Configuration
| `string pointer` | The JSON pointer or JSON pointer template
| Input flow sockets
| `in` | The entry flow into this node
.5+| Input value sockets
| `int <segment>` | The JSON pointer template path segment to be substituted at runtime
| `T value` | The target property value
| `float duration` | The time, in seconds, in which the property **SHOULD** reach the target value
| `float2 p1` | Control point P1
| `float2 p2` | Control point P2
.3+| Output flow sockets
| `out` | The flow to be activated if the JSON pointer can be resolved and the input values are valid
| `err` | The flow to be activated if the JSON pointer cannot be resolved or the input values are invalid
| `done` | The flow to be activated when the property reaches the target value
|===

This node interpolates and updates the specified glTF Asset Object Model property multiple times over the specified duration using the provided JSON pointer. The type `T` is determined by the pointer string according to the glTF Asset Object Model Specification. If the type of the pointer cannot be statically determined or if it is integer or boolean, the node is invalid. Pointers containing `extras` properties are out of scope of this specification but **MAY** be supported by implementations.

The pointer string **MAY** be a template pointer string, i.e., it **MAY** contain path segments substituted at runtime using the input values. All input values used for path segment substitutions **MUST** be of `int` type. Path segments, if used, **MUST** substitute only array indices in the pointer templates as listed in the glTF Asset Object Model Specification.

If the `value` input value or any intermediate interpolated value are not valid for the resolved property, the effective property value becomes implementation-defined and subsequent `pointer/get` evaluations of the property **MAY** return any value of the corresponding type until the property is updated with a valid value.

This node has no internal state.

When a node of this type is used in the behavior graph, the global graph state includes an implementation-defined _pointer interpolation state dynamic array_ each element of which contains the following data:

- The resolved JSON Pointer to the Object Model property being interpolated
- Implementation-defined high precision timestamp value representing the interpolation start time
- Interpolation duration value converted to the implementation-defined high precision time type
- Object Model property value at the time of the successful node activation
- Information needed for cubic Bézier spline evaluation derived from the node's input values
- Target property value
- Implementation-specific pointer to the `done` output flow of the node that has added this entry

This array is initially empty and its maximum size is implementation-specific.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate all input values.
2. If the pointer or the pointer template with all its substitutions applied cannot be resolved,
.. activate the `err` output flow and skip the next steps.
3. If the `duration` input value is NaN, infinite, negative, or not convertible into an implementation-specific time type used for the internal interpolation start time value,
.. activate the `err` output flow and skip the next steps.
4. If any component of the `p1` or `p2` input values is NaN or infinite or if any of the first components of these input values is negative or greater than 1,
.. activate the `err` output flow and skip the next steps.
5. If starting a new pointer interpolation exceeds any implementation-specific limit,
.. activate the `err` output flow and skip the next steps.
6. If the _pointer interpolation state dynamic array_ contains an entry with the same resolved JSON Pointer value,
.. remove it from the array.
7. Using the implicitly-defined end points stem:[P_0 (0, 0)] and stem:[P_3 (1, 1)] together with the control points stem:[P_1] and stem:[P_2] provided via the input values construct a cubic Bézier easing function for the stem:[[0, 1]] input range.
8. Add a new entry to the _pointer interpolation state dynamic array_ filling it with the required information based on the evaluated input values.
9. Activate the `out` output flow.

On each asset animation update, for each entry in the _pointer interpolation state dynamic array_:

1. Compute the current input progress position _t_ as the time passed since the interpolation start divided by the interpolation's duration.
2. If _t_ is less than or equal to zero
.. skip the next steps.
3. If _t_ is NaN or greater than or equal to 1,
.. set the Object Model property to the target value;
.. remove the current entry from the _pointer interpolation state dynamic array_;
.. activate the `done` output flow linked to the current entry
.. skip the next steps.
4. Using the cubic Bézier spline information, compute the output progress position _q_ based on the _t_ value. This step implies that latexmath:[t \in [0; 1\]].
5. Set the linked Object Model property to the new value computed as a linear interpolation between the original and the target property values using the output progress position _q_ as the interpolation coefficient.

If the Object Model property is a quaternion, spherical linear interpolation expression **SHOULD** be used.

Intermediate output progress values **MAY** be less than zero or greater than one.
