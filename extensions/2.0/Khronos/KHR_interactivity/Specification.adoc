// Copyright 2024 The Khronos Group Inc.
//
// SPDX-License-Identifier: CC-BY-4.0

// :regtitle: is explained in
// https://discuss.asciidoctor.org/How-to-add-markup-to-author-information-in-document-title-td6488.html
= glTF{tmtitle} 2.0 Interactivity Extension Specification
:tmtitle: pass:q,r[^™^]
:regtitle: pass:q,r[^®^]
The Khronos{regtitle} 3D Formats Working Group
:data-uri:
:icons: font
:toc2:
:toclevels: 10
:sectnumlevels: 10
:max-width: 100%
:numbered:
:source-highlighter: coderay
:title-logo-image: image:../figures/glTF_RGB_June16.svg[Logo,pdfwidth=4in,align=right]
:docinfo: shared-head
:docinfodir: ../../../../specification/2.0
:stem:

// This causes cross references to chapters, sections, and tables to be
// rendered as "Section A.B" (for example) rather than rendering the reference
// as the text of the section title.  It also enables cross references to
// [source] blocks as "Listing N", but only if the [source] block has a title.
:xrefstyle: short
:listing-caption: Listing

ifndef::revdate[]
:toc-placement!:

[NOTE]
.Note
====
Khronos posts the AsciiDoc source of the glTF specification to enable community
feedback and remixing under CC-BY 4.0. Published versions of the Specification
are located in the https://www.khronos.org/registry/glTF[glTF Registry].
====
endif::[]

// Table of contents is inserted here
toc::[]

:leveloffset: 1

[[foreword]]
= Foreword

Copyright 2024 The Khronos Group Inc.

This specification is protected by copyright laws and contains material proprietary
to Khronos. Except as described by these terms, it or any components
may not be reproduced, republished, distributed, transmitted, displayed, broadcast,
or otherwise exploited in any manner without the express prior written permission
of Khronos.

This specification has been created under the Khronos Intellectual Property Rights
Policy, which is Attachment A of the Khronos Group Membership Agreement available at
https://www.khronos.org/files/member_agreement.pdf. Khronos grants a conditional
copyright license to use and reproduce the unmodified specification for any purpose,
without fee or royalty, EXCEPT no licenses to any patent, trademark or other
intellectual property rights are granted under these terms. Parties desiring to
implement the specification and make use of Khronos trademarks in relation to that
implementation, and receive reciprocal patent license protection under the Khronos
IP Policy must become Adopters under the process defined by Khronos for this specification;
see https://www.khronos.org/conformance/adopters/file-format-adopter-program.

Some parts of this Specification are non-normative through being explicitly identified as
purely informative, and do not define requirements necessary for compliance and so are
outside the Scope of this Specification.

Where this Specification includes normative references to external documents, only the
specifically identified sections and functionality of those external documents are in
Scope. Requirements defined by external documents not created by Khronos may contain
contributions from non-members of Khronos not covered by the Khronos Intellectual
Property Rights Policy.

Khronos makes no, and expressly disclaims any, representations or warranties,
express or implied, regarding this specification, including, without limitation:
merchantability, fitness for a particular purpose, non-infringement of any
intellectual property, correctness, accuracy, completeness, timeliness, and
reliability. Under no circumstances will Khronos, or any of its Promoters,
Contributors or Members, or their respective partners, officers, directors,
employees, agents or representatives be liable for any damages, whether direct,
indirect, special or consequential damages for lost revenues, lost profits, or
otherwise, arising from or in connection with these materials.

Khronos® and Vulkan® are registered trademarks, and ANARI™, WebGL™, glTF™, NNEF™, OpenVX™,
SPIR™, SPIR&#8209;V™, SYCL™, OpenVG™ and 3D Commerce™ are trademarks of The Khronos Group Inc.
OpenXR™ is a trademark owned by The Khronos Group Inc. and is registered as a trademark in
China, the European Union, Japan and the United Kingdom. OpenCL™ is a trademark of Apple Inc.
and OpenGL® is a registered trademark and the OpenGL ES™ and OpenGL SC™ logos are trademarks
of Hewlett Packard Enterprise used under license by Khronos. ASTC is a trademark of
ARM Holdings PLC. All other product names, trademarks, and/or company names are used solely
for identification and belong to their respective owners.


[[introduction]]
= Introduction

[[introduction-general]]
== General

This document, referred to as the "`glTF Interactivity Extension Specification`" or just the "`Specification`" hereafter, describes the `KHR_interactivity` glTF extension.

This extension aims to enhance glTF 2.0 by adding the ability to encode behavior and interactivity in 3D assets.

This extension is for single user experiences only and does not deal with any of the complexity involved in multi-user networked experiences.

[[introduction-conventions]]
== Document Conventions

The glTF Interactivity Extension Specification is intended for use by both implementers of the asset exporters or converters (e.g., digital content creation tools) and application developers seeking to import or load interactive glTF assets, forming a basis for interoperability between these parties.

Specification text can address either party; typically, the intended audience can be inferred from context, though some sections are defined to address only one of these parties.

Any requirements, prohibitions, recommendations, or options defined by <<introduction-normative-terminology, normative terminology>> are imposed only on the audience of that text.

[[introduction-normative-terminology]]
=== Normative Terminology and References

The key words **MUST**, **MUST NOT**, **REQUIRED**, **SHALL**, **SHALL NOT**, **SHOULD**, **SHOULD NOT**, **RECOMMENDED**,  **MAY**, and **OPTIONAL** in this document are to be interpreted as described in <<bcp14,BCP 14>>.

These key words are highlighted in the specification for clarity.

References to external documents are considered normative if the Specification uses any of the normative terms defined in this section to refer to them or their requirements, either as a whole or in part.

[[introduction-informative-language]]
=== Informative Language

Some language in the specification is purely informative, intended to give background or suggestions to implementers or developers.

If an entire chapter or section contains only informative language, its title is suffixed with "`(Informative)`". If not designated as informative, all chapters, sections, and appendices in this document are normative.

All Notes, Implementation notes, and Examples are purely informative.

[[introduction-technical-terminology]]
=== Technical Terminology

TBD

[[introduction-normative-references]]
=== Normative References

The following documents are referenced by normative sections of the specification:

==== External Specifications

[none]
* [[bcp14]]
Bradner, S., _Key words for use in RFCs to Indicate Requirement Levels_, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997. Leiba, B., _Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words_, BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.
<https://www.rfc-editor.org/info/bcp14>

* [[rfc6901]]
Bryan, P., Ed., Zyp, K., and M. Nottingham, Ed., _JavaScript Object Notation (JSON) Pointer_, RFC 6901, DOI 10.17487/RFC6901, April 2013,
<https://www.rfc-editor.org/info/rfc6901>

* [[ieee-754]]
ISO/IEC 60559
_Floating-point arithmetic_
<https://www.iso.org/standard/80985.html>
+
[TIP]
====
Also known as IEEE 754-2019, https://standards.ieee.org/ieee/754/6210/
====

* [[ecma-262]]
ECMA-262
_ECMAScript® Language Specification_
<https://www.ecma-international.org/publications-and-standards/standards/ecma-262/>

[[motivation]]
== Motivation and Design Goals (Informative)

glTF 2.0 assets are widely used in various industries, including automotive, e-commerce, and gaming. There is a growing demand for adding logic and behavior to glTF assets, particularly in the metaverse. This extension aims to fulfill this demand by providing a portable, easily implementable, safe, and visually accessible solution for adding behavior to glTF assets. The extension is inspired by visual scripting features of leading game engines and aims to deliver a minimum meaningful and extensible feature set.

=== What Is a Behavior Graph?
A behavior graph is a series of interconnected nodes that represent behaviors and interactions in a 3D asset. It can respond to events and cause changes in the asset's appearance and behavior.

=== What Problems Can They Solve?
Behavior graphs offer a flexible and multi-functional approach to encoding behavior, making them useful for various applications. For instance, they can be used to create smart assets with behavior and interactions, AR experiences with user interactions, and immersive game levels with dynamic assets and objectives.

=== What Do They Not Solve?
Behavior graphs are not designed to handle UI presentation or arbitrary scripting. Creating a 3D UI using behavior graphs would be complex, not portable, and not accessible. Similarly, arbitrary scripting is challenging to make safe, portable across platforms, and has a vast surface area.

=== Comparison with Trigger-Action Lists
Behavior graphs and trigger-action lists are the two common models for representing and executing behaviors in the digital world. Common 3D experience commerce tools use trigger-action lists, while behavior graphs are typically used by high-end game engines. In this section, we will explore the differences and similarities between these two models, and explain why glTF chose to adopt behavior graphs.

Behavior graphs and trigger-action lists share common features, such as being safe and sandboxed, offering limited execution models controlled by the viewer, and both supporting the “trigger” and “action” node categories. However, there are also significant differences between the two models. Trigger-action lists lack “Queries”, “Logic”, and “Control Flow” nodes, meaning that sophisticated behavior based on queries, logic, or control flow branches is not possible. This lack of functionality greatly affects the ability to create complex behavior and control structures and rules out the implementation of advanced control flow structures in the future.

On the other hand, behavior graphs are a superset of trigger-action lists, meaning that the former can support everything that trigger-action lists can, and more. Behavior graphs support “Queries”, “Logic” and “Control Flow” nodes, making them more expressive and capable of creating more sophisticated behaviors. This makes behavior graphs the preferred method of choice for high-end game engines, as it offers an identical safety model as trigger-action lists while being more expressive.

=== Turing Completeness
The execution model and operation choices for this extension mean that it is Turing-complete. This means that an implementation of this can execute any computation and it is not always possible to predict if it will run forever, e.g., halt or not.

While this may present security implications, it is not a major hindrance and can be safely mitigated so that any implementation does not become susceptible to denial of services by badly behaving behavior graphs, whether intentional or not.

The main way to mitigate the risk of non-halting behavior graphs is to limit the amount of time given to them for execution, both in terms of individual time slice as well as overall execution time.


[[concepts]]
= Concepts

[[concepts-general]]
== Graphs

A behavior graph is a JSON object containing _nodes_. It **MAY** also contain custom variables and custom events.

Behavior graphs are directed graphs with no directed cycles.

When a glTF asset contains a behavior graph, all glTF animations are assumed to be controlled by the graph so they **MUST NOT** play automatically.

[[nodes]]
== Nodes

A _node_ is a JSON object, which represents an executable item. Each node is defined by its _declaration_, which includes an _operation_ and a (possibly empty) set of _value sockets_. Node operations follow `domain/operation` naming pattern. Depending on the operation, a node **MAY** have input and/or output _flow sockets_; they **MAY** be affected by the node's _configuration_.

[[nodes-operation]]
=== Operation

A node's _operation_ defines a specific set of steps performed by the execution environment when the node is executed.

A node is executed when one of its input flow sockets is activated, when one of its output value sockets is accessed by another node, when an operation-specific event occurs. A node **MAY** repeatedly activate its own input flow sockets during the execution.

Usually, the node execution includes evaluating its input value sockets (if any), processing its own logic, and activating any number (including zero) of output flow sockets.

[[nodes-sockets]]
=== Sockets

There are four kinds of sockets.

_Output value sockets_ represent data initialized by the node or produced during its execution. For example, it could be results of math operations or parts of the node's internal state. Accessing these sockets either triggers computing the return value on the fly by executing the node or returns a value based on the node's internal state. Exact behavior depends on the node's operation. As a general rule, output value sockets **MUST** retain their values until a node with one or more flow sockets is executed.

[NOTE]
.Implementation Note
====
At the current state of the Specification, the retention of output value socket values is observable only with the `math/random` node.
====

_Input value sockets_ represent data accessed during the node's execution. For example, it could be arguments of math operations or execution parameters such as iteration count for loop nodes or duration for time-related nodes. Each of these sockets **MUST** either be given an inline constant value in the node object or connected to an output value socket of a different node. The node **MAY** access its input value sockets multiple times during the execution. The runtime **MUST** guarantee that all input value sockets have defined values when the node execution starts.

_Output flow sockets_ represent "`function pointers`" that the node will call to advance the graph execution. For example, bodies and branches of flow control nodes are output flow sockets that drive further execution when certain condition are fulfilled. An output flow socket is either connected to exactly one input flow socket of another node or unconnected; in the latter case activating the output flow socket is a no-op.

_Input flow sockets_ represent "`methods`" that could be called on the node. For example, flow control nodes (such as loops and branches) usually have an `in` input flow socket that starts node's execution. Additional input flow sockets **MAY** exist such as `reset` for nodes having an internal state. An input flow socket is either connected to one or more output flow sockets of other nodes or unconnected; in the latter case the node's "`method`" represented by the socket is never called.

Input and output value sockets have associated data types, e.g., floats, integers, booleans, etc.

Socket ids exist in four separate scopes corresponding to the four socket kinds.

[NOTE]
.Example
====
For example, a `flow/sequence` node can have an output flow socket with id `"in"` despite having an input flow socket with the same id.
====

[[socket-order]]
==== Socket Order

Although sockets are inherently unordered within a node (because JSON properties are unordered), some operations such as `flow/sequence` or `flow/multiGate` need a specific socket order to guarantee predictable behavior. In such cases, the sockets are implicitly sorted by their ids in ascending order.

For any given ids `a` and `b`, the following procedure **MUST** be used to determine if `a` is less than `b`.

1. Let _unitsA_ and _unitsB_ be the sequences of UTF-16 code units corresponding to the socket ids `a` and `b` respectively and _lengthA_ and _lengthB_ be the lengths of these sequences.
2. Let _minLength_ be the minimum of _lengthA_ and _lengthB_.
3. For each integer _i_ such that 0 ≤ _i_ < _minLength_, in ascending order, do
.. if _unitsA[i]_ < _unitsB[i]_ return true;
.. if _unitsA[i]_ > _unitsB[i]_ return false.
4. If _lengthA_ < _lengthB_ return true.
5. Return false.

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript as follows, assuming that `flows` is a JSON object representing output flow sockets:
[source,js]
----
const sortedSocketIds = Object.keys(flows).sort();
----
====

[CAUTION]
====
This process enforces lexicographic order solely based on UTF-16 code units. In particular, the following two caveats apply:

- A socket id `10` is _less_ than a socket id `9`. This could be avoided by padding socket ids to the same number of characters, i.e., using `09` instead of `9` in this case.

- The sorting algorithm does not account for characters that use more than one code unit in UTF-16 encoding. For example, the "`North East Sans-Serif Arrow`" character has a code point of `0x1F855` encoded as two surrogate code units `[0xD83E, 0xDC55]` so it is _less_ than the "`Replacement Character`" character that has a code point of `0xFFFD` encoded directly as a single code unit.
====

[[socket-types]]
==== Value Socket Types

All value sockets are strictly typed.

Implementations of this extension **MUST** support the following type signatures.

bool::
a boolean value

float::
a double precision <<ieee-754,IEEE-754>> floating-point scalar value

float2::
a two-component vector of *float* values

float3::
a three-component vector of *float* values

float4::
a four-component vector of *float* values

float2x2::
a 2x2 matrix of *float* values

float3x3::
a 3x3 matrix of *float* values

float4x4::
a 4x4 matrix of *float* values

int::
a two's complement 32-bit signed integer scalar value

[[nodes-configuration]]
=== Configuration

Nodes **MAY** be configurable through inline properties collectively called _configuration_ that **MAY** affect the node's behavior and the number of its sockets, such as the set of cases for the `flow/switch` node.

If a node specification does not include any configuration, the node is not configurable and any configuration properties defined for it in the behavior graph **MUST** be ignored.

Unless specified otherwise, all nodes that include configuration have a _default_ configuration. The default configuration **MUST** be used when the behavior graph does not provide any configuration or when the provided configuration is invalid. If a node does not have a default configuration (like `variable/*` nodes) and the behavior graph does not provide a valid configuration, the whole graph is invalid and **MUST** be rejected.

For a configuration to be valid, all configuration properties defined by the node specification **MUST** be provided in the behavior graph with valid types and values. If any of the configuration properties defined by the node specification is omitted or has invalid type or invalid value, the whole configuration is invalid and the node behavior **MUST** fall back to the default configuration if the latter is supported. Configuration properties present in the behavior graph but not defined by the node specification **MUST** be ignored.

Implementations **SHOULD** generate appropriate warnings as deemed possible when:

* a non-configurable node has a configuration in the behavior graph;
* a provided configuration contains unknown properties;
* a provided configuration is invalid.

[[nodes-configuration-types]]
==== Configuration Types

Configuration properties use a separate type system unrelated to the value socket types.

bool::
a boolean value

int::
a two's complement 32-bit signed integer scalar value

int[]::
an array of *int* values

string::
a string value

[[nodes-noop]]
=== Unsupported Operations

If the execution environment does not support the operation, e.g., when the operation is defined by an unsupported or disabled extension for the Interactivity Specification, the operation is implicitly replaced with a "`no-op`" operation defined as follows:

- activating the node's input flow sockets is ignored;
- the node's output flow sockets are never activated;
- the node's output value sockets have constant <<variables-types,type-default>> values.

[[events]]
== Custom Events

A behavior graph **MAY** define custom events for interacting with external execution environments and/or creating asynchronous loops.

A custom event definition includes its value sockets with types and optional initial values as well as an optional unique string identifier for linking the event with the external environment.

Semantics of custom events are application-specific.

[[variables]]
== Custom Variables

A behavior graph **MAY** define custom variables. A variable **MAY** be declared simultaneously with its initial value, otherwise the variable **MUST** be initialized to the type-specific default.

Custom variables **MUST** retain their values until the graph execution is terminated.

[[variables-types]]
=== Custom Variable Types

Custom variables use the same type system as the value sockets. The following table defines type-default values.

[cols="1,2", options="header"]
|===
|  Type      | Default value
| `bool`     | Boolean false
| `float`    | Floating-point NaN
| `float2`   | Two floating-point NaNs
| `float3`   | Three floating-point NaNs
| `float4`   | Four floating-point NaNs
| `float2x2` | Four floating-point NaNs
| `float3x3` | Nine floating-point NaNs
| `float4x4` | Sixteen floating-point NaNs
| `int`      | Integer zero
|===

[[limits]]
== Implementation-Specific Limits

=== Static Limits

Implementations **MAY** restrict the size and complexity of behavior graphs by imposing certain limits on the following statically-known properties:

* The number of types
* The number of variables
* The number of custom events and the number of value sockets within a custom event
* The number of operation declarations
* The number of input and output value sockets in operation declarations
* The number of nodes
* The number of graph-defined output flow sockets in operations like `flow/multiGate` or `flow/sequence`
* The number of configuration-defined output flow sockets in operations like `flow/switch`
* The number of configuration-defined input value sockets in operations like `pointer/get`, `math/switch`, or `variable/set`

The graph **MUST** be rejected if it exceeds implementation-defined max values for these properties.

=== Dynamic Limits

Implementations **MAY** restrict the runtime capabilities of behavior graphs by imposing certain limits on the following features that require dynamic allocation of memory and/or processing power:

* Numbers of simultaneous delays, animations, and interpolations; exceeding these limits results in runtime errors that can be gracefully handled by the graph itself, see `err` output flows of the corresponding nodes.

* Number of events processed within a single rendered frame; exceeding this limit **MAY** result in an implementation-specific behavior such as reducing the frame rate or rescheduling the extra events.

These limits are exposed to behavior graphs via additional glTF Object Model pointers.

= Functional Specification

== Nodes

=== Math Nodes

Starting from this section, `floatN` is a placeholder for `float`, `float2`, `float3`, and `float4` types; `floatNxN` is a placeholder for `float2x2`, `float3x3`, and `float4x4` types.

All value sockets of `floatN` or `floatNxN` types have the same type within a node.

==== Constants

===== E

[cols="1h,1,2"]
|===
| Operation | `math/E` | Euler's number
| Output value sockets | `float value` | 2.718281828459045
|===

===== Pi

[cols="1h,1,2"]
|===
| Operation | `math/Pi` | Ratio of a circle's circumference to its diameter
| Output value sockets | `float value` | 3.141592653589793
|===

===== Infinity

[cols="1h,1,2"]
|===
| Operation | `math/Inf` | Positive infinity
| Output value sockets | `float value` | _Infinity_
|===

[TIP]
.Authoring Tip
====
To get negative infinity, combine this node with `math/neg`.
====

===== Not a Number

[cols="1h,1,2"]
|===
| Operation | `math/NaN` | Not a Number
| Output value sockets | `float value` | _NaN_
|===

==== Arithmetic Nodes

These all operate component-wise. The description is per component.

If any input value component is _NaN_, the corresponding output value component is also _NaN_.

===== Absolute Value

[cols="1h,1,2"]
|===
| Operation | `math/abs` | Absolute value operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | latexmath:[\begin{cases}
                                  -a & \text{if } a \lt 0 \\
                                  +0 & \text{if } a = \pm0 \\
                                   a & \text{if } a \gt 0
                                \end{cases}]
|===

===== Sign

[cols="1h,1,2"]
|===
| Operation | `math/sign` | Sign operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | latexmath:[\begin{cases}
                                  -1 & \text{if } a \lt 0 \\
                                   a & \text{if } a = \pm0 \\
                                  +1 & \text{if } a \gt 0
                                \end{cases}]
|===

===== Truncate

[cols="1h,1,2"]
|===
| Operation | `math/trunc` | Truncate operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | Integer value equal to the nearest integer to stem:[a] whose absolute value is not larger than the absolute value of stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Floor

[cols="1h,1,2"]
|===
| Operation | `math/floor` | Floor operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | stem:[floor(a)], value equal to the nearest integer that is less than or equal to stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Ceil

[cols="1h,1,2"]
|===
| Operation | `math/ceil` | Ceil operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | stem:[ceil(a)], value equal to the nearest integer that is greater than or equal to stem:[a]
|===

If the argument is infinity, it is returned unchanged.

===== Round

[cols="1h,1,2"]
|===
| Operation | `math/round` | Round operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | Value equal to the integer nearest to stem:[a]
|===

Half-way cases **MUST** be rounded away from zero. Negative values greater than `-0.5` **MUST** be rounded to negative zero.

If the argument is infinity, it is returned unchanged.

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
a < 0 ? -Math.round(-a) : Math.round(a)
----
====

===== Fraction

[cols="1h,1,2"]
|===
| Operation | `math/fract` | Fractional operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | stem:[a - floor(a)]
|===

===== Negation

[cols="1h,1,2"]
|===
| Operation | `math/neg` | Negation operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | stem:[-a]
|===

===== Addition

[cols="1h,1,2"]
|===
| Operation | `math/add` | Addition operation
.2+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | First addend
d| `floatN b` or +
   `floatNxN b` | Second addend
| Output value sockets
| `floatN value` or +
  `floatNxN value` | Sum, stem:[a + b]
|===

===== Subtraction

[cols="1h,1,2"]
|===
| Operation | `math/sub` | Subtraction operation
.2+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | Minuend
d| `floatN b` or +
   `floatNxN b` | Subtrahend
| Output value sockets
| `floatN value` or +
  `floatNxN value` | Difference, stem:[a - b]
|===

===== Multiplication

[cols="1h,1,2"]
|===
| Operation | `math/mul` | Multiplication operation
.2+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | First factor
d| `floatN b` or +
   `floatNxN b` | Second factor
| Output value sockets
| `floatN value` or +
  `floatNxN value` | Product, stem:[a * b]
|===

For matrix arguments, this operation performs per-element multiplication.

[NOTE]
.Authoring Note
====
See `math/matMul` for matrix multiplication.
====

===== Division

[cols="1h,1,2"]
|===
| Operation | `math/div` | Division operation
.2+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | Dividend
d| `floatN b` or +
   `floatNxN b` | Divisor
| Output value sockets
| `floatN value` or +
  `floatNxN value` | Quotient, stem:[a / b]
|===

===== Remainder

[cols="1h,1,2"]
|===
| Operation | `math/rem` | Remainder operation
.2+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | Dividend
d| `floatN b` or +
   `floatNxN b` | Divisor
| Output value sockets
| `floatN value` or +
  `floatNxN value` | latexmath:[\begin{cases}
                                  \mathit{NaN} & \text{if } a = \pm \infty \text{ or } b = \pm 0 \\
                                  a & \text{if } a \ne \pm \infty \text{ and } b = \pm \infty \\
                                  a - (b \cdot \operatorname{trunc}(\frac{a}{b})) & \text{otherwise}
                                \end{cases}]
|===

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
a % b
----
====

===== Minimum

[cols="1h,1,2"]
|===
| Operation | `math/min` | Minimum operation
.2+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | First argument
d| `floatN b` or +
   `floatNxN b` | Second argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | Smallest of the arguments
|===

For the purposes of this node, negative zero is less than positive zero.

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.min(a, b)
----
====

===== Maximum

[cols="1h,1,2"]
|===
| Operation | `math/max` | Maximum operation
.2+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | First argument
d| `floatN b` or +
   `floatNxN b` | Second argument
| Output value sockets
| `floatN value` or +
  `floatNxN value` | Largest of the arguments
|===

For the purposes of this node, negative zero is less than positive zero.

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.max(a, b)
----
====

===== Clamp

[cols="1h,1,2"]
|===
| Operation | `math/clamp` | Clamp operation
.3+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | Value to clamp
d| `floatN b` or +
   `floatNxN b` | First boundary
d| `floatN c` or +
   `floatNxN c` | Second boundary
| Output value sockets
| `floatN value` or +
  `floatNxN value` | latexmath:[\min(\max(a, \min(b, c)), \max(b, c))]
|===

This node is defined in terms of `math/min` and `math/max` nodes defined above.

[NOTE]
.Authoring Note
====
This operation correctly handles a case when stem:[b] is greater than stem:[c].
====

===== Saturate

[cols="1h,1,2"]
|===
| Operation | `math/saturate` | Saturate operation
| Input value sockets
| `floatN a` or +
  `floatNxN a` | Value to saturate
| Output value sockets
| `floatN value` or +
  `floatNxN value` | latexmath:[\min(\max(a, 0), 1)]
|===

This node is defined in terms of `math/min` and `math/max` nodes defined above.

===== Interpolate

[cols="1h,1,2"]
|===
| Operation | `math/mix` | Linear interpolation operation
.3+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | Interpolated value at stem:[0]
d| `floatN b` or +
   `floatNxN b` | Interpolated value at stem:[1]
d| `floatN c` or +
   `floatNxN c` | Unclamped interpolation coefficient
| Output value sockets
| `floatN value` or +
  `floatNxN value` | stem:[(1 - c) * a + c * b]
|===

==== Comparison Nodes

If any input value is _NaN_, the output value is false.

For the purposes of these nodes, negative zero is equal to positive zero.

===== Equality

[cols="1h,1,2"]
|===
| Operation | `math/eq` | Equality operation
.2+| Input value sockets
d| `floatN a` or +
   `floatNxN a` | First argument
d| `floatN b` or +
   `floatNxN b` | Second argument
| Output value sockets
| `bool value` | True if the input arguments are equal, per-component; false otherwise
|===

===== Less Than

[cols="1h,1,2"]
|===
| Operation | `math/lt` | Less than operation
.2+| Input value sockets
d| `float a` | First argument
d| `float b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a < b]; false otherwise
|===

===== Less Than Or Equal To

[cols="1h,1,2"]
|===
| Operation | `math/le` | Less than or equal to operation
.2+| Input value sockets
d| `float a` | First argument
d| `float b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a <= b]; false otherwise
|===

===== Greater Than

[cols="1h,1,2"]
|===
| Operation | `math/gt` | Greater than operation
.2+| Input value sockets
d| `float a` | First argument
d| `float b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a > b]; false otherwise
|===

===== Greater Than Or Equal To

[cols="1h,1,2"]
|===
| Operation | `math/ge` | Greater than or equal operation
.2+| Input value sockets
d| `float a` | First argument
d| `float b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a >= b]; false otherwise
|===

==== Special Nodes

===== Is Not a Number

[cols="1h,1,2"]
|===
| Operation | `math/isNaN` | Not a Number check operation
| Input value sockets
| `float a` | Argument
| Output value sockets
| `bool value` | True if stem:[a] is _NaN_; false otherwise
|===

===== Is Infinity

[cols="1h,1,2"]
|===
| Operation | `math/isInf` | Infinity check operation
| Input value sockets
| `float a` | Argument
| Output value sockets
| `bool value` | True if stem:[a] is positive or negative infinity; false otherwise
|===

[TIP]
.Authoring Tip
====
To check whether a value is only a positive infinity, combine `math/eq` and `math/Inf` nodes.

To check whether a value is only a negative infinity, combine `math/eq`, `math/neg`, and `math/Inf` nodes.
====

===== Select

[cols="1h,1,2"]
|===
| Operation | `math/select` | Conditional selection operation
.3+| Input value sockets
d| `bool condition` | Value selecting the value returned
d| `T a` | Positive selection option
d| `T b` | Negative selection option
| Output value sockets
| `T value` | stem:[a] if the `condition` input value is true; stem:[b] otherwise
|===

The type `T` represents any supported type including custom types. It **MUST** be the same for the output value socket and the input value sockets stem:[a] and stem:[b].

===== Switch

[cols="1h,1,2"]
|===
| Operation | `math/switch` | Conditionally output one of the input values
| Configuration
| `int[] cases` | The cases on which to perform the switch; empty in the default configuration
.3+| Input value sockets
d| `int selection` | The value on which the switch operates
d| `T <case>`  | Zero or more input value sockets; `<case>` is an integer decimal number
d| `T default` | The value used when the `selection` input value is not present in the `cases` configuration array
| Output value sockets
| `T value` | The value taken from the selected input value socket
|===

[CAUTION]
====
The configuration of this node affects its value sockets.
====

The node has zero or more `<case>` input value sockets corresponding to the elements of the `cases` configuration array.

The type `T` represents any supported type including custom types. The type of the `value` output value socket is the same as the type of the `default` input value socket.

In the default configuration, the `cases` configuration array is empty and the node has only the `default` and `selection` input value sockets.

The following procedure defines input value sockets generation from the provided configuration:

1. If the `cases` configuration property is not present or if it is not an array, ignore it and use the default configuration.
2. If the `cases` configuration property is present and it is an array, then for each array element `C`:
.. if `C` is not a literal number or if it is not exactly representable as a 32-bit signed integer, ignore the `cases` property and use the default configuration;
+
[TIP]
.Implementation Tip
====
The integer representation check is implementable in ECMAScript via the following expression:
[source,js]
----
C === (C | 0)
----
====
.. convert `C` to a base-10 string representation `S` containing only decimal integers (ASCII characters `0x30 ... 0x39`) and a leading minus sign (ASCII character `0x2D`) if `C` is negative; extra leading zeros **MUST NOT** be present;
.. add a value socket `S` to the set of the input value sockets of this node or ignore it if an input value socket with the same id has been already added.
3. If the number of generated value sockets plus two exceeds an implementation-defined limit on the maximum number of input value sockets, the graph **MUST** be rejected.
4. Proceed with the generated input value sockets.

[NOTE]
.Examples
====
* If the `cases` configuration array is `[0.5, 1]`, the default configuration is used because `0.5` is not representable as a 32-bit signed integer.
* If the `cases` configuration array is `[-2147483649, 0]`, the default configuration is used because `-2147483649` is not representable as a 32-bit signed integer.
* If the `cases` configuration array is `[-1.0, 0, 1]`, the output socket ids are exactly `"-1"`, `"0"`, and `"1"` because `-1.0` is equal to an integer `-1`.
* If the `cases` configuration array is `[0.1e1, 2, 2]`, the output socket ids are exactly `"1"` and `"2"` because `0.1e1` is equal to an integer `1` and the duplicate entry is ignored.
====

If the nodes's JSON object does not contain all input value sockets generated by the procedure above with the same type as the `default` input value socket, the node is invalid and the graph **MUST** be rejected.

[NOTE]
.Validation Examples
====
* If the node does not have `selection` or `default` input value sockets, then the node is invalid.
* If the node has a `selection` input value socket with any type other than integer, then the node is invalid.
* If the default configuration is used and the node has an integer `selection` input value socket and a `default` input value socket of any type, then the node is valid.
* If the `cases` configuration array is `[1, 2]` and the node does not have input value sockets with ids `1` and `2`, then the node is invalid.
* If the `cases` configuration array is `[1, 2]` and the node has an input value socket with id `1` and the same type as the type of the `default` input value socket and an input value socket with id `2` and any other type, then the node is invalid.
====

Extra input value sockets with ids not present in the output of the procedure above do not affect the node's operation and validation but they still **MUST** have valid types and value sources.

[NOTE]
.Validation Examples
====
* If the default configuration is used and the node has an integer `selection` input value socket, a `default` input value socket of any type, and any other input value socket of any type, then the node is valid.
* If the `cases` configuration array is `[1]` and the node has an integer `selection` input value socket, a `default` input value socket of any type, an input value socket with id `1` and the same type as the type of the `default` input value socket, and any other input value socket of any type, then the node is valid.
====

This node has no internal state.

The `value` output value is computed as follows:

1. Evaluate all input value sockets.
2. If the `cases` configuration array does not contain the `selection` input value:
.. set the `value` output value to the value of the `default` input value socket.
3. If the `cases` configuration array contains the `selection` input value:
.. set the `value` output value to the value of the input value socket with id equal to the decimal string representation of the `selection` input value.

[NOTE]
.Operation Examples
====
* If the default configuration is used, the `value` output value is always the same as the `default` input value.
* If the `cases` configuration array is `[1]` and the `selection` input value is `1`, the `value` output value is the value of the input value socket with id `1`.
* If the `cases` configuration array is `[1]` and the `selection` input value is `2`, the `value` output value is the value of the `default` input value socket even if the the node's JSON has an input value socket with id `2`.
====

===== Random

[cols="1h,1,2"]
|===
| Operation | `math/random` | Random value generation operation
| Output value sockets | `float value` | A pseudo-random number greater than or equal to zero and less than one
|===

[WARNING]
====
This node is not intended for any workflows that require cryptographically secure random numbers.
====

The value of the output value socket `value` **MUST** be initialized to a random number on the first access. Any two accesses of the output value socket `value` **MUST** return the same value if there were no flow socket activations (of other nodes) between them.

[NOTE]
.Example
====
This means that, e.g., a `math/eq` node with both its input value sockets connected to the same `math/random` node always returns true.
====

The value of the output value socket `value` **MUST** be updated when accessed as a result of a new flow socket activation, including self-activations.

[NOTE]
.Implementation Note
====
At the current state of the Specification, only `flow/while` and `flow/for` nodes use self-activation of their input flow sockets.
====

==== Angle and Trigonometry Nodes

Node parameters specified as angle are assumed to be in units of radians.

These all operate component-wise. The description is per component.

If any input value component is _NaN_, the corresponding output value component is also _NaN_.

===== Degrees-To-Radians

[cols="1h,1,2"]
|===
| Operation | `math/rad` | Converts degrees to radians
| Input value sockets
| `floatN a` | Value in degrees
| Output value sockets
| `floatN value` | stem:[a * pi / 180]
|===

===== Radians-To-Degrees

[cols="1h,1,2"]
|===
| Operation | `math/deg` | Converts radians to degrees
| Input value sockets
| `floatN a` | Value in radians
| Output value sockets
| `floatN value` | stem:[a * 180 / pi]
|===

===== Sine

[cols="1h,1,2"]
|===
| Operation | `math/sin` | Sine function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \pm0 & \text{if } a = \pm0 \\
                                \mathit{NaN} & \text{if } a = \pm\infty \\
                                \sin(a) & \text{otherwise}
                              \end{cases}]
|===

===== Cosine

[cols="1h,1,2"]
|===
| Operation | `math/cos` | Cosine function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                +1 & \text{if } a = \pm0 \\
                                \mathit{NaN} & \text{if } a = \pm\infty \\
                                \cos(a) & \text{otherwise}
                              \end{cases}]
|===

===== Tangent

[cols="1h,1,2"]
|===
| Operation | `math/tan` | Tangent function
| Input value sockets
| `floatN a` | Angle
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \pm0 & \text{if } a = \pm0 \\
                                \mathit{NaN} & \text{if } a = \pm\infty \\
                                \tan(a) & \text{otherwise}
                              \end{cases}]
|===

[NOTE]
.Authoring Note
====
Since stem:[a] cannot exactly represent latexmath:[\pm\frac{\pi}{2}], this function does not return infinity.
The closest representable argument values would likely produce latexmath:[\pm16331239353195370].
====

===== Arcsine

[cols="1h,1,2"]
|===
| Operation | `math/asin` | Arcsine function
| Input value sockets
| `floatN a` | Sine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \pm0 & \text{if } a = \pm0 \\
                                \mathit{NaN} & \text{if } \|a\| \gt 1 \\
                                \arcsin(a) \in [-\frac{\pi}{2}; \frac{\pi}{2}\] & \text{otherwise}
                              \end{cases}]
|===

===== Arccosine

[cols="1h,1,2"]
|===
| Operation | `math/acos` | Arccosine function
| Input value sockets
| `floatN a` | Cosine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                +0 & \text{if } a = 1 \\
                                \mathit{NaN} & \text{if } \|a\| \gt 1 \\
                                \arccos(a) \in [0; \pi\] & \text{otherwise}
                              \end{cases}]
|===

===== Arctangent

[cols="1h,1,2"]
|===
| Operation | `math/atan` | Arctangent function
| Input value sockets
| `floatN a` | Tangent value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \pm0 & \text{if } a = \pm0 \\
                                \pm\frac{\pi}{2} & \text{if } a = \pm\infty \\
                                \arctan(a) \in [-\frac{\pi}{2}; \frac{\pi}{2}\] & \text{otherwise}
                              \end{cases}]
|===

[NOTE]
.Authoring Note
====
When stem:[a] is infinite, the returned value is an implementation-specific approximation of latexmath:[\pm\frac{\pi}{2}].
====

===== Arctangent 2

[cols="1h,1,2"]
|===
| Operation | `math/atan2` | Arctangent 2 function
.2+| Input value sockets
d| `floatN a` | Y coordinate
d| `floatN b` | X coordinate
| Output value sockets
| `floatN value` | Angle between the positive X-axis and the vector from the stem:[(0, 0)] origin to the stem:[(X, Y)] point on a 2D plane; see the description for details
|===

This function is defined as the **atan2** operation from the <<ieee-754,IEEE-754>> standard including return values for all special cases.

[NOTE]
.Implementation Note
====
This definition also matches the <<ecma-262,ECMA-262>> standard so the node is implementable in ECMAScript via the following expression:
[source,js]
----
Math.atan2(a, b)
----
====

==== Hyperbolic Nodes

These all operate component-wise. The description is per component.

If any input value component is _NaN_, the corresponding output value component is also _NaN_.

===== Hyperbolic Sine

[cols="1h,1,2"]
|===
| Operation |`math/sinh`| Hyperbolic sine function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \pm0 & \text{if } a = \pm0 \\
                                \pm\infty & \text{if } a = \pm\infty \\
                                \sinh(a) & \text{otherwise}
                              \end{cases}]
|===

===== Hyperbolic Cosine

[cols="1h,1,2"]
|===
| Operation |`math/cosh`| Hyperbolic cosine function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                +1 & \text{if } a = \pm0 \\
                                +\infty & \text{if } a = \pm\infty \\
                                \cosh(a) & \text{otherwise}
                              \end{cases}]
|===

===== Hyperbolic Tangent

[cols="1h,1,2"]
|===
| Operation |`math/tanh`| Hyperbolic tangent function
| Input value sockets
| `floatN a` | Hyperbolic angle value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \pm0 & \text{if } a = \pm0 \\
                                \pm1 & \text{if } a = \pm\infty \\
                                \tanh(a) & \text{otherwise}
                              \end{cases}]
|===

===== Inverse Hyperbolic Sine

[cols="1h,1,2"]
|===
| Operation |`math/asinh`| Inverse hyperbolic sine function
| Input value sockets
| `floatN a` | Hyperbolic sine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \pm0 & \text{if } a = \pm0 \\
                                \pm\infty & \text{if } a = \pm\infty \\
                                \operatorname{arsinh}(a) & \text{otherwise}
                              \end{cases}]
|===

===== Inverse Hyperbolic Cosine

[cols="1h,1,2"]
|===
| Operation |`math/acosh`| Inverse hyperbolic cosine function
| Input value sockets
| `floatN a` | Hyperbolic cosine value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \mathit{NaN} & \text{if } a \lt 1 \\
                                +0 & \text{if } a = 1 \\
                                +\infty & \text{if } a = +\infty \\
                                \operatorname{arcosh}(a) & \text{otherwise}
                              \end{cases}]
|===

===== Inverse Hyperbolic Tangent

[cols="1h,1,2"]
|===
| Operation |`math/atanh`| Inverse hyperbolic tangent function
| Input value sockets
| `floatN a` | Hyperbolic tangent value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \mathit{NaN} & \text{if } \|a\| \gt 1 \\
                                \pm\infty & \text{if } a = \pm1 \\
                                \pm0 & \text{if } a = \pm0 \\
                                \operatorname{artanh}(a) & \text{otherwise}
                              \end{cases}]
|===

==== Exponential Nodes

These all operate component-wise. The description is per component.

If any input value component is _NaN_, the corresponding output value component is also _NaN_ for all nodes except `math/pow`.

===== Exponent

[cols="1h,1,2"]
|===
| Operation | `math/exp` | Exponent function
| Input value sockets
| `floatN a` | Power value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                +0 & \text{if } a = -\infty \\
                                +1 & \text{if } a = \pm0 \\
                                +\infty & \text{if } a = +\infty \\
                                e^a & \text{otherwise}
                              \end{cases}]
|===

===== Natural Logarithm

[cols="1h,1,2"]
|===
| Operation | `math/log` | Natural logarithm function
| Input value sockets
| `floatN a` | Argument value
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \mathit{NaN} & \text{if } a \lt 0 \\
                                -\infty & \text{if } a = \pm0 \\
                                +0 & \text{if } a = +1 \\
                                +\infty & \text{if } a = +\infty \\
                                \log_e(a) & \text{otherwise}
                              \end{cases}]
|===

===== Base-2 Logarithm

[cols="1h,1,2"]
|===
| Operation | `math/log2` | Base-2 logarithm function
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \mathit{NaN} & \text{if } a \lt 0 \\
                                -\infty & \text{if } a = \pm0 \\
                                +0 & \text{if } a = +1 \\
                                +\infty & \text{if } a = +\infty \\
                                \log_2(a) & \text{otherwise}
                              \end{cases}]
|===

===== Base-10 Logarithm

[cols="1h,1,2"]
|===
| Operation | `math/log10` | Base-10 logarithm function
| Input value sockets
| `floatN a` | Argument
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \mathit{NaN} & \text{if } a \lt 0 \\
                                -\infty & \text{if } a = \pm0 \\
                                +0 & \text{if } a = +1 \\
                                +\infty & \text{if } a = +\infty \\
                                \log_{10}(a) & \text{otherwise}
                              \end{cases}]
|===

===== Square Root

[cols="1h,1,2"]
|===
| Operation | `math/sqrt` | Square root function
| Input value sockets
| `floatN a` | Radicand
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \mathit{NaN} & \text{if } a \lt 0 \\
                                \pm0 & \text{if } a = \pm0 \\
                                +\infty & \text{if } a = +\infty \\
                                \sqrt[2\]{a} & \text{otherwise}
                              \end{cases}]
|===

===== Cube Root

[cols="1h,1,2"]
|===
| Operation | `math/cbrt` | Cube root function
| Input value sockets
| `floatN a` | Radicand
| Output value sockets
| `floatN value` | latexmath:[\begin{cases}
                                \pm0 & \text{if } a = \pm0 \\
                                \pm\infty & \text{if } a = \pm\infty \\
                                \sqrt[3\]{a} & \text{otherwise}
                              \end{cases}]
|===

===== Power

[cols="1h,1,2"]
|===
| Operation | `math/pow` | Power function
.2+| Input value sockets
d| `floatN a` | Base
d| `floatN b` | Exponent
| Output value sockets
| `floatN value` | stem:[a^b]; see the description for details
|===

This function is defined as the **pow** operation from the <<ieee-754,IEEE-754>> standard with the following changes applied:

- latexmath:[\mathit{NaN} ^ {\pm0} = 1]
- latexmath:[+1 ^ {\pm\infty}], latexmath:[-1 ^ {\pm\infty}], and latexmath:[\pm1 ^ \mathit{NaN}] are latexmath:[\mathit{NaN}]

[NOTE]
.Implementation Note
====
This definition matches the <<ecma-262,ECMA-262>> standard so the node is implementable in ECMAScript via the following expression:
[source,js]
----
a ** b
----
====

==== Vector Nodes

See individual node definitions for handling special floating-point values.

===== Length

[cols="1h,1,2"]
|===
| Operation | `math/length` | Vector length
| Input value sockets
| `floatN a` | Vector
| Output value sockets
| `float value` | Length of stem:[a], e.g., stem:[sqrt(a_x^2 + a_y^2)] for `float2`; see the description for details
|===

If any input value component is positive or negative infinity, the output value is positive infinity.

If none of the input value components are positive or negative infinity and any input value component is NaN, the output value is NaN.

If all input value components are positive or negative zeros, the output value is a positive zero.

If all input value components are finite, the output value is an approximation of the square root of the sum of the input value component squares.

[NOTE]
.Implementation Note
====
This definition matches the **hypot** operation from the <<ieee-754,IEEE-754>> standard including return values for all special cases.
====

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.hypot(...a)
----
====

[TIP]
.Authoring Tip
====
To get the squared length of stem:[a], use `math/dot` with stem:[a] provided to its both input value sockets. Note that this approach will produce NaN if any vector component is NaN regardless of other components.
====

===== Normalize

[cols="1h,1,2"]
|===
| Operation | `math/normalize` | Vector normalization
| Input value sockets
| `floatN a` | Vector
.2+| Output value sockets
d| `floatN value` | Vector in the same direction as stem:[a] but with a unit length, e.g., latexmath:[\dfrac{\vec{a}}{\sqrt{a_x^2 + a_y^2}}] for `float2`; see the description for details
d| `bool isValid` | True if the output vector value has a unit length after normalization; false otherwise
|===

The output values are computed as follows:

1. Let _length_ be the output value of the `math/length` operation on stem:[a] as defined above.

2. If _length_ is zero, NaN, or positive infinity, the `isValid` output value is false and the `value` output value is a vector of the same type as stem:[a] with all components set to positive zeros.

3. If _length_ is a positive finite number, the `isValid` output value is true and the `value` output value is a vector of the same type as stem:[a] constructed by dividing each component of stem:[a] by _length_.

[TIP]
.Authoring Tip
====
If the input vector represents a quaternion and the graph expects it to be identity in a case when normalization fails, a `math/select` node could be added to return stem:[(0, 0, 0, 1)] when `isValid` is false.
====

===== Dot Product

[cols="1h,1,2"]
|===
| Operation | `math/dot` | Dot product
.2+| Input value sockets
d| `floatN a` | First vector
d| `floatN b` | Second vector of the same type as stem:[a]
| Output value sockets
| `float value` | Sum of per-component products of stem:[a] and stem:[b], e.g., stem:[a_x * b_x + a_y * b_y] for `float2`
|===

Both input value sockets **MUST** have the same type.

Since this operation is a shortcut for the combination of multiplications and additions, NaN and infinity values are propagated accordingly.

[NOTE]
.Implementation Note
====
This operation is frequently used with both input value sockets connected to the same output value socket to compute the squared length of a vector.
====

===== Cross Product

[cols="1h,1,2"]
|===
| Operation | `math/cross` | Cross product
.2+| Input value sockets
d| `float3 a` | Vector
d| `float3 b` | Vector
| Output value sockets
| `float3 value` | Cross product of stem:[a] and stem:[b], i.e., stem:[(a_y * b_z - a_z * b_y, a_z * b_x - a_x * b_z, a_x * b_y - a_y * b_x)]
|===

Since this operation is a shortcut for the combination of multiplications and subtractions, NaN and infinity values are propagated accordingly.

===== Rotate 2D

[cols="1h,1,2"]
|===
| Operation | `math/rotate2D` | 2D rotation
.2+| Input value sockets
d| `float2 a` | Vector to rotate
d| `float angle`  | Angle in radians
| Output value sockets
| `float2 value` | Rotated vector
|===

Let latexmath:[a_x] and latexmath:[a_y] be the components of the `a` input socket value and latexmath:[\alpha] be the `angle` input socket value.

Then the components of the `value` output socket value are computed as follows:

[latexmath]
+++++
x = a_x \cdot \cos(\alpha) - a_y \cdot \sin(\alpha) \\
y = a_x \cdot \sin(\alpha) + a_y \cdot \cos(\alpha)
+++++

Since this operation is a shortcut for the combination of trigonometry and arithmetic operations, NaN and infinity values are propagated accordingly.

===== Rotate 3D

[cols="1h,1,2"]
|===
| Operation | `math/rotate3D` | 3D rotation
.2+| Input value sockets
d| `float3 a` | Vector to rotate
d| `float4 rotation` | Rotation quaternion
| Output value sockets
| `float3 value` | Rotated vector
|===

[CAUTION]
====
This node assumes that the rotation quaternion is unit.
====

Let

- latexmath:[\vec{a}] be a three-component vector formed from the `a` input socket value;
- latexmath:[r_x], latexmath:[r_y], latexmath:[r_z], and latexmath:[r_w] be the components of the `rotation` input socket value;
- latexmath:[\vec{r}] be a three-component vector formed from latexmath:[r_x], latexmath:[r_y], and latexmath:[r_z].

Then the components of the `value` output socket value are computed as the components of the following vector:

[latexmath]
+++++
\vec{a} + 2 \cdot (\vec{r} \times (\vec{r} \times \vec{a}) + r_w \cdot (\vec{r} \times \vec{a}))
+++++

Since this operation is a shortcut for the combination of arithmetic operations, NaN and infinity values are propagated accordingly.

[NOTE]
.Implementation Note
====
This operation is supposed to be more efficient than converting the rotation quaternion to a matrix and transforming the vector with it.
====

[TIP]
.Authoring Tip
====
This operation does not implicitly normalize the rotation quaternion. If needed, that step could be done explicitly by adding a `math/normalize` node.
====

===== Transform

[cols="1h,1,2"]
|===
| Operation | `math/transform` | Vector transformation
.2+| Input value sockets
d| `float2 a`   | Vector to transform
d| `float2x2 b` | Transformation matrix
| Output value sockets
| `float2 value` | Transformed vector
|===

[cols="1h,1,2"]
|===
| Operation | `math/transform` | Vector transformation
.2+| Input value sockets
d| `float3 a`   | Vector to transform
d| `float3x3 b` | Transformation matrix
| Output value sockets
| `float3 value` | Transformed vector
|===

[cols="1h,1,2"]
|===
| Operation | `math/transform` | Vector transformation
.2+| Input value sockets
d| `float4 a`   | Vector to transform
d| `float4x4 b` | Transformation matrix
| Output value sockets
| `float4 value` | Transformed vector
|===

==== Matrix Nodes

===== Transpose

[cols="1h,1,2"]
|===
| Operation | `math/transpose` | Transpose operation
| Input value sockets
| `floatNxN a` | Matrix to transpose
| Output value sockets
| `floatNxN value` | Matrix that is the transpose of stem:[a]
|===

The input and output value sockets have the same type.

This operation only reorders the matrix elements without inspecting or altering their values.

===== Determinant

[cols="1h,1,2"]
|===
| Operation | `math/determinant` | Dot product
| Input value sockets
| `floatNxN a` | Matrix
| Output value sockets
| `float value` | Determinant of stem:[a]
|===

Since this operation is a shortcut for the combination of multiplications, subtractions, and additions, NaN and infinity values are propagated accordingly.

===== Inverse

[cols="1h,1,2"]
|===
| Operation | `math/inverse` | Inverse operation
| Input value sockets
| `floatNxN a` | Matrix stem:[A] to inverse
.2+| Output value sockets
d| `floatNxN value` | Matrix that is the inverse of stem:[A]; see the description for details
d| `bool isValid` | True if the input matrix is invertible; false otherwise
|===

The `value` input value socket and `value` output value socket have the same type.

The output values are computed as follows:

1. Let _determinant_ be the output value of the `math/determinant` operation on stem:[A] as defined above.

2. If _determinant_ is zero, NaN, or infinity, the `isValid` output value is false and the `value` output value is a matrix of the same type as stem:[A] with all elements set to positive zeros.

3. If _determinant_ is a finite number not equal to zero, the `isValid` output value is true and the `value` output value is a matrix that is an implementation-defined approximation of the inverse of stem:[A].

===== Multiplication

[cols="1h,1,2"]
|===
| Operation | `math/matMul` | Matrix multiplication operation
.2+| Input value sockets
d| `floatNxN a` | First matrix
d| `floatNxN b` | Second matrix
| Output value sockets
| `floatNxN value` | Matrix product
|===

Both input value sockets **MUST** have the same type.

The output value socket has the same type as the input value sockets.

Since this operation is a shortcut for the combination of multiplications and additions, NaN and infinity values are propagated accordingly.

[NOTE]
.Authoring Note
====
See `math/mul` for per-element multiplication.
====

===== Compose

[cols="1h,1,2"]
|===
| Operation | `math/matCompose` | Compose a 4x4 transform matrix
.3+| Input value sockets
d| `float3 translation` | Translation vector
d| `float4 rotation` | Rotation quaternion
d| `float3 scale` | Scale vector
| Output value sockets
| `float4x4 value` | Matrix composed from the TRS properties
|===

[CAUTION]
====
This node assumes that the rotation quaternion is unit.
====

Let

- stem:[t_x], stem:[t_y], and stem:[t_z] be the translation vector components;
- stem:[r_x], stem:[r_y], stem:[r_z], and stem:[r_w] be the rotation quaternion components;
- stem:[s_x], stem:[s_y], and stem:[s_z] be the scale vector components.

Then the `value` output socket value is computed as follows:

[stem]
+++++
((1, 0, 0, t_x),
 (0, 1, 0, t_y),
 (0, 0, 1, t_z),
 (0, 0, 0, 1)) cdot
((1 - 2(r_y^2 + r_z^2), 2(r_xr_y - r_zr_w),   2(r_xr_z + r_yr_w),   0),
 (2(r_xr_y + r_zr_w),   1 - 2(r_x^2 + r_z^2), 2(r_yr_z - r_xr_w),   0),
 (2(r_xr_z - r_yr_w),   2(r_yr_z + r_xr_w),   1 - 2(r_x^2 + r_y^2), 0),
 (0, 0, 0, 1)) cdot
((s_x, 0,   0,   0),
 (0,   s_y, 0,   0),
 (0,   0,   s_z, 0),
 (0,   0,   0,   1)) =

= ((s_x * (1 - 2(r_y^2 + r_z^2)), s_y * 2(r_xr_y - r_zr_w),     s_z * 2(r_xr_z + r_yr_w),     t_x),
   (s_x * 2(r_xr_y + r_zr_w),     s_y * (1 - 2(r_x^2 + r_z^2)), s_z * 2(r_yr_z - r_xr_w),     t_y),
   (s_x * 2(r_xr_z - r_yr_w),     s_y * 2(r_yr_z + r_xr_w),     s_z * (1 - 2(r_x^2 + r_y^2)), t_z),
   (0, 0, 0, 1))
+++++

Since this operation is a shortcut for the combination of multiplications, subtractions, and additions, NaN and infinity values are propagated accordingly.

[TIP]
.Authoring Tip
====
This operation does not implicitly normalize the rotation quaternion. If needed, that step could be done explicitly by adding a `math/normalize` node.
====

===== Decompose

[cols="1h,1,2"]
|===
| Operation | `math/matDecompose` | Decompose a 4x4 transform matrix to TRS properties
| Input value sockets
| `float4x4 a` | Matrix stem:[A] to decompose
.4+| Output value sockets
d| `float3 translation` | Translation vector
d| `float4 rotation` | Rotation quaternion
d| `float3 scale` | Scale vector
d| `bool isValid` | True if the input matrix is decomposable; false otherwise
|===

The output values are computed as follows:

1. If the first three elements of the fourth row of stem:[A] are not zeros or if the last element of the fourth row of stem:[A] is not close to positive one within an implementation-defined threshold, set the `isValid` output value to false and goto to the step 11.

2. Let stem:[s_x], stem:[s_y], and stem:[s_z] be lengths of the first three columns of stem:[A]. For example, stem:[s_x=sqrt(a_{11}^2+a_{21}^2+a_{31}^2)].

3. If stem:[s_x], stem:[s_y], or stem:[s_z] are infinite, NaN, or equal to zero, set the `isValid` output value to false and goto to the step 11.

4. Let stem:[B] be a 3x3 matrix formed by taking the upper-left 3x3 sub-matrix of stem:[A] and dividing each column by stem:[s_x], stem:[s_y], and stem:[s_z] respectively.
+
[stem]
+++++
B = ((a_{11}/s_x, a_{12}/s_y, a_{13}/s_z),
     (a_{21}/s_x, a_{22}/s_y, a_{23}/s_z),
     (a_{31}/s_x, a_{32}/s_y, a_{33}/s_z))
+++++

5. If the absolute value of the determinant of stem:[B] is not close to one within an implementation-defined threshold, set the `isValid` output value to false and goto to the step 11.

6. Set the `translation` output value to the first three elements of the fourth column of stem:[A], i.e., to stem:[(a_{14}, a_{24}, a_{34})].

7. If the determinant of stem:[B] is positive, set the `scale` output value to stem:[(s_x, s_y, s_z)].

8. If the determinant of stem:[B] is negative, do one of the following four options.
.. First option:
... set the `scale` output value to latexmath:[(-s_x, s_y, s_z)];
... negate elements of the first column of stem:[B] in-place.
.. Second option:
... set the `scale` output value to latexmath:[(s_x, -s_y, s_z)];
... negate elements of the second column of stem:[B] in-place.
.. Third option:
... set the `scale` output value to latexmath:[(s_x, s_y, -s_z)];
... negate elements of the third column of stem:[B] in-place.
.. Fourth option:
... set the `scale` output value to latexmath:[(-s_x, -s_y, -s_z)];
... negate all elements of stem:[B] in-place.

9. Set the `rotation` output value to the unit quaternion corresponding to the rotation matrix stem:[B].

10. Set `isValid` output value to true.

11. If the `isValid` output value is false,
.. set the `translation` output value to stem:[(0, 0, 0)];
.. set the `rotation` output value to stem:[(0, 0, 0, 1)];
.. set the `scale` output value to stem:[(1, 1, 1)].

==== Quaternion Nodes

===== Conjugation

[cols="1h,1,2"]
|===
| Operation | `math/quatConjugate` | Quaternion conjugation operation
| Input value sockets
| `float4 a` | Input quaternion
| Output value sockets
| `float4 value` | Conjugated quaternion
|===

Let stem:[a_x], stem:[a_y], stem:[a_z], and stem:[a_w] be the components of stem:[a].

Then the components of the `value` output socket value are set as follows:

[latexmath]
+++++
x = -a_x \\
y = -a_y \\
z = -a_z \\
w = a_w
+++++

Since this operation is a shortcut for the combination of negations, NaN and infinity values are propagated accordingly.

[TIP]
.Authoring Tip
====
If the quaternion is unit, this operation also produces the quaternion's inverse.
====

===== Multiplication

[cols="1h,1,2"]
|===
| Operation | `math/quatMul` | Quaternion multiplication operation
.2+| Input value sockets
d| `float4 a` | First quaternion
d| `float4 b` | Second quaternion
| Output value sockets
| `float4 value` | Quaternion product
|===

Let

- stem:[a_x], stem:[a_y], stem:[a_z], and stem:[a_w] be the components of stem:[a];
- stem:[b_x], stem:[b_y], stem:[b_z], and stem:[b_w] be the components of stem:[b].

Then the components of the `value` output socket value are computed as follows:

[stem]
+++++
x = a_w * b_x + a_x * b_w + a_y * b_z - a_z * b_y \
y = a_w * b_y + a_y * b_w + a_z * b_x - a_x * b_z \
z = a_w * b_z + a_z * b_w + a_x * b_y - a_y * b_x \
w = a_w * b_w - a_x * b_x - a_y * b_y - a_z * b_z
+++++

Since this operation is a shortcut for the combination of multiplications, subtractions, and additions, NaN and infinity values are propagated accordingly.

===== Angle Between Quaternions

[cols="1h,1,2"]
|===
| Operation | `math/quatAngleBetween` | Angle between two quaternions
.2+| Input value sockets
d| `float4 a` | First quaternion
d| `float4 b` | Second quaternion
| Output value sockets
| `float value` | Angle in radians
|===

[CAUTION]
====
This node assumes that both input quaternions are unit.
====

Let

- stem:[a_x], stem:[a_y], stem:[a_z], and stem:[a_w] be the components of stem:[a];
- stem:[b_x], stem:[b_y], stem:[b_z], and stem:[b_w] be the components of stem:[b].

Then the `value` output socket value is computed as follows:

[latexmath]
+++++
2 \cdot \arccos(a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z + a_w \cdot b_w)
+++++

Since this operation is a shortcut for the combination of arithmetic and trigonometry operations, NaN and infinity values are propagated accordingly.

[TIP]
.Authoring Tip
====
This operation does not implicitly normalize the input quaternions. If needed, that step could be done explicitly by adding `math/normalize` nodes.
====

===== Quaternion From Axis & Angle

[cols="1h,1,2"]
|===
| Operation | `math/quatFromAxisAngle` | Create a quaternion from a rotation axis and an angle
.2+| Input value sockets
d| `float3 axis` | Rotation axis
d| `float angle` | Angle in radians
| Output value sockets
| `float4 value` | Rotation quaternion
|===

[CAUTION]
====
This node assumes that the rotation axis vector is unit.
====

The components of the `value` output socket value are computed as follows:

[latexmath]
+++++
x = \textit{axis}_x \cdot \sin(0.5 \cdot \textit{angle}) \\
y = \textit{axis}_y \cdot \sin(0.5 \cdot \textit{angle}) \\
z = \textit{axis}_z \cdot \sin(0.5 \cdot \textit{angle}) \\
w = \cos(0.5 \cdot \textit{angle})
+++++

Since this operation is a shortcut for the combination of multiplications and trigonometry functions, NaN and infinity values are propagated accordingly.

[TIP]
.Authoring Tip
====
This operation does not implicitly normalize the rotation axis vector. If needed, that step could be done explicitly by adding a `math/normalize` node.
====

===== Quaternion To Axis & Angle

[cols="1h,1,2"]
|===
| Operation | `math/quatToAxisAngle` | Decompose a quaternion to a rotation axis and an angle
| Input value sockets
| `float4 a` | Rotation quaternion
.2+| Output value sockets
d| `float3 axis` | Rotation axis
d| `float angle` | Angle in radians
|===

[CAUTION]
====
This node assumes that the rotation quaternion is unit.
====

Let stem:[a_x], stem:[a_y], stem:[a_z], and stem:[a_w] be the components of stem:[a].

Then the `angle` and `axis` output socket values are computed as follows:

1. If the absolute value of stem:[a_w] is close to one within an implementation-defined threshold, set the `angle` socket value to zero and the `axis` socket value to any axis-aligned unit vector, i.e., to one of latexmath:[(\pm1, 0, 0)], latexmath:[(0, \pm1, 0)], or latexmath:[(0, 0, \pm1)].
2. Else set `angle` and `axis` socket values using the following expressions:
+
[latexmath]
+++++
\textit{axis}_x = \frac{a_x}{\sqrt{1 - a^2_w}} \\
\textit{axis}_y = \frac{a_y}{\sqrt{1 - a^2_w}} \\
\textit{axis}_z = \frac{a_z}{\sqrt{1 - a^2_w}} \\
\textit{angle} = 2 \cdot \arccos(a_w)
+++++

Since this operation is a shortcut for the combination of arithmetic and trigonometry functions, NaN and infinity values are propagated accordingly.

[TIP]
.Authoring Tip
====
This operation does not implicitly normalize the rotation quaternion. If needed, that step could be done explicitly by adding a `math/normalize` node.
====

===== Quaternion From Two Directional Vectors

[cols="1h,1,2"]
|===
| Operation | `math/quatFromDirections` | Create a quaternion transforming one directional vector to another
.2+| Input value sockets
d| `float3 a` | First direction
d| `float3 b` | Second direction
| Output value sockets
| `float4 value` | Rotation quaternion
|===

[CAUTION]
====
This node assumes that both directions are unit.
====

The components of the `value` output socket value are computed as follows:

1. Let latexmath:[c] be the dot product of latexmath:[\vec{a}] and latexmath:[\vec{b}].
2. If latexmath:[c] is close to positive one within an implementation-defined threshold,
.. set the `value` output value to an identity quaternion, i.e., set the stem:[w] component of the `value` output value to stem:[\pm1] and set the other three components to zeros;
.. skip the next steps.
3. If latexmath:[c] is close to negative one within an implementation-defined threshold,
.. set the stem:[x], stem:[y], and stem:[z] components of the `value` output socket value to the corresponding components of a unit vector representing a direction perpendicular to latexmath:[\vec{a}];
.. set the stem:[w] component of the `value` output socket value to zero;
.. skip the next steps.
4. Let latexmath:[\vec{r}] be the normalized cross product of latexmath:[\vec{a}] and latexmath:[\vec{b}].
5. Set the components of the `value` output socket value using the following expressions:
+
[latexmath]
+++++
x = r_x \cdot \sqrt{0.5 - 0.5 \cdot c} \\
y = r_y \cdot \sqrt{0.5 - 0.5 \cdot c} \\
z = r_z \cdot \sqrt{0.5 - 0.5 \cdot c} \\
w = \sqrt{0.5 + 0.5 \cdot c}
+++++

Since this operation is a shortcut for the combination of arithmetic and exponential functions, NaN and infinity values are propagated accordingly.

[TIP]
.Authoring Tip
====
This operation implies that both input vectors are normalized. A `math/normalize` node could be added to handle non-normalized inputs.
====

===== Quaternion From Up and Forward Directional Vectors

[cols="1h,1,2"]
|===
| Operation | `math/quatFromUpForward` | Create a quaternion from the specified up and forward directions
.2+| Input value sockets
d| `float3 up` | Up direction
d| `float3 forward` | Forward direction
| Output value sockets
| `float4 value` | Rotation quaternion
|===

[CAUTION]
====
This node assumes that both input directions are unit.
====

The `value` output socket value is computed as follows:

1. Let latexmath:[\vec{y}] be a three-component vector corresponding to the `up` input socket value and latexmath:[\vec{r}] be a three-component vector corresponding to the `forward` input socket value.
2. If latexmath:[\vec{y}] and latexmath:[\vec{r}] are colinear within an implementation-defined threshold,
.. let latexmath:[\vec{s}] be a three-component unit vector representing a direction perpendicular to latexmath:[\vec{r}].
3. Else
.. let latexmath:[\vec{s}] be the normalized cross product of latexmath:[\vec{y}] and latexmath:[\vec{r}].
4. Let latexmath:[\vec{t}] be the cross product of latexmath:[\vec{r}] and latexmath:[\vec{s}].
5. Let latexmath:[M] be a rotation matrix composed as follows:
+
[stem]
+++++
M = ((s_x, t_x, r_x),
     (s_y, t_y, r_y),
     (s_z, t_z, r_z))
+++++
6. Set the `value` output value to the unit quaternion corresponding to the rotation matrix stem:[M].

[TIP]
.Authoring Tip
====
This operation implies that both input vectors are normalized. A `math/normalize` node could be added to handle non-normalized inputs.
====

===== Quaternion Spherical Linear Interpolation

[cols="1h,1,2"]
|===
| Operation | `math/quatSlerp` | Spherical linear interpolation operation
.3+| Input value sockets
d| `float4 a` | First quaternion
d| `float4 b` | Second quaternion
d| `float c` |  Unclamped interpolation coefficient
| Output value sockets
| `float4 value` | Interpolated value
|===

[CAUTION]
====
This node assumes that both input quaternions are unit.
====

The `value` output socket value is computed as follows:

1. Let
.. stem:[a_x], stem:[a_y], stem:[a_z], and stem:[a_w] be the components of stem:[a];
.. stem:[b_x], stem:[b_y], stem:[b_z], and stem:[b_w] be the components of stem:[b].
2. Let latexmath:[d = a_x \cdot b_x + a_y \cdot b_y + a_z \cdot b_z + a_w \cdot b_w].
3. If latexmath:[d] is negative,
.. set latexmath:[d] to latexmath:[-d];
.. negate all components of the quaternion latexmath:[b].
4. If latexmath:[d] is close to positive one within an implementation-defined threshold,
.. let latexmath:[k_a = 1 - c], latexmath:[k_b = c].
5. Else let:
.. latexmath:[\omega = \arccos(d)];
.. latexmath:[k_a = \frac{\sin(\omega \cdot (1 - c))}{\sin(\omega)}], latexmath:[k_b = \frac{\sin(\omega \cdot c)}{\sin(\omega)}].
6. Set the components of the `value` output socket value using the following expressions:
+
[latexmath]
+++++
x = a_x \cdot k_a + b_x \cdot k_b \\
y = a_y \cdot k_a + b_y \cdot k_b \\
z = a_z \cdot k_a + b_z \cdot k_b \\
w = a_w \cdot k_a + b_w \cdot k_b
+++++

Since this operation is a shortcut for the combination of arithmetic and trigonometry operations, NaN and infinity values are propagated accordingly.

[TIP]
.Authoring Tip
====
This operation does not implicitly normalize the input quaternions. If needed, that step could be done explicitly by adding `math/normalize` nodes.
====

==== Swizzle Nodes

===== Combine

[cols="1h,1,2"]
|===
| Operation | `math/combine2` | Combine two floats into a two-component vector
.2+| Input value sockets
d| `float a` | First component
d| `float b` | Second component
| Output value sockets
| `float2 value` | Vector
|===

[cols="1h,1,2"]
|===
| Operation | `math/combine3` | Combine three floats into a three-component vector
.3+| Input value sockets
d| `float a` | First component
d| `float b` | Second component
d| `float c` | Third component
| Output value sockets
| `float3 value` | Vector
|===

[cols="1h,1,2"]
|===
| Operation | `math/combine4` | Combine four floats into a four-component vector
.4+| Input value sockets
d| `float a` | First component
d| `float b` | Second component
d| `float c` | Third component
d| `float d` | Fourth component
| Output value sockets
| `float4 value` | Vector
|===

[cols="1h,1,2"]
|===
| Operation | `math/combine2x2` | Combine 4 floats into a 2x2 matrix
.4+| Input value sockets
d| `float a` | First row, first column element
d| `float b` | Second row, first column element
d| `float c` | First row, second column element
d| `float d` | Second row, second column element
| Output value sockets
| `float2x2 value` | Matrix
|===

[cols="1h,1,2"]
|===
| Operation | `math/combine3x3` | Combine 9 floats into a 3x3 matrix
.9+| Input value sockets
d| `float a` | First row, first column element
d| `float b` | Second row, first column element
d| `float c` | Third row, first column element
d| `float d` | First row, second column element
d| `float e` | Second row, second column element
d| `float f` | Third row, second column element
d| `float g` | First row, third column element
d| `float h` | Second row, third column element
d| `float i` | Third row, third column element
| Output value sockets
| `float3x3 value` | Matrix
|===

[cols="1h,1,2"]
|===
| Operation | `math/combine4x4` | Combine 16 floats into a 4x4 matrix
.16+| Input value sockets
d| `float a` | First row, first column element
d| `float b` | Second row, first column element
d| `float c` | Third row, first column element
d| `float d` | Fourth row, first column element
d| `float e` | First row, second column element
d| `float f` | Second row, second column element
d| `float g` | Third row, second column element
d| `float h` | Fourth row, second column element
d| `float i` | First row, third column element
d| `float j` | Second row, third column element
d| `float k` | Third row, third column element
d| `float l` | Fourth row, third column element
d| `float m` | First row, fourth column element
d| `float n` | Second row, fourth column element
d| `float o` | Third row, fourth column element
d| `float p` | Fourth row, fourth column element
| Output value sockets
| `float4x4 value` | Matrix
|===

===== Extract

[cols="1h,1,2"]
|===
| Operation | `math/extract2` | Extract two floats from a two-component vector
| Input value sockets
| `float2 a` | Vector
.2+| Output value sockets
d| `float 0` | First component
d| `float 1` | Second component
|===

[cols="1h,1,2"]
|===
| Operation | `math/extract3` | Extract three floats from a three-component vector
| Input value sockets
| `float3 a` | Vector
.3+| Output value sockets
d| `float 0` | First component
d| `float 1` | Second component
d| `float 2` | Third component
|===

[cols="1h,1,2"]
|===
| Operation | `math/extract4` | Extract four floats from a four-component vector
| Input value sockets
| `float4 a` | Vector
.4+| Output value sockets
d| `float 0` | First component
d| `float 1` | Second component
d| `float 2` | Third component
d| `float 3` | Fourth component
|===

[cols="1h,1,2"]
|===
| Operation | `math/extract2x2` | Extract 4 floats from a 2x2 matrix
| Input value sockets
| `float2x2 a` | Matrix
.4+| Output value sockets
d| `float 0` | First row, first column element
d| `float 1` | Second row, first column element
d| `float 2` | First row, second column element
d| `float 3` | Second row, second column element
|===

[cols="1h,1,2"]
|===
| Operation | `math/extract3x3` | Extract 9 floats from a 3x3 matrix
| Input value sockets
| `float3x3 a` | Matrix
.9+| Output value sockets
d| `float 0` | First row, first column element
d| `float 1` | Second row, first column element
d| `float 2` | Third row, first column element
d| `float 3` | First row, second column element
d| `float 4` | Second row, second column element
d| `float 5` | Third row, second column element
d| `float 6` | First row, third column element
d| `float 7` | Second row, third column element
d| `float 8` | Third row, third column element
|===

[cols="1h,1,2"]
|===
| Operation | `math/extract4x4` | Extract 16 floats from a 4x4 matrix
| Input value sockets
| `float4x4 a` | Matrix
.16+| Output value sockets
d| `float 0`  | First row, first column element
d| `float 1`  | Second row, first column element
d| `float 2`  | Third row, first column element
d| `float 3`  | Fourth row, first column element
d| `float 4`  | First row, second column element
d| `float 5`  | Second row, second column element
d| `float 6`  | Third row, second column element
d| `float 7`  | Fourth row, second column element
d| `float 8`  | First row, third column element
d| `float 9`  | Second row, third column element
d| `float 10` | Third row, third column element
d| `float 11` | Fourth row, third column element
d| `float 12` | First row, fourth column element
d| `float 13` | Second row, fourth column element
d| `float 14` | Third row, fourth column element
d| `float 15` | Fourth row, fourth column element
|===

==== Integer Arithmetic Nodes

All inputs to these nodes are two's complement 32-bit signed integers.

===== Absolute Value

[cols="1h,1,2"]
|===
| Operation | `math/abs` | Absolute value operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | latexmath:[\begin{cases}
                             -a & \text{if } a \lt 0 \\
                              a & \text{if } a \ge 0
                           \end{cases}]
|===

As this node is defined in terms of the negation node (see below), the absolute value of `-2147483648` is `-2147483648`.

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.abs(a) | 0
----
====

===== Sign

[cols="1h,1,2"]
|===
| Operation | `math/sign` | Sign operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | latexmath:[\begin{cases}
                             -1 & \text{if } a \lt 0 \\
                              0 & \text{if } a = 0 \\
                             +1 & \text{if } a \gt 0
                           \end{cases}]
|===

===== Negation

[cols="1h,1,2"]
|===
| Operation | `math/neg` | Negation operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | stem:[-a]
|===

Negating `-2147483648` **MUST** return `-2147483648`.

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(-a) | 0
----
====

===== Addition

[cols="1h,1,2"]
|===
| Operation | `math/add` | Addition operation
.2+| Input value sockets
d| `int a` | First addend
d| `int b` | Second addend
| Output value sockets
| `int value` | Sum, stem:[a + b]
|===

Arithmetic overflow **MUST** wrap around, for example:

[source]
----
2147483647 + 1 == -2147483648
----

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(a + b) | 0
----
====

===== Subtraction

[cols="1h,1,2"]
|===
| Operation | `math/sub` | Subtraction operation
.2+| Input value sockets
d| `int a` | Minuend
d| `int b` | Subtrahend
| Output value sockets
| `int value` | Difference, stem:[a - b]
|===

Arithmetic overflow **MUST** wrap around, for example:

[source]
----
-2147483648 - 1 == 2147483647
----

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(a - b) | 0
----
====

===== Multiplication

[cols="1h,1,2"]
|===
| Operation | `math/mul` | Multiplication operation
.2+| Input value sockets
d| `int a` | First factor
d| `int b` | Second factor
| Output value sockets
| `int value` | Product, stem:[a * b]
|===

Arithmetic overflow **MUST** wrap around, for example:

[source]
----
 2147483647 * 2147483647 == 1

-2147483648 * (-1)       == -2147483648
----

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.imul(a, b)
----
====

===== Division

[cols="1h,1,2"]
|===
| Operation | `math/div` | Division operation
.2+| Input value sockets
d| `int a` | Dividend
d| `int b` | Divisor
| Output value sockets
| `int value` | latexmath:[\begin{cases}
                             \frac{a}{b} & \text{if } b \ne 0 \\
                             0 & \text{if } b = 0
                           \end{cases}]
|===

The quotient **MUST** be truncated towards zero.

Arithmetic overflow is defined as follows:
[source]
----
-2147483648 / (-1) == -2147483648
----

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(a / b) | 0
----
====

===== Remainder

[cols="1h,1,2"]
|===
| Operation | `math/rem` | Remainder operation
.2+| Input value sockets
d| `int a` | Dividend
d| `int b` | Divisor
| Output value sockets
| `int value` | latexmath:[\begin{cases}
                             a - (b \cdot \operatorname{trunc}(\frac{a}{b})) & \text{if } b \ne 0 \\
                             0 & \text{if } b = 0
                           \end{cases}]
|===

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
(a % b) | 0
----
====

===== Minimum

[cols="1h,1,2"]
|===
| Operation | `math/min` | Minimum operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `int value` | Smallest of the arguments
|===

===== Maximum

[cols="1h,1,2"]
|===
| Operation | `math/max` | Maximum operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `int value` | Largest of the arguments
|===

===== Clamp

[cols="1h,1,2"]
|===
| Operation | `math/clamp` | Clamp operation
.3+| Input value sockets
d| `int a` | Value to clamp
d| `int b` | First boundary
d| `int c` | Second boundary
| Output value sockets
| `int value` | latexmath:[\min(\max(a, \min(b, c)), \max(b, c))]
|===

This node is defined in terms of `math/min` and `math/max` nodes defined above.

[NOTE]
.Authoring Note
====
This operation correctly handles a case when stem:[b] is greater than stem:[c].
====

==== Integer Comparison Nodes

All inputs to these nodes are two's complement 32-bit signed integers.

===== Equality

[cols="1h,1,2"]
|===
| Operation | `math/eq` | Equality operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `bool value` | True if the input arguments are equal; false otherwise
|===

===== Less Than

[cols="1h,1,2"]
|===
| Operation | `math/lt` | Less than operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a < b]; false otherwise
|===

===== Less Than Or Equal To

[cols="1h,1,2"]
|===
| Operation | `math/le` | Less than or equal to operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a <= b]; false otherwise
|===

===== Greater Than

[cols="1h,1,2"]
|===
| Operation | `math/gt` | Greater than operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a > b]; false otherwise
|===

===== Greater Than Or Equal To

[cols="1h,1,2"]
|===
| Operation | `math/ge` | Greater than or equal operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `bool value` | True if stem:[a >= b]; false otherwise
|===

==== Integer Bitwise Nodes

All inputs to these nodes are two's complement 32-bit signed integers.

===== Bitwise NOT

[cols="1h,1,2"]
|===
| Operation | `math/not` | Bitwise NOT operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | `~a`
|===

===== Bitwise AND

[cols="1h,1,2"]
|===
| Operation | `math/and` | Bitwise AND operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `int value` | `a & b`
|===

===== Bitwise OR

[cols="1h,1,2"]
|===
| Operation | `math/or` | Bitwise OR operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `int value` | `a \| b`
|===

===== Bitwise XOR

[cols="1h,1,2"]
|===
| Operation | `math/xor` | Bitwise XOR operation
.2+| Input value sockets
d| `int a` | First argument
d| `int b` | Second argument
| Output value sockets
| `int value` | `a ^ b`
|===

===== Right Shift

[cols="1h,1,2"]
|===
| Operation | `math/asr` | Right Shift
.2+| Input value sockets
d| `int a` | Value to be shifted
d| `int b` | Number of bits to shift by
| Output value sockets
| `int value` | `a >> b`
|===

Only the lowest 5 bits of stem:[b] are considered, i.e., its effective range is [0, 31]. The result **MUST** be truncated to 32 bits and interpreted as a two's complement signed integer. The most significant bit of stem:[a] **MUST** be propagated.

===== Left Shift

[cols="1h,1,2"]
|===
| Operation | `math/lsl` | Left Shift
.2+| Input value sockets
d| `int a` | Value to be shifted
d| `int b` | Number of bits to shift by
| Output value sockets
| `int value` | `a << b`
|===

Only the lowest 5 bits of stem:[b] are considered, i.e., its effective range is [0, 31]. The result **MUST** be truncated to 32 bits and interpreted as a two's complement signed integer.

===== Count Leading Zeros

[cols="1h,1,2"]
|===
| Operation | `math/clz` | Count leading zeros operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | Number of leading zero bits in stem:[a]
|===

If stem:[a] is 0, the operation returns 32; if stem:[a] is negative, the operation returns 0.

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
Math.clz32(a)
----
====

===== Count Trailing Zeros

[cols="1h,1,2"]
|===
| Operation | `math/ctz` | Count trailing zeros operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | Number of trailing zero bits in stem:[a]
|===

If stem:[a] is 0, the operation returns 32.

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
a ? (31 - Math.clz32(a & -a)) : 32
----
====

===== Count One Bits

[cols="1h,1,2"]
|===
| Operation | `math/popcnt` | Count set bits operation
| Input value sockets
| `int a` | Argument
| Output value sockets
| `int value` | Number of set bits in stem:[a]
|===

If stem:[a] is 0, the operation returns 0; if stem:[a] is -1, the operation returns 32.

==== Boolean Arithmetic Nodes

===== Equality

[cols="1h,1,2"]
|===
| Operation | `math/eq` | Equality operation
.2+| Input value sockets
d| `bool a` | First argument
d| `bool b` | Second argument
| Output value sockets
| `bool value` | True if and only if both stem:[a] and stem:[b] have the same value; false otherwise
|===

===== Boolean NOT

[cols="1h,1,2"]
|===
| Operation | `math/not` | Boolean NOT operation
| Input value sockets
| `bool a` | Argument
| Output value sockets
| `bool value` | True if stem:[a] is false; false if stem:[a] is true
|===

===== Boolean AND

[cols="1h,1,2"]
|===
| Operation | `math/and` | Boolean AND operation
.2+| Input value sockets
d| `bool a` | First argument
d| `bool b` | Second argument
| Output value sockets
| `bool value` | True if and only if both stem:[a] and stem:[b] are true; false otherwise
|===

===== Boolean OR

[cols="1h,1,2"]
|===
| Operation | `math/or` | Boolean OR operation
.2+| Input value sockets
d| `bool a` | First argument
d| `bool b` | Second argument
| Output value sockets
| `bool value` | False if and only if both stem:[a] and stem:[b] are false; true otherwise
|===

===== Boolean XOR

[cols="1h,1,2"]
|===
| Operation | `math/xor` | Boolean XOR operation
.2+| Input value sockets
d| `bool a` | First argument
d| `bool b` | Second argument
| Output value sockets
| `bool value` | True if and only if stem:[a] is not equal to stem:[b]; false otherwise
|===

=== Type Conversion Nodes

==== Boolean Conversion Nodes

===== Boolean to Integer

[cols="1h,1,2"]
|===
| Operation | `type/boolToInt` | Boolean to integer conversion
| Input value sockets
| `bool a` | Argument
| Output value sockets
| `int value` | stem:[1] if stem:[a] is true; stem:[0] otherwise
|===

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
a | 0
----
====

===== Boolean to Float

[cols="1h,1,2"]
|===
| Operation | `type/boolToFloat` | Boolean to float conversion
| Input value sockets
| `bool a` | Argument
| Output value sockets
| `float value` | stem:[1] if stem:[a] is true; stem:[0] otherwise
|===

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
+a
----
====

==== Integer Conversion Nodes

===== Integer to Boolean

[cols="1h,1,2"]
|===
| Operation | `type/intToBool` | Integer to boolean conversion
| Input value sockets
| `int a` | Argument
| Output value sockets
| `bool value` | True if stem:[a] is not equal to zero; false otherwise
|===

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
!!a
----
====

===== Integer to Float

[cols="1h,1,2"]
|===
| Operation | `type/intToFloat` | Integer to float conversion
| Input value sockets
| `int a` | Argument
| Output value sockets
| `float value` | Floating-point value equal to stem:[a]
|===

Since floating-point values have double precision, this conversion **MUST** be lossless.

This operation **MUST NOT** produce negative zero.

[TIP]
.Implementation Tip
====
This operation is no-op in ECMAScript.
====

==== Float Conversion Nodes

===== Float to Boolean

[cols="1h,1,2"]
|===
| Operation | `type/floatToBool` | Float to boolean conversion
| Input value sockets
| `float a` | Argument
| Output value sockets
| `bool value` | False if stem:[a] is NaN or equal to zero; true otherwise
|===

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
!!a
----
====

===== Float to Integer

[cols="1h,1,2"]
|===
| Operation | `type/floatToInt` | Float to integer conversion
| Input value sockets
| `float a` | Argument
| Output value sockets
| `int value` | Integer value produced as described below
|===

1. If the stem:[a] input value is zero, infinite, or NaN, return zero and skip the next steps.
2. Let stem:[t] be stem:[a] with its fractional part removed by truncating towards zero.
3. Let stem:[k] be a value of the same sign as stem:[t] such that its absolute value is less than stem:[2^32] and stem:[k] is equal to stem:[t - q * 2^32] for some integer stem:[q].
4. If stem:[k] is greater than or equal to stem:[2^31], return stem:[k - 2^32]; otherwise return stem:[k].

[TIP]
.Implementation Tip
====
This is implementable in ECMAScript via the following expression:
[source,js]
----
a | 0
----
====

=== Control Flow Nodes

==== Sync Nodes

===== Sequence

[cols="1h,1,2"]
|===
| Operation | `flow/sequence` | Sequentially activate all connected output flows
| Input flow sockets
|  `in`  | The entry flow into this node
| Output flow sockets
| `<id>` | Zero or more output flows; their ids define the order of activation
|===

This node has no internal state.

When the `in` input flow is activated, all output flows are activated sequentially (each output flow is activated after the previous output flow completes) in the order as described in the <<socket-order,Socket Order>> section.

If the number of output flow sockets (as present in JSON) exceeds an implementation-defined limit, the graph **MUST** be rejected.

===== Branch

[cols="1h,1,2"]
|===
| Operation | `flow/branch` | Branch the execution flow based on a condition
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `bool condition` | Value selecting the branch taken
.2+| Output flow sockets
d| `true`  | The flow to be activated if the `condition` input value is true
d| `false` | The flow to be activated if the `condition` input value is false
|===

This node has no internal state.

The `condition` input value is evaluated each time the node is executed.

===== Switch

[cols="1h,1,2"]
|===
| Operation | `flow/switch` | Conditionally route the execution flow to one of the outputs
| Configuration
| `int[] cases` | The cases on which to perform the switch; empty in the default configuration
| Input flow sockets
|   `in`  | The entry flow into this node
| Input value sockets
| `int selection` | The value on which the switch operates
.2+| Output flow sockets
d| `<case>`  | Zero or more output flows; `<case>` is an integer decimal number
d| `default` | The output flow activated when the `selection` input value is not present in the `cases` configuration array
|===

[CAUTION]
====
The configuration of this node affects its flow sockets.
====

The node has zero or more `<case>` output flow sockets corresponding to the elements of the `cases` configuration array.

In the default configuration, the `cases` configuration array is empty and the node has only the `default` output flow socket.

The following procedure defines output flow sockets generation from the provided configuration:

1. If the `cases` configuration property is not present or if it is not an array, ignore it and use the default configuration.
2. If the `cases` configuration property is present and it is an array, then for each array element `C`:
.. if `C` is not a literal number or if it is not exactly representable as a 32-bit signed integer, ignore the `cases` property and use the default configuration;
+
[TIP]
.Implementation Tip
====
The integer representation check is implementable in ECMAScript via the following expression:
[source,js]
----
C === (C | 0)
----
====
.. convert `C` to a base-10 string representation `S` containing only decimal integers (ASCII characters `0x30 ... 0x39`) and a leading minus sign (ASCII character `0x2D`) if `C` is negative; extra leading zeros **MUST NOT** be present;
.. add a flow socket `S` to the set of the output flow sockets of this node or ignore it if an output flow socket with the same id has been already added.
3. If the number of generated flow sockets plus one exceeds an implementation-defined limit on the maximum number of output flow sockets, the graph **MUST** be rejected.
4. Proceed with the generated output flow sockets.

[NOTE]
.Examples
====
* If the `cases` configuration array is `[0.5, 1]`, the default configuration is used because `0.5` is not representable as a 32-bit signed integer.
* If the `cases` configuration array is `[-2147483649, 0]`, the default configuration is used because `-2147483649` is not representable as a 32-bit signed integer.
* If the `cases` configuration array is `[-1.0, 0, 1]`, the output socket ids are exactly `"-1"`, `"0"`, and `"1"` because `-1.0` is equal to an integer `-1`.
* If the `cases` configuration array is `[0.1e1, 2, 2]`, the output socket ids are exactly `"1"` and `"2"` because `0.1e1` is equal to an integer `1` and the duplicate entry is ignored.
====

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate the `selection` input value.
2. If the `cases` configuration array does not contain the `selection` input value:
.. activate the `default` output flow if it is connected.
3. If the `cases` configuration array contains the `selection` input value:
.. activate the output flow with the matching id if it is connected.

===== While Loop

[cols="1h,1,2"]
|===
| Operation | `flow/while` | Repeatedly activate the output flow based on a condition
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `bool condition` | Loop condition
.2+| Output flow sockets
d| `loopBody`  | The flow to be activated while the `condition` input value is true
d| `completed` | The flow to be activated once the `condition` input value is false
|===

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate the `condition` input value.
2. If the `condition` is true,
.. activate the `loopBody` output flow;
.. after completion of the `loopBody` output flow, self-activate the `in` input flow.
3. If the `condition` is false,
.. activate the `completed` output flow.

===== For Loop

[cols="1h,1,2"]
|===
| Operation | `flow/for` | Repeatedly activate the output flow based on an incrementing index value
| Configuration
| `int initialIndex` | The index value before the loop starts; zero in the default configuration
| Input flow sockets
| `in` | The entry flow into this node
.2+| Input value sockets
d| `int startIndex` | The start index of the loop
d| `int endIndex` | The end index of the loop
.2+| Output flow sockets
d| `loopBody`  | The flow to be activated if the `index` value is less than the `endIndex` input value
d| `completed` | The flow to be activated if the `index` value is greater than or equal to the `endIndex` input value
| Output value sockets
| `int index` | The current index value if the node has ever been activated, `initialIndex` otherwise
|===

In the default configuration, the `initialIndex` configuration value is zero.

If the `initialIndex` configuration property is not provided by the behavior graph, if it is not a literal number, or if its value is not exactly representable as a 32-bit signed integer, the default configuration **MUST** be used.

The internal state of this node consists of one 32-bit signed integer value `index` initialized to `initialIndex`.

When the `in` input flow is activated:

1. Evaluate the `startIndex` input value.
2. Set `index` to `startIndex`.
3. Evaluate the `endIndex` input value.
4. If `index` is less than the `endIndex` input value,
.. activate the `loopBody` output flow;
.. after completion of the `loopBody` output flow, increment the `index` value by 1;
.. self-activate the `in` input flow and goto step 3, i.e., skip steps 1 and 2;
5. If the `index` value is greater than or equal to the `endIndex` input value,
.. activate the `completed` output flow.

===== Do N

[cols="1h,1,2"]
|===
| Operation | `flow/doN` | Activate the output flow no more than N times
.2+| Input flow sockets
d|   `in`  | The entry flow into this node
d| `reset` | When this flow is activated, the `currentCount` value is reset to 0
| Input value sockets
| `int n` | Maximum number of times the `out` output flow is activated
| Output flow sockets
| `out` | The flow to be activated if the `currentCount` value is less than the `n` input value
| Output value sockets
| `int currentCount` | The current execution count
|===

The internal state of this node consists of one 32-bit signed integer value `currentCount` initialized to 0.

When the `reset` input flow is activated:

1. Reset `currentCount` to 0.

When the `in` input flow is activated:

1. Evaluate the `n` input value.
2. If `currentCount` is less than `n`,
.. increment `currentCount` by 1;
.. activate the `out` output flow.

===== Multi Gate

[cols="1h,1,2"]
|===
| Operation | `flow/multiGate` | Route the execution flow to one of the outputs sequentially or randomly
.2+| Configuration
d| `bool isRandom` | If set to true, output flows are activated in random order, picking a random not used output flow each time until all are done; false in the default configuration
d| `bool isLoop`   | If set to true, output flow activations will repeat in a loop continuously after all are done; false in the default configuration
.2+| Input flow sockets
d|   `in`  | The entry flow into this node
d| `reset` | When this flow is activated, the `lastIndex` value is reset to -1 and all outputs are marked as not used
| Output flow sockets
| `<id>`  | Zero or more output flows; their ids define the order of activation
| Output value sockets
| `int lastIndex` | The index of the last used output; `-1` if the node has not been activated
|===

If the number of output flow sockets (as present in JSON) exceeds an implementation-defined limit, the graph **MUST** be rejected.

In the default configuration, both `isRandom` and `isLoop` configuration values are false.

If any of the two configuration properties is not provided by the behavior graph or if it is not a literal boolean, the default configuration for both properties **MUST** be used.

The internal state of this node consists of one 32-bit signed integer value `lastIndex` initialized to -1 and an array of booleans with all values initialized to false representing used output flows. The size of the boolean array is equal to the number of output flows.

For the purposes of the `in` input flow operation, the output flows are assigned internal indices starting with zero in the order as described in the <<socket-order,Socket Order>> section.

When the `reset` input flow is activated:

1. Reset the `lastIndex` value to -1.
2. Mark all output flows as not used in the boolean array.

When the `in` input flow is activated:

1. If the `isRandom` configuration value is false,
.. let `i` be the smallest not used output flow index according to the boolean array or -1 if all output flows are marked as used.
2. If the `isRandom` configuration value is true,
.. let `i` be a random not used output flow index according to the boolean array or -1 if all output flows are marked as used.
3. If `i` is greater than -1,
.. mark the output flow with index `i` as used in the boolean array;
.. set the `lastIndex` value to `i`;
.. activate the output flow with index `i`.
4. If `i` is equal to -1 and the `isLoop` configuration value is true,
.. mark all output flows as not used in the boolean array;
.. if the `isRandom` configuration value is false,
... set `i` to 0;
.. if the `isRandom` configuration value is true,
... set `i` to a random output flow index;
.. mark the output flow with index `i` as used in the boolean array;
.. set the `lastIndex` value to `i`;
.. activate the output flow with index `i`.

When the `isRandom` and `isLoop` configuration values are true, the output flow activation order **SHOULD** be randomized on each loop iteration.

===== Wait All

[cols="1h,1,2"]
|===
| Operation | `flow/waitAll` | Activate the output flow when all input flows have been activated at least once.
| Configuration
| `int inputFlows` | The number of input flows; zero in the default configuration
.2+| Input flow sockets
d|   `<i>`  | The `i`-th input flow, `i` is a non-negative integer decimal number less than the `inputFlows` configuration value
d| `reset` | When this flow is activated, all input flows are marked as unused
.2+| Output flow sockets
d|    `out`    | The flow to be activated after every input flow activation except the last missing input
d| `completed` | The flow to be activated when the last missing input flow is activated
| Output value sockets
| `int remainingInputs` | The number of not yet activated input flows
|===

[CAUTION]
====
The configuration of this node affects its flow sockets.
====

The node has from zero to 64 input flow sockets with ids assigned sequential non-negative integer decimal numbers depending on the `inputFlows` configuration value. Encoded as base-10 strings, these input flow socket ids contain only decimal integers (ASCII characters `0x30 ... 0x39`); other characters and leading zeros are not used.

For example, if `inputFlows` is 3, the input flow socket ids are `"0"`, `"1"`, and `"2"` exactly.

In the default configuration, the `inputFlows` configuration value is zero.

If the `inputFlows` configuration property is not provided by the behavior graph, if it is not a literal number, if its value is not exactly representable as an integer, if it is negative, or if it is greater than 64, the default configuration **MUST** be used.

The internal state of this node consists of one 32-bit signed integer value `remainingInputs` initialized to the value of the `inputFlows` configuration property and an array of booleans with all values initialized to false representing activated input flow sockets. The size of the boolean array is equal to the value of the `inputFlows` configuration property.

When the `reset` input flow is activated:

1. Reset `remainingInputs` to the value of the `inputFlows` configuration property.
2. Mark all input flows as not activated in the boolean array.

When any of the `<i>` input flows is activated:

1. If the `<i>`-th input flow is not marked as activated in the boolean array:
.. mark the `<i>`-th input flow as activated in the boolean array;
.. decrement the `remainingInputs` value by 1.
2. If the `remainingInputs` value is zero:
.. activate the `completed` output flow.
3. If the `remainingInputs` value is not zero:
.. activate the `out` output flow.

[NOTE]
.Authoring Note
====
In the default configuration, this node has only the `reset` input flow, the `remainingInputs` output value is always zero, and the output flows are never activated.
====

===== Throttle

[cols="1h,1,2"]
|===
| Operation | `flow/throttle` | Activate the output flow unless it has been activated less than a certain time ago
.2+| Input flow sockets
d|   `in`  | The entry flow into this node
d| `reset` | When this flow is activated, the output flow throttling state is reset
| Input value sockets
| `float duration` | The time, in seconds, to wait after an output flow activation before allowing subsequent output flow activations
.2+| Output flow sockets
d| `out` | The flow to be activated if the output flow is not currently throttled
d| `err` | The flow to be activated if the `duration` input value is negative, infinite, or NaN
| Output value sockets
| `float lastRemainingTime` | The remaining throttling time, in seconds, at the moment of the last valid activation of the input flow or NaN if the input flow has never been activated with a valid `duration` input value
|===

The internal state of this node consists of an uninitialized _timestamp_ value of an implementation-defined high-precision time type and a floating-point `lastRemainingTime` value initialized to NaN.

When the `reset` input flow is activated:

1. Reset the `lastRemainingTime` value to NaN.

When the `in` input flow is activated:

1. Evaluate the `duration` input value.
2. If the `duration` input value is NaN, infinite, negative, or not convertible into an implementation-specific time type used for the internal _timestamp_ value,
.. activate the `err` output flow and skip the next steps.
3. If the `lastRemainingTime` value is not NaN:
.. Let `elapsed` be a non-negative difference, in seconds, between the _timestamp_ and the current time.
.. If the `duration` input value is less than or equal to the `elapsed` value,
... set the _timestamp_ value to the current time;
... set the `lastRemainingTime` value to zero;
... activate the `out` output flow.
.. If the `duration` input value is greater than the `elapsed` value,
... set the `lastRemainingTime` value to the positive difference, in seconds, between the `duration` and `elapsed` values.
4. If the `lastRemainingTime` value is NaN,
.. set the _timestamp_ value to the current time;
.. set the `lastRemainingTime` value to zero;
.. activate the `out` output flow.

==== Delay Nodes

===== Set Delay

[cols="1h,1,2"]
|===
| Operation | `flow/setDelay` | Schedule the output flow activation after a certain delay
.2+| Input flow sockets
d|   `in`   | The entry flow into this node
d| `cancel` | When this flow is activated, all delayed activations scheduled by this node are cancelled
| Input value sockets
| `float duration` | The duration, in seconds, to delay the `done` output flow activation
| Output value sockets
| `int lastDelayIndex` | The delay index assigned during the last successful node execution
.3+| Output flow sockets
d| `out` | The flow to be activated if the `duration` value is valid
d| `err` | The flow to be activated if the `duration` value is invalid
d| `done` | The flow to be activated after the delay
|===

The internal state of this node consists of an integer `lastDelayIndex` value initialized to -1 and a dynamic array of activation indices scheduled by the node. This array is initially empty and its maximum size is implementation-specific.

The internal state of an execution graph having one or more `flow/setDelay` nodes includes a dynamic array of activation indices scheduled from all such nodes. This array is initially empty and its maximum size is implementation-specific.

Implementations **MUST** be aware of their effective limit on the maximum supported `duration` input value to avoid any implicit behavior changes, e.g., due to numeric overflows; exceeding such value **MUST** lead to the `err` output flow activation as described below.

When the `in` input flow is activated:

1. Evaluate the `duration` input value.
2. If the `duration` input value is NaN, infinite, negative, or not convertible into an implementation-specific time type,
.. activate the `err` output flow and skip the next steps.
3. If scheduling a new activation exceeds an implementation-specific limit on the maximum number of simultaneous delays,
.. activate the `err` output flow and skip the next steps.
4. Let _activationTime_ be an implementation-defined high-precision time value equal to the sum of the current time value and the `duration` input value converted to the same time type.
5. If _activationTime_ is not valid according to implementation-specific validation rules, e.g., it exceeds an internal threshold value,
.. activate the `err` output flow and skip the next steps.
6. Set `lastDelayIndex` to a non-negative value representing the delayed flow activation being scheduled. This value **MUST** be unique across all previous activations of all `flow/setDelay` nodes of the graph.
7. Push the value of `lastDelayIndex` to the graph and node arrays of activation indices.
8. Schedule the following actions at the _activationTime_ time:
.. Removal of the activation index value from both arrays of activation indices.
.. Activation of the `done` output flow.
9. Activate the `out` output flow.

When the `cancel` input flow is activated:

1. Set the `lastDelayIndex` value to -1.
2. For each activation index value in the node's array of activation indices:
.. Remove this activation index value from the node's and the graph's arrays of activation indices.
.. Cancel the corresponding scheduled activation.

===== Cancel Delay

[cols="1h,1,2"]
|===
| Operation | `flow/cancelDelay` | Cancel a previously scheduled output flow activation
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `int delayIndex` | The index value of the scheduled activation to be cancelled
| Output flow sockets
| `out` | The flow to be activated after executing this node
|===

This node has no internal state but its execution **MAY** affect internal states of other nodes and the graph.

When the `in` input flow is activated:

1. Evaluate the `delayIndex` input value.
2. Remove this activation index value from all arrays of activation indices if it exists.
3. Cancel the corresponding scheduled activation if it exists.
4. Activate the `out` output flow.

Non-positive or not existing delay index values **MUST NOT** cause any runtime errors.

=== State Manipulation Nodes

==== Custom Variable Access

===== Variable Get

[cols="1h,1,2"]
|===
| Operation | `variable/get` | Get a custom variable value
| Configuration
| `int variable` | The custom variable index
| Output value sockets
| `T value` | The custom variable value
|===

[CAUTION]
====
This node does not have a default configuration.
====

[CAUTION]
====
The configuration of this node affects its value socket.
====

This node gets a custom variable value using the variable index provided by the `variable` configuration value.

The type `T` is determined by the referenced variable. The variable index **MUST** be a non-negative integer less than the total number of custom variables, otherwise the node is invalid and the graph **MUST** be rejected.

This node has no internal state.

===== Variable Set

[cols="1h,1,2"]
|===
| Operation | `variable/set` | Set one or more custom variable values
| Configuration
| `int[] variables` | The array containing variable indices
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `Ti <index>`  | One or more input value sockets; `<index>` refers to the corresponding variable index and `Ti` refers to its type
| Output flow sockets
| `out` | The flow to be activated after the values are set
|===

[CAUTION]
====
This node does not have a default configuration.
====

[CAUTION]
====
The configuration of this node affects its value sockets.
====

This node sets multiple custom variable values using the variable indices provided by the `variables` configuration value and the corresponding input values.

The following procedure defines input value sockets generation from the provided configuration:

1. If the `variables` configuration property is not present or if it is not a non-empty array, the node is invalid and the graph **MUST** be rejected.
2. If the `variables` configuration property is present and it is a non-empty array, then for each array element `V`:
.. if `V` is not a valid custom variable index, i.e., it is not a non-negative integer less than the total number of custom variables, the node is invalid and the graph **MUST** be rejected;
.. convert `V` to a base-10 string representation `S` containing only decimal integers (ASCII characters `0x30 ... 0x39`); extra leading zeros **MUST NOT** be present;
.. add a value socket with id `S` and the type corresponding to the type of the custom variable with index `V` to the set of the input value sockets of this node or ignore it if an input value socket with the same id has been already added.
3. If the number of generated value sockets exceeds an implementation-defined limit on the maximum number of input value sockets, the graph **MUST** be rejected.
4. Proceed with the generated input value sockets.

If the nodes's JSON object does not contain all input value sockets generated by the procedure above with proper types, the node is invalid and the graph **MUST** be rejected.

Extra input value sockets with ids not present in the output of the procedure above do not affect the node's operation and validation but they still **MUST** have valid types and value sources.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate all input values.
2. For each unique element `V` of the `variables` configuration array:
.. if the _variable interpolation state dynamic array_ (defined below) contains an entry with the variable index `V`, remove the entry from that array;
.. set the custom variable with the index `V` to the value of the `V` input value socket.
3. Activate the `out` output flow.

===== Variable Interpolate

[cols="1h,1,2"]
|===
| Operation | `variable/interpolate` | Interpolate a variable value
.2+| Configuration
d| `int variable` | The custom variable index
d| `bool useSlerp` | Whether to use spherical interpolation for quaternions
| Input flow sockets
| `in` | The entry flow into this node
.4+| Input value sockets
d| `T value` | The target variable value
d| `float duration` | The time, in seconds, in which the variable **SHOULD** reach the target value
d| `float2 p1` | Control point P1
d| `float2 p2` | Control point P2
.3+| Output flow sockets
d| `out` | The flow to be activated if the input values are valid
d| `err` | The flow to be activated if the input values are invalid
d| `done` | The flow to be activated when the variable reaches the target value
|===

[CAUTION]
====
This node does not have a default configuration.
====

[CAUTION]
====
The configuration of this node affects its value socket.
====

This node interpolates and updates the specified custom variable multiple times over the specified duration.

The type `T` is determined by the referenced variable. The variable index **MUST** be a non-negative integer less than the total number of custom variables, otherwise the node is invalid and the graph **MUST** be rejected.

If the referenced variable is integer or boolean, the node is invalid and the graph **MUST** be rejected.

The `useSlerp` configuration value **MUST** be a boolean literal and it **MUST NOT** be true if the type `T` is not `float4`, otherwise the node is invalid and the graph **MUST** be rejected.

This node has no internal state.

When a node of this type is used in the behavior graph, the global graph state includes an implementation-defined _variable interpolation state dynamic array_ each element of which contains the following data:

- The reference to the variable being interpolated
- Implementation-defined high precision timestamp value representing the interpolation start time
- Interpolation duration value converted to the implementation-defined high precision time type
- Variable value at the time of the successful node activation
- Information needed for cubic Bézier spline evaluation derived from the node's input values
- Target variable value
- Implementation-specific pointer to the `done` output flow of the node that has added this entry

This array is initially empty and its maximum size is implementation-specific.

When the `in` input flow is activated:

1. Evaluate all input values.
2. If the `duration` input value is NaN, infinite, negative, or not convertible into an implementation-specific time type used for the internal interpolation start time value,
.. activate the `err` output flow and skip the next steps.
3. If any component of the `p1` or `p2` input values is NaN or infinite or if any of the first components of these input values is negative or greater than 1,
.. activate the `err` output flow and skip the next steps.
4. If starting a new variable interpolation exceeds an implementation-specific limit on the maximum number of simultaneous variable interpolations,
.. activate the `err` output flow and skip the next steps.
5. If the _variable interpolation state dynamic array_ contains an entry with the same variable reference,
.. remove it from the array.
6. Using the implicitly-defined end points stem:[P_0 (0, 0)] and stem:[P_3 (1, 1)] together with the control points stem:[P_1] and stem:[P_2] provided via the input values construct a cubic Bézier easing function for the stem:[[0, 1]] input range.
7. Add a new entry to the _variable interpolation state dynamic array_ filling it with the required information based on the evaluated input values.
8. Activate the `out` output flow.

On each tick, for each entry of the _variable interpolation state dynamic array_:

1. Compute the current input progress position _t_ as the time passed since the interpolation start divided by the interpolation's duration.
2. If _t_ is less than or equal to zero,
.. skip the next steps.
3. If _t_ is NaN or greater than or equal to 1,
.. set the variable to the target value;
.. remove the current entry from the _variable interpolation state dynamic array_;
.. activate the `done` output flow linked to the current entry;
.. skip the next steps.
4. Using the cubic Bézier spline information, compute the output progress position _q_ based on the _t_ value. This step implies that latexmath:[t \in (0; 1)].
5. Set the variable to the new value computed as a linear or spherical linear interpolation depending on the `useSlerp` configuration value between the original and the target variable values using the output progress position _q_ as the interpolation coefficient.

[NOTE]
.Authoring Note
====
Certain control point values can cause the intermediate output progress value to be negative or greater than one. This is not an error.
====

==== Object Model Access

Operations defined in this section use JSON Pointers (<<rfc6901,RFC 6901>>) to refer to glTF Asset Object Model properties. These pointers are generated from JSON Pointer Templates specified in the `pointer` configuration values of the nodes.

JSON Pointers always refer to the properties of the glTF asset that contains the behavior graph. Existence and validity of properties accessed via JSON Pointers do not depend on the current glTF scene index.

[NOTE]
.Implementation Note
====
For example:

* The `/nodes/0/translation` pointer denotes the translation of the glTF node with index 0 in glTF coordinate system.

* The `/nodes/1/rotation` pointer denotes the rotation quaternion of the glTF node with index 1 in glTF coordinate system using the glTF order of quaternion components, i.e., XYZW, where W is the scalar.

Both pointers are functional even if the nodes do not belong to the current glTF scene.

Implementations that import glTF assets into pre-existing scenes may need to maintain mappings between their internal objects and glTF objects defined in the asset. If the implementation's coordinate system is different from the one used in glTF, extra runtime conversions may be necessary for properties that depend on the XYZ axes.
====

When a behavior graph is loaded, all JSON Pointer Templates **MUST** be processed as described in the following sections. If a pointer template contains path segments wrapped in curly brackets, called _template parameters_, they define input value socket ids (with the curly brackets stripped) for the node. These template parameters **MUST NOT** be empty; the same parameter **MUST NOT** be used more than once within a template string. If used literally, curly brackets **MUST** be doubled, i.e, `{` **MUST** be written as `{{`, and `}` **MUST** be written as `}}` when used within path segments; curly brackets **MUST NOT** be used within parameters. Tilde (`~`) and forward slash (`/`) characters used in path segments or parameters **MUST** be encoded as `~0` and `~1` respectively as defined in <<rfc6901,RFC 6901>>.

[NOTE]
.Implementation Note
====
None of the glTF properties currently defined in Khronos specifications contain curly brackets, forward slash, or tilde in their names but such properties can exist in arbitrary glTF assets within vendor-specific extensions or `extras` objects.
====

When an Object Model Access node is activated, its JSON Pointer Template and input values (if present) are used to generate the effective JSON Pointer string value.

If the property being accessed is also affected by a currently active animation, the animation state **MUST** be applied before getting and/or setting the property value via pointers.

===== JSON Pointer Template Parsing

The input to these steps is the `pointer` string configuration value; the output includes a boolean validity flag and a template parameter array. Each template parameter array entry consists of a string representing the corresponding input value socket id and the parameter substring location (e.g., start and end offsets) in the JSON Pointer Template.

Implementations **MAY** optimize these steps as long as such optimizations do not change the output.

1. Let the validity flag be true and the template parameter array be empty.
2. If the pointer template string is not a syntactically valid JSON Pointer as defined in <<rfc6901,RFC 6901>> regardless of the pointer applicability to the glTF asset and/or template parameters, reject the pointer template string with a syntax error.
3. Split the pointer template string at all matches of the forward slash character (`/`, `0x2F`). This step produces a path segment array consisting of a substring before the first match, substrings between the matches, and a substring after the last match.
4. For each path segment substring produced during step 3:
.. If the path segment consists of a single left curly bracket (`{`, `0x7B`) character,
... set the validity flag to false, ignore all other segments, and goto step 5.
.. If the first character of the path segment substring is a left curly bracket and the second character is not a left curly bracket:
... Assume the path segment substring to be a template parameter.
... If the path segment substring contains left curly brackets not including the first character, right curly brackets (`}`, `0x7D`) not including the last character, if it does not end with a right curly bracket, or if there are no characters between the first and the last curly brackets (i.e., if the entire path segment substring is `{}`), set the validity flag to false, ignore all other segments, and goto step 5.
... Derive the input value socket id as follows:
.... Strip the first and the last characters, i.e., the leading left and trailing right curly brackets.
.... Replace all instances of `~1` with `/`.
.... Replace all instances of `~0` with `~`.
... If the template parameter array contains an element with the same value socket id, set the validity flag to false and goto step 5.
... Add a new entry to the template parameter array consisting of the derived input value socket id and the path segment substring location in the pointer template string.
.. If the first character of the path segment substring is not a left curly bracket or if the first two characters are left curly brackets:
... Assume the path segment substring to be a literal path segment, i.e., not a template parameter.
... If the path segment substring contains an odd number of consecutive left curly brackets or an odd number of consecutive right curly brackets, set the validity flag to false and goto step 5.
5. If the validity flag is true, output the parameter array; if the validity flag is false, reject the pointer template string with a syntax error.

[NOTE]
.Valid Syntax Examples
====
- The template string `"/myProperty"` is syntactically valid and has no template parameters. As it does not represent a recognized glTF Asset Object Model property, using this pointer will result in runtime errors defined by the corresponding nodes.

- The template string `"/nodes/0/scale"` is syntactically valid and has no template parameters thus it does not yield any input value socket ids.

- The template string `"/nodes/{index}/scale"` is syntactically valid and has one template parameter that yields an input value socket with id `index`.

- The template string `"/nodes/{index}/extras/{{index}}"` is syntactically valid and has one template parameter that yields an input value socket with id `index`. The curly brackets that are part of the `{index}` property name are doubled.

- The template string `"/nodes/{\~0~0index\~0~0}/rotation"` is syntactically valid and has one template parameter that yields an input value socket with id `\~~index~~`. The tilde characters used in the template parameter are encoded as `~0`.

- The template string `"/nodes/{my~1index}/scale"` is syntactically valid and has one template parameter that yields an input value socket with id `my/index`. The forward slash character used in the template parameter is encoded as `~1`.
====

[NOTE]
.Invalid Syntax Examples
====
- The template string `"/nodes/{index}/extras/~2"` is syntactically invalid because the `~2` character sequence is invalid in JSON Pointers, see <<rfc6901,RFC 6901>>.

- The template string `"/nodes/{index}/weights/{index}"` is syntactically invalid because it yields two input value sockets with the same id.

- The template string `"/nodes/{/scale"` is syntactically invalid because it contains a `{` path segment.

- The template string `"/nodes/{}/scale"` is syntactically invalid because the template parameter path segment has no characters between `{` and `}`.

- The template string `"/nodes/{index/scale"` is syntactically invalid because the template parameter path segment does not end with `}`.

- The template string `"/nodes/{i{ndex}/scale"` is syntactically invalid because the template parameter path segment contains a left curly bracket inside the parameter.

- The template string `"/nodes/{i}ndex}/scale"` is syntactically invalid because the template parameter path segment contains a right curly bracket inside the parameter.

- The template string `"/nodes/0/extras/{{i{ndex}}"` is syntactically invalid because a literal path segment has an odd number of consecutive left curly brackets.

- The template string `"/nodes/0/extras/{{index}"` is syntactically invalid because a literal path segment has an odd number of consecutive right curly brackets.
====

===== Effective JSON Pointer Generation

The inputs to these steps are the `pointer` configuration value, the template parameter array, and the corresponding input values provided at runtime by the behavior graph; the output is the effective JSON Pointer string that will be handled by the Object Model Access nodes. Implementations **MAY** optimize these steps as long as such optimizations do not change the output.

1. Assume that the `pointer` configuration value is syntactically valid.
2. Let _P_ be a copy of the `pointer` configuration value.
3. For each element of the template parameter array taken in the descending order of parameter substring locations:
.. Assert that the corresponding input socket value is not negative.
.. Convert the corresponding input socket value to its decimal string representation containing only ASCII characters `0x30 ... 0x39` with no extra leading zeros.
.. Update _P_ by replacing the template parameter substring, as identified by the template parameter location, with the decimal string value of the corresponding input value socket.
4. Update _P_ by replacing all occurrences of the `{{` substring in it with `{`.
5. Update _P_ by replacing all occurrences of the `}}` substring in it with `}`.
6. Output _P_ as the effective JSON Pointer string.

[NOTE]
.Examples
====
- Let the `pointer` configuration value be `"/nodes/{N}/weights/{W}"`. Then the nodes using this template pointer string have the `N` and `W` input value sockets. Let the runtime `N` value be 1 and the runtime `W` value be 2. Then the effective JSON Pointer is `"/nodes/1/weights/2"`.

- Let the `pointer` configuration value be `"/nodes/{index}/extras/{{index}}"`. Then the nodes using this template pointer string have the `index` input value socket. Let the runtime `index` value be 2. Then the effective JSON Pointer is `"/nodes/2/extras/{index}"`.
====

===== Pointer Get

[cols="1h,1,2"]
|===
| Operation | `pointer/get` | Get an object model property value
.2+| Configuration
d| `string pointer` | JSON Pointer Template
d| `int type`       | Property type index
| Input value sockets
| `int <parameter>` | Zero or more JSON Pointer template parameters to be evaluated at runtime; input value socket ids correspond to the pointer's path segments wrapped with curly brackets (`{}`)
.2+| Output value sockets
d| `T value`  | The resolved property value
d| `bool isValid`  | True if the property value can be resolved; false otherwise
|===

[CAUTION]
====
This node does not have a default configuration.
====

[CAUTION]
====
The configuration of this node affects its value sockets.
====

This node gets a glTF Asset Object Model property value using the effective JSON Pointer string derived from the JSON Pointer Template configuration value and the runtime values of the input value sockets.

The type `T` is determined by the `type` configuration value which points to the element of the <<json-types,`types`>> array. Input value socket ids are defined by parsing the JSON Pointer Template string as described above.

[NOTE]
.Examples
====
- If the `pointer` configuration value is `"/nodes/0/translation"`, the behavior graph node has no input value sockets and the pointer always refers to the `translation` property of the glTF node 0.

- If the `pointer` configuration value is `"/nodes/{myId}/scale"`, the behavior graph node has the `myId` input value socket, which value denotes the glTF node index.
====

If the `pointer` configuration value is not provided, if it is not a string, or if it is invalid (as defined in the previous sections), the node is invalid and the graph **MUST** be rejected.

If the `type` configuration value is not provided, if it is not a literal number, if it is not exactly representable as a 32-bit signed integer, if it is negative, or if it is greater than or equal to the length of the `types` array, the node is invalid and the graph **MUST** be rejected.

If the number of input value sockets derived from the pointer template string exceeds an implementation-specific limit on the maximum number of input value sockets, the graph **MUST** be rejected.

When this node is activated, i.e., when one of its output value sockets is being accessed:

1. Evaluate all input values.
2. If any of the input values is negative:
.. set the `isValid` output value to false;
.. set the `value` output value to the default value for the type `T`;
.. skip the next steps.
3. Generate the effective JSON Pointer as described in the previous sections.
4. If the effective JSON Pointer cannot be resolved against the glTF asset or if the Object Model type of the resolved property does not match the type `T`,
.. set the `isValid` output value to false;
.. set the `value` output value to the default value for the type `T`;
.. skip the next steps.
5. Set the `isValid` output value to true and the `value` output value to the value of the resolved glTF Asset Object Model property.

Pointers containing `extras` properties are out of scope of this specification but **MAY** be supported by implementations.

[NOTE]
.Examples
====
- If the `pointer` configuration value is `"/nodes/{myId}/scale"`, the type `T` is `float3`, and the `myId` input value is negative or greater than or equal to the total number of glTF nodes, then the `isValid` output value is false and the `value` output value is `[NaN, NaN, NaN]`.

- If the `pointer` configuration value is `"/nodes/{myId}/scale"` and the type `T` is `float4`, then the `isValid` output value is false and the `value` output value is `[NaN, NaN, NaN, NaN]`. Note that `myId` input value becomes irrelevant in this case because even if it is valid the Object Model property type does not match the declared type `T`.
====

[NOTE]
.Authoring Note
====
The `/meshes/{}/weights` and `/nodes/{}/weights` pointers defined in the glTF Asset Object Model have the `float[]` type that is not supported by this extension. Any `pointer/get` node using those pointers would always have its `isValid` output value as false.
====

===== Pointer Set

[cols="1h,1,2"]
|===
| Operation | `pointer/set` | Set an object model property value
.2+| Configuration
d| `string pointer` | JSON Pointer Template
d| `int type`       | Property type index
| Input flow sockets
| `in` | The entry flow into this node
.2+| Input value sockets
d| `int <parameter>` | Zero or more JSON Pointer template parameters to be evaluated at runtime; input value socket ids correspond to the pointer's path segments wrapped with curly brackets (`{}`)
d| `T value` | The new property value
.2+| Output flow sockets
d| `out` | The flow to be activated if the property was set
d| `err` | The flow to be activated if the property was not set
|===

[CAUTION]
====
This node does not have a default configuration.
====

[CAUTION]
====
The configuration of this node affects its value sockets.
====

This node sets a glTF Asset Object Model property value using the effective JSON Pointer string derived from the JSON Pointer Template configuration value and the runtime values of the `<parameter>` input value sockets.

The type `T` is determined by the `type` configuration value which points to the element of the <<json-types,`types`>> array. Input value socket ids are defined by parsing the JSON Pointer Template string as described above.

If the `pointer` configuration value is not provided, if it is not a string, if it is invalid (as defined in the previous sections), or if it contains a template parameter `{value}`, the node is invalid and the graph **MUST** be rejected.

If the `type` configuration value is not provided, if it is not a literal number, if it is not exactly representable as a 32-bit signed integer, if it is negative, or if it is greater than or equal to the length of the `types` array, the node is invalid and the graph **MUST** be rejected.

If the number of input value sockets derived from the pointer template string plus one exceeds an implementation-specific limit on the maximum number of input value sockets, the graph **MUST** be rejected.

If the `value` input value is not valid for the resolved property, the effective property value becomes implementation-defined and subsequent `pointer/get` evaluations of the property **MAY** return any value of the corresponding type until the property is updated with a valid value. This is not an error. Implementations **MAY** generate runtime warnings in this case as deemed possible.

[NOTE]
.Example
====
If the resolved glTF property is `"/materials/0/emissiveFactor"` and it is being set to `[1, 2, 3]`, the effective emissive factor becomes undefined. Querying it afterwards with `pointer/get` could return any `float3` value including but not limited to `[0, 0, 0]`, `[1, 1, 1]`, `[1, 2, 3]`, or `[NaN, NaN, NaN]`.
====

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate all input values.
2. If any of the `<parameter>` input values is negative,
.. activate the `err` output flow and skip the next steps.
3. Generate the effective JSON Pointer as described in the previous sections.
4. If the effective JSON Pointer cannot be resolved against the glTF asset, if the Object Model type of the resolved property does not match the type `T`, or if the property is not mutable,
.. activate the `err` output flow and skip the next steps.
5. If the _pointer interpolation state dynamic array_ (defined in the next section) contains an entry with the effective JSON Pointer,
.. remove the entry from the array.
6. Set the resolved glTF Asset Object Model property to the `value` input value.
7. Activate the `out` output flow.

[NOTE]
.Authoring Note
====
The `/meshes/{}/weights` and `/nodes/{}/weights` pointers defined in the glTF Asset Object Model have the `float[]` type that is not supported by this extension. Any `pointer/set` node using those pointers would always activate only its `err` output flow.
====

===== Pointer Interpolate

[cols="1h,1,2"]
|===
| Operation | `pointer/interpolate` | Interpolate an object model property value
.2+| Configuration
d| `string pointer` | JSON Pointer Template
d| `int type`       | Property type index
| Input flow sockets
| `in` | The entry flow into this node
.5+| Input value sockets
d| `int <parameter>` | Zero or more JSON Pointer template parameters to be evaluated at runtime; input value socket ids correspond to the pointer's path segments wrapped with curly brackets (`{}`)
d| `T value` | The target property value
d| `float duration` | The time, in seconds, in which the property **SHOULD** reach the target value
d| `float2 p1` | Control point P1
d| `float2 p2` | Control point P2
.3+| Output flow sockets
d| `out` | The flow to be activated if the property interpolation has been started
d| `err` | The flow to be activated if the property interpolation has not been started
d| `done` | The flow to be activated after the property reaches the target value
|===

[CAUTION]
====
This node does not have a default configuration.
====

[CAUTION]
====
The configuration of this node affects its value sockets.
====

This node interpolates and updates the glTF Asset Object Model property multiple times over the specified duration using the effective JSON Pointer string derived from the JSON Pointer Template configuration value, the runtime values of the `<parameter>` input value sockets, and several interpolation inputs.

The type `T` is determined by the `type` configuration value which points to the element of the <<json-types,`types`>> array. Input value socket ids are defined by parsing the JSON Pointer Template string as described above.

If the `pointer` configuration value is not provided, if it is not a string, if it is invalid (as defined in the previous sections), or if it contains template parameters `{value}`, `{duration}`, `{p1}`, or `{p2}` the node is invalid and the graph **MUST** be rejected.

If the `type` configuration value is not provided, if it is not a literal number, if it is not exactly representable as a 32-bit signed integer, if it is negative, if it is greater than or equal to the length of the `types` array, or if it point to the type entry with `bool` or `int` type signatures, the node is invalid and the graph **MUST** be rejected.

If the number of input value sockets derived from the pointer template string plus four exceeds an implementation-specific limit on the maximum number of input value sockets, the graph **MUST** be rejected.

If the `value` input value or any intermediate interpolated value are not valid for the resolved property, the effective property value becomes implementation-defined and subsequent `pointer/get` evaluations of the property **MAY** return any value of the corresponding type until the property is updated with a valid value. This is not an error. Implementations **MAY** generate runtime warnings in this case as deemed possible.

[NOTE]
.Example
====
If the resolved glTF property is `"/materials/0/pbrMetallicRoughness/metallicFactor"`, its current value is zero, and the interpolation target value is two, the effective metalness factor becomes undefined when the interpolated value is greater than one.
====

If the current glTF Asset Object Model property value is already undefined due to previous invocations of `pointer/set` or `pointer/interpolate` nodes with invalid values (as defined above), the interpolated property remains undefined during and after the interpolation. This is not an error. Implementations **MAY** generate runtime warnings in this case as deemed possible.

This node has no internal state.

When a `pointer/interpolate` node is used in the behavior graph, the global graph state includes an implementation-defined _pointer interpolation state dynamic array_ each element of which contains the following data:

- The resolved JSON Pointer to the Object Model property being interpolated
- Implementation-defined high precision timestamp value representing the interpolation start time
- Interpolation duration value converted to the implementation-defined high precision time type
- Object Model property value at the time of the successful node activation
- Information needed for cubic Bézier spline evaluation derived from the node's input values
- Target property value
- Implementation-specific pointer to the `done` output flow of the node that has added this entry

This array is initially empty and its maximum size is implementation-specific.

When the `in` input flow is activated:

1. Evaluate all input values.
2. If any of the `<parameter>` input values is negative,
.. activate the `err` output flow and skip the next steps.
3. Generate the effective JSON Pointer as described in the previous sections.
4. If the effective JSON Pointer cannot be resolved against the glTF asset, if the Object Model type of the resolved property does not match the type `T`, or if the property is not mutable,
.. activate the `err` output flow and skip the next steps.
5. If the `duration` input value is NaN, infinite, negative, or greater than the maximum property interpolation duration supported by the implementation,
.. activate the `err` output flow and skip the next steps.
6. If any component of the `p1` or `p2` input values is NaN or infinite or if any of the first components of these input values is negative or greater than 1,
.. activate the `err` output flow and skip the next steps.
7. If starting a new pointer interpolation exceeds an implementation-specific limit on the maximum number of simultaneous property interpolations,
.. activate the `err` output flow and skip the next steps.
8. If the _pointer interpolation state dynamic array_ contains an entry with the same effective JSON Pointer value,
.. remove it from the array.
9. Using the implicitly-defined end points stem:[P_0 (0, 0)] and stem:[P_3 (1, 1)] together with the control points stem:[P_1] and stem:[P_2] provided via the input values construct a cubic Bézier easing function for the stem:[[0, 1]] input range.
10. Add a new entry to the _pointer interpolation state dynamic array_ filling it with the required information based on the evaluated input values.
11. Activate the `out` output flow.

On each tick, for each entry in the _pointer interpolation state dynamic array_:

1. Compute the current input progress position _t_ as the time passed since the interpolation start divided by the interpolation's duration.
2. If _t_ is less than or equal to zero,
.. skip the next steps.
3. If _t_ is NaN or greater than or equal to 1,
.. set the target property to the target value;
.. remove the current entry from the _pointer interpolation state dynamic array_;
.. activate the `done` output flow linked to the current entry;
.. skip the next steps.
4. Using the cubic Bézier spline information, compute the output progress position _q_ based on the _t_ value. This step implies that latexmath:[t \in (0; 1)].
5. Set the glTF Asset Object Model property to the new value computed as a linear interpolation between the original and the target property values using the output progress position _q_ as the interpolation coefficient. If the glTF Asset Object Model property is a quaternion, e.g., `/nodes/0/rotation`, spherical linear interpolation **MUST** be used.

[NOTE]
.Authoring Note
====
Certain control point values can cause the intermediate output progress value to be negative or greater than one. This is not an error.
====

[NOTE]
.Authoring Note
====
The `/meshes/{}/weights` and `/nodes/{}/weights` pointers defined in the glTF Asset Object Model have the `float[]` type that is not supported by this extension. Any `pointer/interpolate` node using those pointers would always activate only its `err` output flow.
====

==== Animation Control Nodes

===== Animation Start

[cols="1h,1,2"]
|===
| Operation | `animation/start` | Start playing an animation
| Input flow sockets
| `in` | The entry flow into this node
.4+| Input value sockets
d| `int animation` | Animation index
d| `float startTime` | Start time in seconds
d| `float endTime` | End time in seconds
d| `float speed` | Speed multiplier
.3+| Output flow sockets
d| `out` | The flow to be activated if the input values are valid
d| `err` | The flow to be activated if any of the input values is invalid
d| `done` | The flow to be activated after the animation ends
|===

This node starts playing an animation using the specified input values.

For the purposes of the Animation Control Nodes the concept of glTF animations is extended to unambiguously map any _requested input timestamp_ stem:[r] to the _effective input timestamp_ stem:[t] present in the glTF animation data as follows.

1. Let stem:[T] be the maximum value of all animation sampler input accessors of the animation. Then, the stored animation data defines the animated property values for all _effective input timestamps_ in the stem:[[0, T]] range.
2. Let stem:[r] be a scalar value on a timeline infinite in both directions, from negative infinity to positive infinity.
3. If stem:[T] is not equal to zero, let stem:[s] be the current iteration number computed as follows:
latexmath:[s=\begin{cases}
            \left\lceil \dfrac{r-T}{T} \right\rceil & \text{if } r \gt 0 \\
            \left\lfloor \dfrac{r}{T} \right\rfloor & \text{if } r \le 0 \\
           \end{cases}]
4. Now for each _requested input timestamp_ stem:[r], the corresponding _effective input timestamp_ is
latexmath:[t=\begin{cases}
            r - s * T & \text{if } T \ne 0 \\
            0 & \text{if } T=0 \\
           \end{cases}]

[TIP]
.Authoring Tip
====
The `/animations/{}/extensions/KHR_interactivity/maxTime` virtual property can be used to query the value of stem:[T] for a given animation. By setting the `endTime` input value socket to that value, the graph can play the animation to completion without statically knowing its duration.
====

This node has no internal state.

When an `animation/start` node is used in the behavior graph, the global graph state includes an implementation-defined _animation state dynamic array_ each element of which contains the following data:

- Animation index
- Start time value
- End time value
- Stop time value (see `animation/stopAt`)
- Speed value
- Implementation-specific _entry creation_ timestamp value associated with the system time when this entry was added
- Implementation-specific _end completion_ pointer to the `done` output flow of the node that has added this entry
- Implementation-specific _stop completion_ pointer to the `done` output flow of the node that has scheduled its stopping (see `animation/stopAt`)

This array is initially empty; its maximum size is implementation-specific.

When the `in` input flow is activated:

1. Evaluate all input values.
2. If the `animation` input value is negative or greater than or equal to the number of glTF animations in the asset,
.. activate the `err` output flow and skip the next steps.
3. If the `startTime` or `endTime` input values are NaN or if the `startTime` input value is infinite,
.. activate the `err` output flow and skip the next steps.
4. If the `speed` input value is NaN, infinite, or less than or equal to zero,
.. activate the `err` output flow and skip the next steps.
5. If starting a new animation exceeds an implementation-specific limit on the maximum number of active animations or if the referenced glTF animation is invalid as determined by the implementation,
.. activate the `err` output flow and skip the next steps.
6. If the _animation state dynamic array_ contains an entry with the same animation index,
.. remove it from the array; the previously set `done` flows **MUST NOT** be activated.
7. Add a new entry to the _animation state dynamic array_ filling it with the required information based on the evaluated input values. The stop time value **MUST** be set to the end time value and the stop completion pointer **MUST** be set to null.
8. Activate the `out` output flow.

On each asset animation update, for each entry in the _animation state dynamic array_:

1. If the _start time_ is equal to the _end time_,
.. let the requested timestamp stem:[r] be equal to the _start time_;
.. compute the effective timestamp stem:[t] from stem:[r] as defined above and apply the glTF animation state at the timestamp stem:[t] to the asset;
.. let `endDone` be the _end completion_ pointer stored in the current animation state entry;
.. remove the current animation state entry from the array;
.. activate the `done` output flow referenced by the `endDone` pointer;
.. skip the next steps.
2. Let the _elapsed time_ be the non-negative difference between _entry creation_ timestamp and the current system time; this step assumes that the current system time is not behind the _entry creation_ timestamp.
3. Let the _scaled elapsed time_ be the product of the _elapsed time_ and the _animation speed_ value; if the _start time_ is greater than the _end time_, negate the _scaled elapsed time_ value.
4. Let the _current timestamp_ be the sum of the _start time_ and the _scaled elapsed time_.
5. If the _start time_ is less than the _end time_, the _current timestamp_ is greater than or equal to the _stop time_, the _stop time_ is greater than or equal to the _start time_, and the _stop time_ is less than the _end time_; or if the _start time_ is greater than the _end time_, the _current timestamp_ is less than or equal to the _stop time_, the _stop time_ is less than or equal to the _start time_, and the _stop time_ is greater than the _end time_:
... let the requested timestamp stem:[r] be equal to the _stop time_;
... compute the effective timestamp stem:[t] from stem:[r] as defined above and apply the glTF animation state at the timestamp stem:[t] to the asset;
... let `stopDone` be the _stop completion_ pointer stored in the current animation state entry;
... remove the current animation state entry from the array;
... activate the `done` output flow referenced by the `stopDone` pointer;
... skip the next steps.
6. If the _start time_ is less than the _end time_ and the _current timestamp_ is greater than or equal to the _end time_; or if the _start time_ is greater than the _end time_ and the _current timestamp_ is less than or equal to the _end time_:
... let the requested timestamp stem:[r] be equal to the _end time_;
... compute the effective timestamp stem:[t] from stem:[r] as defined above and apply the glTF animation state at the timestamp stem:[t] to the asset;
... let `endDone` be the end completion pointer stored in the current animation state entry;
... remove the current animation state entry from the array;
... activate the `done` output flow referenced by the `endDone` pointer;
... skip the next steps.
7. Let the requested timestamp stem:[r] be equal to the _current timestamp_.
8. Compute the effective timestamp stem:[t] from stem:[r] as defined above and apply the glTF animation state at the timestamp stem:[t] to the asset.

If two or more active animations target the same glTF property, it becomes undefined and remains undefined as long as the number of active animations affecting it is greater than one.

[NOTE]
.Example
====
Let's say an asset has two animations that target position of the node zero. The first animation lasts 15 seconds and the second animation lasts 5 seconds. The graph starts the first animation, waits 5 seconds, then starts the second animation. Both animations are played to completion once.

During the first 5 seconds, the position of the node zero is well-defined. It is repeatedly updated by the first animation and could be reliably queried with a `pointer/get` operation.

During the next 5 seconds (i.e., when both animations are active) the position of the node zero is undefined. Since both animations try to update it at the same time, querying the property with a `pointer/get` operation could return arbitrary values. However, using a `pointer/set` operation on that property would make it well-defined until the next animation update.

During the last 5 seconds, the position of the node zero is well-defined again.
====

===== Animation Stop

[cols="1h,1,2"]
|===
| Operation | `animation/stop` | Immediately stop a playing animation
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `int animation` | Animation index
.2+| Output flow sockets
d| `out` | The flow to be activated if the animation index is valid
d| `err` | The flow to be activated if the animation index is invalid
|===

This node stops a playing animation.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate all input values.
2. If the `animation` input value is negative or greater than or equal to the number of glTF animations in the asset,
.. activate the `err` output flow and skip the next steps.
3. If the _animation state dynamic array_ exists and contains an entry with the same animation index,
.. remove it from the array and stop the playing animation. The animated properties **MUST** keep their current values and the previously associated `done` flows **MUST NOT** be activated.
4. Activate the `out` output flow.

===== Animation Stop At

[cols="1h,1,2"]
|===
| Operation | `animation/stopAt` | Schedule stopping a playing animation
| Input flow sockets
| `in` | The entry flow into this node
.2+| Input value sockets
d| `int animation` | Animation index
d| `float stopTime` | Stop time in seconds
.3+| Output flow sockets
d| `out` | The flow to be activated if the input values are valid
d| `err` | The flow to be activated if any of the input values is invalid
d| `done` | The flow to be activated after the animation stops
|===

This node stops a playing animation.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate all input values.
2. If the `animation` input value is negative or greater than or equal to the number of glTF animations in the asset,
.. activate the `err` output flow and skip the next steps.
3. If the `stopTime` input value is NaN,
.. activate the `err` output flow and skip the next steps.
4. If the _animation state dynamic array_ exists and does contain an entry with the same animation index,
.. update the entry's _stop completion_ pointer to the `done` output flow of this node;
.. update the entry's _stop time_ to the `stopTime` input value.
5. Activate the `out` output flow.

=== Event Nodes

==== Lifecycle Event Nodes

===== On Start

[cols="1h,1,2"]
|===
| Operation | `event/onStart` | Start event
| Output flow sockets
| `out`  | The flow to be activated when the start event happens
|===

This node is activated when all glTF asset resources are loaded and ready for rendering and interactions.

This node has no internal state.

If multiple instances of this node exist in the graph, they **MUST** be activated sequentially in the order they appear in JSON.

===== On Tick

[cols="1h,1,2"]
|===
| Operation | `event/onTick` | Tick event
.2+| Output value sockets
d| `float timeSinceStart` | Relative time in seconds since the graph execution start
d| `float timeSinceLastTick` | Relative time in seconds since the last tick occurred
| Output flow sockets
| `out` | The flow to be activated when the tick event happens
|===

This node is activated when a tick occurs. There will be at most one tick per rendered frame, which **SHOULD** align with frame time, but there are no guarantees of time elapsed between ticks.

The internal state of this node consists of two floating-point time values initialized to NaN. They **MUST** be set to their effective values before the `out` output flow is activated.

The first activation of this node **MUST** happen after activating all instances of `event/onStart` if the latter is present in the graph.

On the first activation of this node, the `timeSinceStart` output value **MUST** be set to zero and the `timeSinceLastTick` output value **MUST** remain NaN.

If multiple instances of this node exist in the graph, they **MUST** be activated sequentially in the order they appear in JSON and they **MUST** have the same output values within the same tick.

==== Custom Event Nodes

===== Receive

[cols="1h,1,2"]
|===
| Operation | `event/receive` | Receive a custom event
| Configuration
| `int event` | The custom event index
| Output value sockets
| `<custom>` | Output values defined by the custom event
| Output flow sockets
| `out` | The flow to be activated when the custom event happens
|===

[CAUTION]
====
This node does not have a default configuration.
====

[CAUTION]
====
The configuration of this node affects its value sockets.
====

This node is activated when a custom event specified by the `event` configuration value occurs. The types, ids, and semantics of the output value sockets are defined by the custom event index.

The `event` configuration value **MUST** be non-negative and less than the total number of custom event definitions, otherwise the node is invalid and the graph **MUST** be rejected.

The internal state of this node consists of all output value sockets initialized to <<variables-types,type-default>> values or to the initial values defined by the custom event index. If the event is originated by an external environment, output values not set by the external environment **MUST** be reset to type-default or initial values on each node activation.

[NOTE]
.Example
====
Let's say an event has two value sockets: `a` and `b`; before the first activation, they have initial or type-default values. Let's say the external environment generates this event and sets only the output value `a`. The output value `b` then retains its initial or type-default value. Now if the external environment generates this event again but sets only the output value `b`, the output value `a` is reset to its initial or type-default value.
====

If multiple instances of this node with the same event index exist in the graph, they **MUST** be activated sequentially in the order they appear in JSON and they **MUST** have the same output values within the same event occurrence.

===== Send

[cols="1h,1,2"]
|===
| Operation | `event/send` | Send a custom event
| Configuration
| `int event` | The custom event index
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `<custom>` | Input values defined by the custom event
| Output flow sockets
| `out` | The flow to be activated after sending the event
|===

[CAUTION]
====
This node does not have a default configuration.
====

[CAUTION]
====
The configuration of this node affects its value sockets.
====

This node sends a custom event specified by the `event` configuration value. The types and ids of the input value sockets are defined by the custom event index.

[TIP]
.Authoring Tip
====
If the graph needs to know whether the event has been received and/or processed by an external environment, the latter could send another event in response.
====

The `event` configuration value **MUST** be non-negative and less than the total number of custom event definitions, otherwise the node is invalid and the graph **MUST** be rejected.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate all input values.
2. Send the custom event.
3. Activate the `out` output flow.

=== Debug Nodes

==== Debug Output Nodes

===== Log

[cols="1h,1,2"]
|===
| Operation | `debug/log` | Output a debug message
.2+| Configuration
d| `int severity` | Message severity
d| `string message` | Message template
| Input flow sockets
| `in` | The entry flow into this node
| Input value sockets
| `<any> <parameter>` | Zero or more message template parameters to be evaluated at runtime; input value socket ids correspond to the message substrings wrapped with curly brackets (`{}`)
| Output flow sockets
| `out` | The flow to be activated after the message was logged
|===

[CAUTION]
====
The configuration of this node affects its value sockets.
====

This node builds a debug message from the specified template string and input socket values as described below and outputs the message to the user in an implementation-defined manner.

The `severity` configuration value is intended for filtering messages based on the implementation configuration. The `message` configuration value contains the debug message template string that defines the user-facing text message and input value socket ids (if any).

The value socket ids are substrings of the `message` value wrapped with curly brackets (`{}`); they are extracted as described below. Literal curly brackets present in the message template string **MUST** be doubled.

The type `any` represents any value socket type including custom types. This nodes implies that all value types have implementation-defined string representations.

In the default configuration, the `severity` configuration value is zero, the `message` configuration string is empty, and the node has no input value sockets.

If the `severity` configuration property is not provided by the behavior graph, if it is not a literal number, or if its value is not exactly representable as a 32-bit signed integer, the default configuration **MUST** be used.

[TIP]
.Implementation Tip
====
The integer representation check is implementable in ECMAScript via the following expression:
[source,js]
----
s === (s | 0)
----
====

If the `message` configuration property is not provided by the behavior graph, if it is not a literal string, or if its value is not syntactically valid as described below, the default configuration **MUST** be used.

The following procedure outputs input value socket id locations within the `message` configuration string and returns whether the string is syntactically valid:

1. Let _state_ be a temporary integer variable initialized to zero. During the procedure execution, its value will always be one of 0, 1, 2, or 3.
2. Let _paramStart_ be a temporary integer variable initialized to unspecified value.
3. Let `M[i]` be the character (Unicode code point) of the `message` configuration string at the position `i` (zero-based).
4. For `i` from zero (inclusive) to the `message` length (exclusive), do:
.. If `M[i]` is `"{"` (without quotes):
... If _state_ is 0, set _state_ to 1;
... else if _state_ is 1, set _state_ to 0;
... else (if _state_ is 2 or 3) return false.
.. Else if `M[i]` is `"}"` (without quotes):
... If _state_ is 0, set _state_ to 3;
... else if _state_ is 3, set _state_ to 0;
... else if _state_ is 2,
.... output the (_paramStart_, `i`) tuple as the inclusive range defining the template parameter location in the `message` string;
.... set _state_ to 0;
... else (if _state_ is 1) return false.
.. Else if `M[i]` is neither `"{"` nor `"}"` (without quotes):
... If _state_ is 1,
.... set _paramStart_ to `i - 1`;
.... set _state_ to 2;
... else if _state_ is 3, return false.
5. If _state_ is not 0, return false.
6. Return true.

If the procedure above returns false, the `message` configuration string is invalid and the default configuration is used. If the procedure above returns true, node's input value socket ids match the substrings identified by the template parameter locations with curly brackets removed.

Extra input value sockets with ids not present in the output of the procedure above do not affect the node's operation and validation but they still **MUST** have valid types and value sources.

This node has no internal state.

When the `in` input flow is activated:

1. Evaluate all input values.
2. Generate the effective message string as follows.
.. Let _M_ be a copy of the `message` configuration value.
.. For each element of the template parameter array taken in the descending order of parameter substring locations:
... Convert the corresponding input socket value to its string representation.
... If the string representation of the input socket value contains curly brackets, they **MUST** be doubled.
... Update _M_ by replacing the template parameter substring, as identified by the template parameter location, with the string representation of the corresponding input value socket. Note that the same template parameter **MAY** appear at multiple locations.
.. Update _M_ by replacing all occurrences of the `"{{"` substring in it with `"{"` (without quotes).
.. Update _M_ by replacing all occurrences of the `"}}"` substring in it with `"}"` (without quotes).
3. Output _M_ as the effective message string.
4. Activate the `out` output flow.

== Extending glTF Object Model

This Specification defines additional glTF Object Model pointers for use with `pointer/*` nodes.

=== Implementation-Specific Runtime Limits

TBD

=== Active Camera State

In some viewers, such as, but not limited to, augmented reality viewers and virtual reality viewers, the viewer implementation gives the user direct control over a virtual camera. This virtual camera **MAY** be controlled by user head movements, by movements of the user's phone with their hands, or by mouse, keyboard or touch input on a laptop, or by other means. It is useful for interactivity to be able to react to the position of this virtual camera.

This Specification defines the “active camera” as the camera transformation that ought to be reacted to by interactivity. When there is only one camera being displayed to the user the implementation **SHOULD** use this camera as the “active camera”. When there are multiple cameras being controlled by the user, the implementation **MAY** select one such camera or construct a synthetic camera to use as the “active camera” (for example the midpoint of two stereoscopic camera positions). When zero cameras are being controlled by the user but views from one or more cameras are being displayed to the user, the implementation **SHOULD** select one of the cameras that is being displayed as the “active camera”.

The `position` read-only property represents the “active camera” position in the global space using the glTF coordinate system. The `rotation` read-only property represents the “active camera” rotation quaternion (using XYZW notation); the identity quaternion corresponds to the camera orientation defined in the glTF 2.0 Specification.

An implementation **MAY** provide no “active camera” data, for example for privacy reasons or if no cameras are being displayed to the user. If the “active camera” position is unavailable, the `position` property **MUST** be set to all NaNs; if the “active camera” rotation is unavailable, the `rotation` property **MUST** be set to all NaNs.

The following pointers represent the properties defined in this section.

[options="header",cols="50%,15%"]
|===
| Pointer                                               | Type
| `/extensions/KHR_interactivity/activeCamera/rotation` | `float4`
| `/extensions/KHR_interactivity/activeCamera/position` | `float3`
|===

=== Animation State

To efficiently control animations, graphs usually need to access various states specific to glTF animation objects. The interactivity extension adds the following five runtime properties to the glTF animation objects.

The `isPlaying` read-only property is true when the animation is playing, false otherwise.

The `minTime` and `maxTime` read-only properties represent the timestamps of the first and the last keyframes as stored in the glTF animation object. The values **MUST** be derived from the `min` and `max` properties of the used sampler input accessors. Unused animation samplers, i.e., samplers not referenced by the animation channels, **MUST** be ignored. If the animation object is invalid as defined in the core glTF 2.0 specification, these properties **MUST** return NaNs.

[TIP]
.Authoring Tip
====
As defined in the base glTF 2.0 specification, animated properties are snapped to the closest keyframes if the requested timestamp is between zero and the timestamp of the first available keyframe. The `minTime` property could be used to query the timestamp of the animation's earliest keyframe data and start the animation from that point if the initial delay potentially present in the animation data needs to be skipped.
====

The `playhead` read-only property represents the current animation position within the glTF animation data. For valid glTF animations, the property value is equal to the last effective timestamp, so it is always greater than or equal to zero and less than or equal to `maxTime`. Before the animation start, this property value is zero; when the animation stops, the property retains its last value until the animation is restarted. For invalid glTF animations, the property value is always NaN.

The `virtualPlayhead` read-only property represents the current animation position on the infinite timeline that is used for the input value sockets of the `animation/start` and `animation/stop` operations. For valid glTF animations, the property value is equal to the last requested timestamp. Before the animation start, this property is zero; when the animation stops, the property value retains its last value until the animation is restarted. For invalid glTF animations, the property value is always NaN.

The following pointers represent the properties defined in this section.

[options="header",cols="50%,15%"]
|===
| Pointer                                                       | Type
| `/animations/{}/extensions/KHR_interactivity/isPlaying`       | `bool`
| `/animations/{}/extensions/KHR_interactivity/minTime`         | `float`
| `/animations/{}/extensions/KHR_interactivity/maxTime`         | `float`
| `/animations/{}/extensions/KHR_interactivity/playhead`        | `float`
| `/animations/{}/extensions/KHR_interactivity/virtualPlayhead` | `float`
|===

= JSON Syntax

[[json-general]]
==  General

A `KHR_interactivity` extension object is added to the root-level `extensions` property. It contains an array of interactivity graphs each element of which contains five arrays corresponding to five interactivity concepts: `types`, `variables`, `events`, `declarations`, and `nodes`, and an optional `graph` property that selects the default graph to use.

Different elements of the `graphs` array are completely isolated from each other and exist in separate scopes. One invalid graph does not invalidate other elements of the `graphs` array.

As with the core glTF spec, if a JSON array is empty, it **MUST** be omitted from JSON.

```javascript
{
  "asset": {
    "version": "2.0"
  },
  "extensionsUsed": [ "KHR_interactivity" ],
  "extensions": {
    "KHR_interactivity": {
      "graphs": [
        {
          "types": [
            //
          ],
          "variables": [
            //
          ],
          "events": [
            //
          ],
          "declarations": [
            //
          ],
          "nodes": [
            //
          ]
        }
      ],
      "graph": 0
    }
  }
}
```

The `graph` property refers to the `graphs` array element that **SHOULD** be selected by default by the execution environment. If the `graph` property is undefined, its value is implicitly set to zero. If the `graph` property is negative or greater than the number of elements in the `graphs` array, the interactivity extension object is invalid.

If the currently selected graph is invalid or if the interactivity extension object is invalid, implementations **MAY** treat the asset as not having interactivity at all.

[[json-types]]
== Types

The `types` array defines mappings between type indices used by the graph and the recognized type signatures. Each entry in this array denotes a distinct type.

[NOTE]
.Example
====
This example defines type `0` as *float2*, type `1` as *int*, and type `2` as *float*:

```json
"types": [
  { "signature": "float2" },
  { "signature": "int" },
  { "signature": "float" }
]
```
====

The value of the `signature` property **MUST** be one of the value types defined in this extension specification or `"custom"`. In the latter case, the custom type semantics **MUST** be provided by an additional extension.

Values of the `signature` property are case-sensitive.

Non-custom signatures **MUST NOT** appear more than once in this array; if two or more entries of the `types` array have the same non-custom signature, the graph is invalid and **MUST** be rejected. Extensions or extras present on the types defined by this Specification do not change type semantics.

[NOTE]
.Example
====
This means that, for example, two entries with the signature `"int"` are still disallowed even if they have extensions and/or extras.
====

[[json-variables]]
== Variables

The `variables` array defines variables with their types and optional initial values.

[NOTE]
.Example
====
This example defines two variables of `float2` type; the first is explicitly initialized to `[0.5, 0.5]` and the second is implicitly initialized to `[NaN, NaN]`.

```json
"types": [
  { "signature": "float2" }
],
"variables": [
  {
    "type": 0,
    "value": [ 0.5, 0.5 ]
  },
  {
    "type": 0
  }
]
```
====

The type of the variable is determined by the **REQUIRED** `type` property that points to the element of the `types` array. If the `type` property is undefined or its value is negative or greater than or equal to the length of the `types` array`, the variable is invalid and the graph **MUST** be rejected.

The `value` property is an array that defines the initial variable value. If the `value` property is undefined, the variable is initialized to the default value of its type. The following table defines array lengths and default values for all value types defined in this Specification.

[cols="1,1,2", options="header"]
|===
|  Type      | Array length | Default value
| `bool`     |            1 | Boolean false
| `float`    |            1 | Floating-point NaN
| `float2`   |            2 | Two floating-point NaNs
| `float3`   |            3 | Three floating-point NaNs
| `float4`   |            4 | Four floating-point NaN
| `float2x2` |            4 | Four floating-point NaNs
| `float3x3` |            9 | Nine floating-point NaNs
| `float4x4` |           16 | Sixteen floating-point NaNs
| `int`      |            1 | Integer zero
|===

Values for vector types use the XYZW order of components, that is X component is stored in the array element with index 0, Y component is stored in the array element with index 1, and so forth.

Values for matrix types use the column-major order of elements. For example, elements of a 2x2 matrix are stored as `[c0r0, c0r1, c1r0, c1r1]`, where `c0r0` is the element in the first column and first row, `c0r1` is the element in the first column and second row, and so forth.

If the `value` property array length does not match the array length for the specified type, the variable is invalid and the graph **MUST** be rejected.

If the variable type is **bool** and the only array element is not a JSON boolean literal, i.e., neither `true` nor `false`, the variable is invalid and the graph **MUST** be rejected.

If the variable type is any of the **floatN** or **floatNxN** types and any of the array elements is not a JSON number, the variable is invalid and the graph **MUST** be rejected.

If the variable type is **int** and the only array element is not a JSON number exactly representable as a 32-bit signed integer, the variable is invalid and the graph **MUST** be rejected.

If the variable type is custom, the `value` property is defined by the extension defining the custom type.

[[json-events]]
== Events

The `events` array defines external ids and value sockets for custom events.

[NOTE]
.Example
====
This example defines two custom events. The first event is internal to the graph and has no value sockets; the second event has an external id `"checkout"` and one integer value socket with id `"variant"` and an initial value of -1.

```json
"types": [
  { "signature": "int" }
],
"events": [
  { },
  {
    "id": "checkout",
    "values": {
      "variant": {
        "type": 0,
        "value": [ -1 ]
      }
    }
  }
]
```
====

The event id is an application-specific event identifier recognized by the execution environment. If the `id` property is undefined, the event is considered internal to the graph. If the same id is defined for two or more events, the graph is invalid and **MUST** be rejected.

The properties of the `values` object define ids and the values of those properties define types and optional initial values of the value sockets associated with the event. If the `values` object is undefined, the event has no associated value sockets.

Socket ids defined by the properties of the `values` object are case-sensitive.

The type of the event value socket is determined by the **REQUIRED** `type` property that points to the element of the `types` array. If the `type` property is undefined or its value is negative or greater than or equal to the length of the `types` array, the event is invalid and the graph **MUST** be rejected.

The `value` property of the event value socket has the same syntax and semantics as the `value` property of variable definitions (see the previous section).

[[json-declarations]]
== Declarations

The `declarations` array defines mappings between node declaration indices used by the graph and the operations.

[NOTE]
.Example
====
This example defines declaration `0` as `math/min` and declaration `1` as `variable/set`.

```json
"declarations": [
  { "op": "math/min" },
  { "op": "variable/set" }
]
```
====

The `op` property is **REQUIRED**; it contains the operation identifier; if this property is undefined, the declaration is invalid and the graph **MUST** be rejected.

Values of the `op` property are case-sensitive.

If the operation is not defined by this Specification, the `extension` property **MUST** be defined and it contains the additional interactivity extension name that defines the operation. If the `extension` property is not defined and the operation is not defined by this Specification, the declaration is invalid and the graph **MUST** be rejected.

Values of the `extension` property are case-sensitive.

If the operation is defined in an additional interactivity extension and it uses input value sockets, the `inputValueSockets` object **MUST** be present. Its properties define ids and the values of its properties define types of the input value sockets. If the `inputValueSockets` object is undefined, the operation has no input value sockets.

If the operation is defined in an additional interactivity extension and it uses output value sockets, the `outputValueSockets` object **MUST** be present. Its properties define ids and the values of its properties define types of the output value sockets. If the `outputValueSockets` object is undefined, the operation has no output value sockets.

Socket ids defined by the properties of the `inputValueSockets` and `outputValueSockets` objects are case-sensitive.

If the `extension` property is undefined, the operation with all its value sockets is assumed to be provided by this Specification and therefore `inputValueSockets` and `outputValueSockets` objects **MUST NOT** be defined.

[NOTE]
.Example
====
This example defines a declaration that maps to the `event/onSelect` operation defined in the `KHR_node_selectability` extension. The operations has three output value sockets and zero input value sockets.

```json
"types": [
  { "signature": "int" },
  { "signature": "float3" }
],
"declarations": [
  {
    "op": "event/onSelect",
    "extension": "KHR_node_selectability",
    "outputValueSockets": {
      "selectedNodeIndex": { "type": 0 },
      "controllerIndex":   { "type": 0 },
      "selectionPoint":    { "type": 1 }
    }
  }
]
```
====

The type of the value socket is determined by the **REQUIRED** `type` property that points to the element of the `types` array. If the `type` property is undefined or its value is negative or greater than or equal to the length of the `types` array, the declaration is invalid and the graph **MUST** be rejected.

Two declarations are considered equal if their `op` properties have the same value, their `extension` properties (if present) have the same value, and their `inputValueSockets` objects (if present) define the same socket ids with the same type indices. The `declarations` array **MUST NOT** have equal declarations; if two or more declarations are equal, all of them are invalid and the graph **MUST** be rejected.

[NOTE]
.Example
====
All three declarations in this example are equal thus they all are invalid.

```json
"types": [
  { "signature": "int" },
  { "signature": "float" }
],
"declarations": [
  {
    "op": "math/min3",
    "extension": "VND_interactivity_min3",
    "inputValueSockets": {
      "a": { "type": 0 },
      "b": { "type": 0 },
      "c": { "type": 0 }
    },
    "outputValueSockets": {
      "value": { "type": 0 }
    }
  },
  {
    "op": "math/min3",
    "extension": "VND_interactivity_min3",
    "inputValueSockets": {
      "b": { "type": 0 },
      "a": { "type": 0 },
      "c": { "type": 0 }
    },
    "outputValueSockets": {
      "value": { "type": 0 }
    }
  },
  {
    "op": "math/min3",
    "extension": "VND_interactivity_min3",
    "inputValueSockets": {
      "a": { "type": 0 },
      "b": { "type": 0 },
      "c": { "type": 0 }
    },
    "outputValueSockets": {
      "value": { "type": 1 }
    }
  }
]
```
====

=== Unsupported Declarations

A declaration is considered unsupported if any of the following conditions is true:

- The declaration refers to an unsupported or disabled extension.
- The referred extension does not define the operation.
- Neither of the definitions of the operation in the referred extension has exactly the same input and output value sockets with regards to their ids and types.

If the declaration is unsupported, the nodes referring to it are demoted to <<nodes-noop,"`no-op`" nodes>>.

[[json-nodes]]
== Nodes

The `nodes` array defines the nodes and their connections.

Each element of the `nodes` array specifies the node's operation via a declaration index, sources for the input value sockets, pointers for the output flow sockets, and its configuration.

=== Operation

The operation is specified by the **REQUIRED** `declaration` property that points to an element of the `declarations` array. If that property is undefined or its value is negative or greater than or equal to the number of declarations, the node is invalid and the graph **MUST** be rejected.

[NOTE]
.Example
====
A `math/E` node with its declaration.

```json
"declarations": [
  { "op": "math/E" }
],
"nodes": [
  { "declaration": 0 }
]
```
====

=== Input Value Sockets

If the operation has input value sockets, the `values` object **MUST** be defined and it *MUST** have properties matching the input value socket ids defined by the declaration and/or configuration; if the `values` object does not have a corresponding property for each input value socket id, the node is invalid and the graph **MUST** be rejected. The `values` object **MAY** have additional properties not matching the input value socket ids of the operation; such properties have no effect on the operation but their values **MUST** still conform to the JSON schema and other rules defined in this section. If the operation does not have input value sockets, the `values` object **SHOULD NOT** be defined.

Some operations, e.g., `pointer/get` or `variable/get`, define their input value socket ids and/or types based on the node's configuration. Therefore, the configuration **MAY** need to be processed prior to the input value sockets.

The values of the `values` object properties are JSON objects that define effective input value socket types and value sources. Each value source is either an inline constant value, a <<variables-types,type-default>> value, or a reference to another node's output value socket. If no source is defined or if the socket type does not match the declaration, the node is invalid and the graph **MUST** be rejected.

Socket ids defined by the properties of the `values` object are case-sensitive.

Some nodes have multiple variants to support the same operation on different input value socket types. In all such cases, the variants share the same set of input value socket ids and only their types differ. Therefore, effective input value socket types **MAY** be needed to fully resolve the operation.

If the operation does not support the input value socket types used by the node, the node is invalid and the graph **MUST** be rejected.

[NOTE]
.Example
====
For example, the `math/add` operation defined in this Specification supports all numeric types, i.e., integers, vectors, and matrices, but only for matching input value socket types. So any node that refers to `math/add` and uses different types for its `a` and `b` input value sockets would be invalid.
====

==== Inline Values

If the `value` property is defined in the object representing the input value socket, the input value socket source is an inline constant.

The `value` property has the same syntax as the `value` property of variable definitions. The type of the input value socket is determined by the `type` property that points to the element of the `types` array and **MUST** be defined. If the `type` property value is negative or greater than or equal to the number of types, the node is invalid and the graph **MUST** be rejected.

[NOTE]
.Example
====
A `math/add` node with two integer inline values: 1 and 2.

```json
"types": [
  { "signature": "int" }
],
"declarations": [
  { "op": "math/add" }
],
"nodes": [
  {
    "declaration": 0,
    "values": {
      "a": { "value": [ 1 ], "type": 0 },
      "b": { "value": [ 2 ], "type": 0 }
    }
  }
]
```
====

==== Output Socket References

If the `node` property is defined in the object representing the input value socket, the input value socket source is the output value socket of another node of the graph. If both `node` and `value` properties are defined for the same input value socket, the node is invalid and the graph **MUST** be rejected.

The `node` property contains the index of the other node and the `socket` property contains the id of the output socket of that node.

If the `node` property value is negative or greater than or equal to the index of the current node, the node is invalid and the graph **MUST** be rejected.

[NOTE]
.Rationale
====
This ensures that value sockets do not form loops and simplifies input value socket type derivation.
====

If the `socket` property is defined, it **MUST** correspond to an output value socket existing in the referenced node, otherwise the current node is invalid and the graph **MUST** be rejected. If the `socket` property is undefined, the default socket id `"value"` is used implicitly. Therefore, if the referenced node does not have an output value socket with id `"value"`, the `socket` property **MUST** be defined.

Socket ids referenced by the `socket` property are case-sensitive.

If both `node` and `type` properties are defined, the type referred by the `type` property **MUST** match the type of the referenced output value socket; if the types do not match, the current node is invalid and the graph **MUST** be rejected.

[NOTE]
.Rationale
====
Although explicitly defining input value socket types is generally redundant for input value sockets referring to other nodes, providing this information could improve debugging experience during graph development.
====

[NOTE]
.Example
====
A `math/sub` node with two input value sockets referring to output value sockets of two other nodes. The input socket `a` refers to the output socket id explicitly and the input socket `b` relies on the implicit output socket id.

```json
"types": [
  { "signature": "float" }
],
"declarations": [
  { "op": "math/Pi" },
  { "op": "math/E" },
  { "op": "math/sub" }
],
"nodes": [
  { "declaration": 0 },
  { "declaration": 1 },
  {
    "declaration": 2,
    "values": {
      "a": { "node": 0, "socket": "value" },
      "b": { "node": 1 }
    }
  }
]
```
====

==== Type-Default Values

If neither `value` nor `node` properties are defined in the object representing the input value socket, the input value socket has a <<variables-types,type-default>> value determined by the `type` property that points to the element of the `types` array and **MUST** be defined. If the `type` property value is negative or greater than or equal to the number of types, the node is invalid and the graph **MUST** be rejected.

[NOTE]
.Example
====
A `math/isNaN` node with a type-default input value socket. The output value of this node is true because the input value socket `a` has a constant value of NaN (type-default for `float`).

```json
"types": [
  { "signature": "float" }
],
"declarations": [
  { "op": "math/isNaN" }
],
"nodes": [
  {
    "declaration": 0,
    "values": {
      "a": { "type": 0 }
    }
  }
]
```
====

=== Output Flow Socket Pointers

Pointers for the output flow sockets are defined in the `flows` object of the node.

Properties of the `flows` object link output flow sockets of the current node with input flow sockets of other nodes. If an output flow socket id of the current node is not present in the `flows` object, that output flow socket is unconnected and activating it has have no effect.

Socket ids defined by the properties of the `flows` object are case-sensitive.

The `flows` object **MAY** contain properties not corresponding to output flows of the current node; such properties do not affect functionality of the node but their values **MUST** still be validated as described below.

Each property of the `flows` object is a JSON object containing a **REQUIRED** `node` property and an **OPTIONAL** `socket` property. The `node` property contains the index of the other node and the `socket` property contains the id of the input flow socket of that node.

Socket ids referenced by the `socket` property are case-sensitive.

The `node` property value **MUST** be greater than the index of the current node and less then the total number of nodes, otherwise the node is invalid and the graph **MUST** be rejected.

[NOTE]
.Rationale
====
This ensures that flow sockets do not form loops.
====

If the `socket` property is undefined, it has a default value of `"in"`.

If the `socket` property value corresponds to an input flow socket existing in the referenced node, the output flow socket of the current node is connected to the referenced input flow socket. If the specified input flow socket does not exist in the referenced node, the output flow socket of the current node is unconnected and activating it **MUST** have no effect.

[NOTE]
.Example
====
A `flow/setDelay` node that starts an animation after a certain amount of time since the start of the graph execution.

The `out` output flow of the `event/onStart` node is connected to the `in` input flow of the `flow/setDelay` node explicitly. Then, the `out` output flow of the latter node is connected to the `in` input flow of the `animation/start` node implicitly.

```json
"types": [
  { "signature": "float" },
  { "signature": "int" }
],
"declarations": [
  { "op": "event/onStart" },
  { "op": "flow/setDelay" },
  { "op": "math/Inf" },
  { "op": "animation/start" }
],
"nodes": [
  {
    "declaration": 0,
    "flows": {
      "out": { "node": 1, "socket": "in" }
    }
  },
  {
    "declaration": 1,
    "values": {
      "duration": { "type": 0, "value": [ 5 ] }
    },
    "flows": {
      "out": { "node": 3 }
    }
  },
  {
    "declaration": 2
  },
  {
    "declaration": 3,
    "values": {
      "animation": { "type": 1 },
      "startTime": { "type": 0, "value": [ 0 ] },
      "endTime": { "node": 2 },
      "speed": { "type": 0, "value": [ 1 ] }
    }
  }
]
```
====

=== Configuration

Configuration properties are defined in the `configuration` object of the node.

Each property of the `configuration` object is a JSON object with a single `value` property. The type of the `value` property is determined by the node's specification, i.e., configuration values are implicitly typed.

[NOTE]
.Rationale
====
Some nodes have configuration values of types that cannot be expressed with the explicit types defined in this Specification.
====

Refer to the <<nodes-configuration,Configuration>> section and to individual node specifications for details regarding configuration validity.

Configuration properties defined by the properties of the `configuration` object are case-sensitive.

Configuration values use JSON arrays similarly to other uses of inline values.

[cols="1,2", options="header"]
|===
|  Configuration Type | JSON Type
| `bool`              | Array of one boolean
| `int`               | Array of one number exactly representable as a 32-bit signed integer
| `int[]`             | Array of one or more numbers exactly representable as 32-bit signed integers
| `string`            | Array of one JSON string
|===

[NOTE]
.Example
====
The `variable/set` node sets a custom variable with index `0` when the start event happens.

```json
"types": [
  { "signature": "float" }
],
"variables": [
  { "type": 0 }
],
"declarations": [
  { "op": "event/onStart" },
  { "op": "variable/set" }
],
"nodes": [
  {
    "declaration": 0,
    "flows": {
      "out": { "node": 1 }
    }
  },
  {
    "declaration": 1,
    "configuration": {
      "variables": { "value": [ 0 ] }
    },
    "values": {
      "0": { "type": 0, "value": [ 1.5 ] }
    }
  }
]
```
====

[[validation]]
= Validation (Informative)

This section describes steps needed to check validity of the interactivity extension object according to the normative language of the previous sections and the corresponding JSON schemas.

[[validation-glossary]]
== Validation Glossary

This section uses the following terms:

assert::
continue iff the associated condition is true; otherwise _reject the extension_

JSON index::
a non-negative JSON number that is exactly representable as an integer, e.g., JSON numbers `2`, `2.0`, and `0.2e1` are exactly representable as integer two

reject the extension::
the whole interactivity extension object is invalid and thus cannot be used

reject the graph::
the interactivity graph is invalid and thus cannot be used; this has no effect on other graphs defined in the extension

[[validation-extension-object]]
== Extension Object Validation

1. _Assert_ that the interactivity extension object has the `graphs` property that is a non-empty JSON array.
2. Validate each element of the `graphs` array as described in <<validation-graph-object,Graph Object Validation>>.
3. If the interactivity extension object has the `graph` property:
.. _assert_ that the `graph` property value is a _JSON index_;
.. if the `graph` property value is not less than the `graphs` array length,
... _reject the extension_;
.. if the graph referenced by the `graph` property value is invalid,
... _reject the extension_.

[[validation-graph-object]]
== Graph Object Validation

1. _Assert_ that the element of the `graphs` array is a JSON object ("`the graph`").
2. If "`the graph`" object has the `types` property:
.. _assert_ that the `types` property is a non-empty JSON array;
.. if the `types` array length is greater than the implementation-specific limit on the number of used types, _reject the graph_;
.. for each element of the `types` array:
... _assert_ that the element of the `types` array is a JSON object ("`the type`");
... _assert_ that "`the type`" object has the `signature` property that is a JSON string;
... if the `signature` property value is not `"bool"`, `"custom"`, `"float"`, `"float2"`, `"float3"`, `"float4"`, `"float2x2"`, `"float3x3"`, `"float4x4"`, or `"int"`,
.... _reject the graph_;
.. if two or more elements of the `types` array have the same `signature` value that is not `"custom"`,
... _reject the graph_.
3. If "`the graph`" object has the `variables` property:
.. _assert_ that the graph has the `types` property;
.. _assert_ that the `variables` property is a non-empty JSON array;
.. if the `variables` array length is greater than the implementation-specific limit on the number of variables,
... _reject the graph_;
.. validate each element of the `variables` array as described in the <<validation-variable-object,Variable Object Validation>> section.
4. If "`the graph`" object has the `events` property:
.. _assert_ that the `events` property is a non-empty JSON array;
.. if the `events` array length is greater than the implementation-specific limit on the number of event definitions,
... _reject the graph_;
.. validate each element of the `events` array as described in the <<validation-event-object,Event Object Validation>> section;
.. if two or more elements of the `events` array have the same `id` value that is not undefined,
... _reject the graph_.
5. If "`the graph`" object has the `declarations` property:
.. _assert_ that the `declarations` property is a non-empty JSON array;
.. if the `declarations` array length is greater than the implementation-specific limit on the number of declarations,
... _reject the graph_;
.. validate each element of the `declarations` array as described in the <<validation-declaration-object,Declaration Object Validation>> section.
6. If "`the graph`" object has the `nodes` property:
.. _assert_ that the `nodes` property is a non-empty JSON array;
.. if the `nodes` array length is greater than the implementation-specific limit on the number of nodes,
... _reject the graph_;
.. validate each element of the `nodes` array as described in the <<validation-node-object,Node Object Validation>> section.

[[validation-variable-object]]
== Variable Object Validation

1. _Assert_ that the element of the `variables` array is a JSON object ("`the variable`").
2. _Assert_ that "`the variable`" object has the `type` property that is a _JSON index_.
3. If the `type` property value is not less than the `types` graph array length,
.. _reject the graph_.
4. If the "`the variable`" object has the `value` property:
.. _assert_ that the `value` property is a non-empty JSON array;
.. validate the `value` property value according to the <<inline-value-validation,Inline Value Validation>> section using the `type` property value.

[[validation-event-object]]
== Event Object Validation

1. _Assert_ that the element of the `events` array is a JSON object ("`the event`").
2. If "`the event`" object has the `id` property,
.. _assert_ that the `id` property value is a JSON string.
3. If "`the event`" object has the `values` property,
.. _assert_ that the `values` property is a non-empty JSON object;
.. if the `values` object has more properties than the implementation-specific limit on the number of event value sockets,
... _reject the graph_;
.. for each property of the `values` JSON object:
... _assert_ that the property is a JSON object ("`the event value`");
... _assert_ that "`the event value`" object has the `type` property that is a _JSON index_;
... if the `type` property value is not less than the `types` graph array length,
.... _reject the graph_;
... if the "`the event value`" object has the `value` property:
.... _assert_ that the `value` property is a non-empty JSON array;
.... validate the `value` property value according to the <<inline-value-validation,Inline Value Validation>> using the `type` property.

[[validation-declaration-object]]
== Declaration Object Validation

1. _Assert_ that the element of the `declarations` array is a JSON object ("`the declaration`").
2. _Assert_ that "`the declaration`" object has the `op` property that is a JSON string.
3. If "`the declaration`" object does not have the `extension` property:
.. if the `op` property value does not match any operation defined in this Specification,
... _reject the graph_;
.. if "`the declaration`" object has the `inputValueSockets` and/or `outputValueSockets` properties,
... _reject the graph_;
4. If "`the declaration`" object has the `extension` property:
.. _assert_ that the `extension` property is a JSON string;
.. if the "`the declaration`" object has the `inputValueSockets` property:
... _assert_ that the `inputValueSockets` property is a non-empty JSON object;
... if the `inputValueSockets` object has more properties than the implementation-specific limit on the number of input value sockets for declarations,
.... _reject the graph_;
... _assert_ that the graph has the `types` property;
... for each property of the `inputValueSockets` JSON object:
.... _assert_ that the property is a JSON object ("`the input value socket declaration`");
.... _assert_ that "`the input value socket declaration`" object has the `type` property that is a _JSON index_;
.... if the `type` property value is not less than the `types` graph array length,
..... _reject the graph_;
.. if "`the declaration`" object has the `outputValueSockets` property:
... _assert_ that the `outputValueSockets` property is a non-empty JSON object;
... if the `outputValueSockets` object has more properties than the implementation-specific limit on the number of output value sockets for declarations,
.... _reject the graph_;
... _assert_ that the graph has the `types` property;
... for each property of the `outputValueSockets` JSON object:
.... _assert_ that the property is a JSON object ("`the output value socket declaration`");
.... _assert_ that "`the output value socket declaration`" object has the `type` property that is a _JSON index_;
.... if the `type` property value is not less than the `types` graph array length,
..... _reject the graph_.

[[validation-node-object]]
== Node Object Validation

1. _Assert_ that the element of the `nodes` array is a JSON object ("`the node`").
2. _Assert_ that "`the node`" object has the `declaration` property that is a JSON index.
3. If the `declaration` property value is not less than the `declarations` graph array length,
.. _reject the graph_.
4. If "`the node`" object has the `configuration` property:
.. _assert_ that the `configuration` property is a non-empty JSON object;
.. for each property of the `configuration` JSON object:
... _assert_ that the property is a JSON object ("`the configuration property`");
... _assert_ that "`the configuration property`" object has the `value` property that is a non-empty JSON array.
5. If the node is configurable as indicated by the operation referenced by the `declaration` property and the node does not support a default configuration:
.. if "`the node`" does not have the `configuration` property,
... _reject the graph_;
.. if `configuration` object is not valid as defined by the node,
... _reject the graph_.
6. If the node is configurable, the configuration affects the node's sockets, and applying the specified configuration would lead to exceeding any implementation-specific limit,
.. _reject the graph_;
7. If "`the node`" object has the `values` property:
.. _assert_ that the `values` property is a non-empty JSON object;
.. for each property of the `values` JSON object:
... _assert_ that the property is a JSON object ("`the input value socket`");
... if "`the input value socket`" object has the `node` property:
.... _assert_ that "`the input value socket`" object does not have the `value` property;
.... _assert_ that the `node` property is a JSON index;
.... if the `node` property value is not less than the index of the current element of the `nodes` array,
..... _reject the graph_;
.... let "`the effective socket id`" be `"value"`;
.... if "`the input value socket`" object has the `socket` property:
..... _assert_ that the `socket` property is a JSON string;
..... set "`the effective socket id`" to the value of the `socket` property;
.... if the graph node referenced by the `node` property does not have the output value socket with id equal to "`the effective socket id`",
..... _reject the graph_;
.... if "`the input value socket`" object has the `type` property:
..... _assert_ that the `type` property is a _JSON index_;
..... if the `type` property value is not less than the `types` graph array length,
...... _reject the graph_;
..... if the type of the referenced output value socket does not match the type referenced by the `type` property value,
...... _reject the graph_;
... if "`the input value socket`" object does not have the `node` property:
.... _assert_ that "`the input value socket`" object has the `type` property that is a _JSON index_;
.... if the `type` property value is not less than the `types` graph array length,
..... _reject the graph_;
.... if "`the input value socket`" object has the `value` property:
..... _assert_ that the `value` property is a non-empty JSON array;
..... validate the `value` property value according to the <<inline-value-validation,Inline Value Validation>> using the `type` property.
8. Let "`the operation inputs`" be the set (or the sets in case of overloaded operations) of input value sockets defined by the declaration and/or derived from the configuration.
9. If any input value socket id present in "`the operation inputs`" is not present in the set of input value sockets defined by the `values` property,
.. _reject the graph_.
10. If the types of input value sockets defined by the `values` property excluding sockets with ids not present in "`the operation inputs`" do not match any set of the input value socket types present in "`the operation inputs`",
.. _reject the graph_.
11. If "`the node`" object has the `flows` property:
.. _assert_ that the `flows` property is a non-empty JSON object;
.. if the `flows` object has more properties than the implementation-specific limit on the number of output flow sockets per node,
... _reject the graph_;
.. for each property of the `flows` JSON object:
... _assert_ that the property is a JSON object ("`the output flow socket`");
... _assert_ that "`the output flow socket`" object has the `node` property that is a JSON index;
... if the `node` property value is not greater than the index of the current element of the `nodes` array,
.... _reject the graph_;
... if "`the output flow socket`" object has the `socket` property,
.... _assert_ that the `socket` property is a JSON string.

[[inline-value-validation]]
== Inline Value Object Validation

1. Let "`the array`" be the JSON array representing the inline value and "`the type signature`" be the type signature associated with it.
2. If "`the type signature`" is `"bool"`, `"float"`, or `"int"` and "`the array`" length is not one,
.. _reject the graph_.
3. If "`the type signature`" is `"float2"` and "`the array`" length is not two,
.. _reject the graph_.
4. If "`the type signature`" is `"float3"` and "`the array`" length is not three,
.. _reject the graph_.
5. If "`the type signature`" is `"float4"` or `"float2x2"` and "`the array`" length is not four,
.. _reject the graph_.
6. If "`the type signature`" is `"float3x3"` and "`the array`" length is not nine,
.. _reject the graph_.
7. If "`the type signature`" is `"float4x4"` and "`the array`" length is not 16,
.. _reject the graph_.
8. If "`the type signature`" is `"bool"` and the only element of "`the array`" is not a JSON boolean,
.. _reject the graph_.
9. If "`the type signature`" is `"int"` and the only element of "`the array`" is not exactly representable as a 32-bit signed integer,
.. _reject the graph_.
10. If "`the type signature`" is any of the seven float types defined in this Specification and any element of "`the array`" is not a JSON number,
.. _reject the graph_.
